\documentclass[12pt,a4paper,oneside]{abntex2}



\input{configuracoes}


% Informações de dados para CAPA e FOLHA DE ROSTO

\include{capa}
\begin{document}

% Seleciona o idioma do documento 
\selectlanguage{brazil}

% Capa


% Folha de rosto
%\imprimirfolhaderosto*

% Para gerar a ficha bibliográfica acesse:
% https://biblioteca.ufes.br/ficha-catalografica-cip

% Inserir a ficha bibliografica gerada pela biblioteca
\begin{fichacatalografica}
    \includepdf{fig_ficha_catalografica.pdf}
\end{fichacatalografica}

% Folha de aprovação
\begin{folhadeaprovacao}
\includepdf{folhadeaprovacao_final.pdf}
\end{folhadeaprovacao}

% Folha de aprovação editável
\begin{folhadeaprovacao}

  \begin{center}
    % Remover após edição da folha de aprovação
    \textbf{Editável}
    
    %{\ABNTEXchapterfont\large\imprimirautor}

    \vspace*{\fill}\vspace*{\fill}
    \begin{center}
    %  \ABNTEXchapterfont\bfseries\Large\imprimirtitulo
    \end{center}
    \vspace*{\fill}
    
    \hspace{.45\textwidth}
    \begin{minipage}{.5\textwidth}
        \imprimirpreambulo
    \end{minipage}%
    \vspace*{\fill}
   \end{center}
        
   Trabalho aprovado. \imprimirlocal, \today:

   \assinatura{\textbf{\imprimirorientador} \\ Universidade Federal do Espírito Santo \\ Orientador} 
   \assinatura{\textbf{Prof. Dr. Convidado 1} \\ Universidade Federal do Espírito Santo \\ Membro Interno}
   \assinatura{\textbf{Prof. Dr. Convidado 2} \\ Instituição \\ Membro Externo}
   
   \begin{center}
    \vspace*{0.5cm}
    {\large\imprimirlocal}
    \par
   % {\large\imprimirdata}
    \vspace*{1cm}
  \end{center}
  
\end{folhadeaprovacao}


% Dedicatória
\begin{dedicatoria}
   \vspace*{\fill}
   \centering
   \noindent
   \textit{Texto referente a dedicatória.} \vspace*{\fill}
\end{dedicatoria}


% Agradecimentos
\begin{agradecimentos}
Texto referente aos agradecimentos.
\end{agradecimentos}


% Epígrafe
\begin{epigrafe}
    \vspace*{\fill}
	\begin{flushright}
		\textit{``Texto referente a epigrafe." \\
		(Indicar fonte do texto)}
	\end{flushright}
\end{epigrafe}


% RESUMOS

% Resumo em português
\setlength{\absparsep}{18pt} % Espaçamento dos parágrafos
\begin{resumo}
Texto referente ao resumo em português.

 \textbf{Palavras-chave}: Palavras-chave em português
\end{resumo}

% resumo em inglês
\begin{resumo}[Abstract]
 \begin{otherlanguage*}{english}
   This is the english abstract.

   \vspace{\onelineskip}
 
   \noindent 
   \textbf{Keywords}: Keywords in english
 \end{otherlanguage*}
\end{resumo}


% Lista de ilustrações
\pdfbookmark[0]{\listfigurename}{lof}
\listoffigures*
\cleardoublepage

% Lista de quadros
%\pdfbookmark[0]{\listofquadrosname}{loq}
%\listofquadros*
%\cleardoublepage

% Lista de tabelas
\pdfbookmark[0]{\listtablename}{lot}
\listoftables*
\cleardoublepage

% Lista de abreviaturas e siglas
%\begin{siglas}
%  \item[ABNT] Associação Brasileira de Normas Técnicas
%  \item[abnTeX] ABsurdas Normas para TeX
%\end{siglas}

% Lista de símbolos
%\begin{simbolos}
%  \item[$ \Gamma $] Letra grega Gama
%  \item[$ \Lambda $] Lambda
%  \item[$ \zeta $] Letra grega minúscula zeta
%  \item[$ \in $] Pertence
%\end{simbolos}

% Sumário
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage


% ---------------------------------------------------------
% ELEMENTOS TEXTUAIS
\textual

% ---------------------------------------------------------
\chapter{prefácio:}
"Neste trabalho, utilizamos o ChatGPT (OpenAI, 2021) como uma ferramenta auxiliar para criação do livro. O ChatGPT é um modelo de linguagem de grande escala treinado por meio de técnicas de aprendizado profundo e possui uma vasta base de conhecimentos sobre linguagem natural."



\chapter{Introduçao a Linguagem Rust :}




%----------------------------------------------------------------
 \section{O que é Rust:}
Rust é uma linguagem de programação desenvolvida pelo Mozilla Research. Sendo criada para ser segura, rápida e concisa, com um foco na eficiência e na performance.
A linguagem Rust possui uma sintaxe similar ao C++, mas adiciona algumas características modernas, como tipagem forte e estática, gerenciamento de memória seguro e um sistema de empréstimos que permite aos programadores controlar o acesso e o uso da memória de maneira explícita que iremos ver ainda neste capítulo. Isso torna o Rust ideal para aplicações que precisam de desempenho elevado, com segurança e estabilidade, ideal para aplicação de kernel de sistemas operacionais, sistemas backend, CLI's entre outras. 

Além disso, a comunidade Rust é conhecida por ser muito ativa e colaborativa. Os desenvolvedores contribuem frequentemente com o código do núcleo da linguagem, bem como com bibliotecas e ferramentas. Em pesquisa no Stackoverflow o Rust foi elegido como linguagem mais amada pelo setimo ano seguido, isso se dá pela comunidade forte e ao retorno do seu compilador que é intuitivo para solução dos erros e dicas para melhoria da performance e segurança de memoria. 


\section{Como instalar o Rust no Windows, Linux e MacOS}
Agora que você conheceu um pouco da linguagem, vamos instalar o Rust no seu computador: 
\subsection{Instalação no windows:}
\begin{enumerate}
    \item Baixe o instalador do Rust no site oficial disponivel em (https://www.rust-lang.org/tools/install). 
    \item Execute o instalador baixado e siga as instruções na tela para instalar o Rust. Isso
inclui a instalação do compilador Rust ("rustc") e do gerenciador de pacotes Cargo
\end{enumerate}
\subsection{Instação no Linux :}
Para instalar o Rust no Linux, basta seguir os seguintes passos:
\begin{enumerate}
    \item Abra o terminal e atualize o gerenciador de pacotes do seu sistema digitando o comando \textbf{sudo apt update}    (para sistemas baseados em Debian) ou  \textbf{sudo dnf update}  (para sistemas baseados em Fedora).
    \item Instale o compilador Rust e o gerenciador de pacotes Cargo digitando o comando \textbf{sudo apt install rustc cargo}
 (para sistemas baseados em Debian) ou \textbf{ sudo dnf install rustc
cargo} (para sistemas baseados em Fedora).
\item Depois de instalado, o Rust estará disponível no seu sistema. Você pode verificar se a instalação foi bem-sucedida digitando os comandos \textbf{rustc --version} e \textbf{cargo --version }no terminal. Isso deve exibir as versões do rustc e do Cargo instaladas no seu sistema.
\end{enumerate}

\subsection{Instalando Rust no MacOs}

Para instalar o Rust no Mac, basta seguir os seguintes passos:
\begin{enumerate}
    \item Abra o terminal e atualize o gerenciador de pacotes Homebrew digitando o comando \textbf{brew update}.
    \item Instale o compilador Rust e o gerenciador de pacotes Cargo digitando o comando \textbf{brew install rust}.
    \item Repita o procedimento de verificação do Linux. Digitando os comandos \textbf{rustc --version} e \textbf{cargo --version }no terminal.
\end{enumerate}
\section{O gerenciador de pacotes Cargo}
Como observamos no processo de instalação, a ferramenta cargo é muito importante para o Rust. O cargo tem a função de :
\begin{itemize}
\item Gerenciamento de dependências: o Cargo permite que você especifique as bibliotecas e outras dependências do seu projeto em um arquivo chamado Cargo.toml, e ele cuidará de baixar e instalar essas dependências automaticamente.
    \item Compilação de código: o Cargo pode compilar o código do seu projeto automaticamente, e é possível especificar configurações de compilação como opções de linha de comando ou em um arquivo chamado .cargo/config.

    \item Criação de binários para distribuição: o Cargo pode criar binários (arquivos executáveis) para distribuição em diferentes plataformas. 
\end{itemize}



\section{Como é a sintaxe do Rust:}

Como ja dito a sintaxe do Rust é inspirada em outras linguagens de programação de alto nível, como C++ e Python, o que a torna relativamente fácil de aprender para quem já tem experiência em outras linguagens.

A seguir, estão alguns exemplos de como o Rust é sintaticamente:


%%\lstinputlisting[language=rust, caption = Declaração de variáveis onde x é uma variável do tipo inteiro e y do tipo String]{codigos/captulo1/exemplos/src/2_variavies/declararVariaveis.rs}
%%\lstinputlisting[language=rust, caption = Declaração de estruturas de controler :]{codigos/captulo1/if-else.rs}
%%\lstinputlisting[language=rust, caption = Declaração de estruturas de loop :]{codigos/captulo1/loop.rs}
%%\lstinputlisting[language=rust, caption = Declaração de funcoes  no exemplo uma função que soma duas variavies do tipo inteiros de 32 bytes que retorna um inteiro também de 32 bytes :]{codigos/captulo1/funcoes.rs}

Como pode ser visto, a sintaxe do Rust é clara e concisa, o que a torna fácil de ler e escrever. Além disso, o Rust tem uma grande variedade de recursos avançados como tipagem forte , estática e a imultabilidade de variáveis que veremos mais aprofunadmente mais a frente.



\section{Como é o processo de compilação em Rust}

O processo de compilação em Rust é relativamente simples. Primeiramente, é preciso instalar o compilador Rust (chamado de "rustc") e o gerenciador de pacotes Cargo como ja vimos anteriormente.
Uma vez que o rustc e o Cargo estão instalados, é possível compilar um programa Rust usando o seguinte processo:
\begin{enumerate}
    \item Crie um novo projeto usando o comando :
    %\lstinputlisting[language=Bash, caption = Isso criará uma nova pasta com a estrutura de arquivos básica para um projeto Rust]{codigos/captulo1/exemplos/src/1_comandos/criarprojeto.sh}
    \item Abra o arquivo src/main.rs no seu editor de texto preferido. Esse arquivo é o ponto de entrada do programa, e é onde você escreverá o código principal.
    \item Escreva o código Rust no arquivo main.rs. Exemplo :
    %\lstinputlisting[language=rust, caption = Hello World em Rust]{codigos/captulo1/exemplo1.rs}
    \item entre na pasta do projeto pelo terminal:
    \item execute o comando :
        %\lstinputlisting[language=Bash, caption =Isso cria um arquivo executável em target/debug/nome-do-projeto ]{codigos/captulo1/exemplos/src/1_comandos/cargobuider.sh}
    \item Agora você pode executar com este comando:
    %\lstinputlisting[language=Bash, caption =Rode para executar o projeto Rust ]{codigos/captulo1/exemplos/src/1_comandos/comnd.sh}
    \item Você também pode usar o comando  cargo run para compilar um codigo rust.Teste executando o programa usando o comando cargo run.
\end{enumerate}

\subsection{Variáveis}
As variáveis são espaços na memória de um computador que podem armazenar informações temporárias, como números, texto ou valores lógicos (verdadeiro/falso). Em outras palavras, elas são como caixas onde podemos guardar dados que queremos usar mais tarde em nosso programa.

As variáveis têm um nome que as identifica e um valor que é armazenado dentro delas. Esse valor pode ser alterado durante a execução do programa, permitindo que o programa faça cálculos, tome decisões e realize outras tarefas.

Depois de declarada, a variável pode ser usada em qualquer lugar do seu código como se fosse um valor literal. Para entender claramente o papel das variáveis, basta associar os recipientes do mundo real. Se você deseja guardar água, então provavelmente você irá utilizar uma jarra, se você deseja guardar biscoitos, então provavelmente você irá utilizar um pote hermético, se quiser guardar ovos, então irá utilizar uma caixa de ovos. 
Em programação, as variáveis são como recipientes que armazenam valores durante a execução de um programa. Elas permitem que você armazene dados em memória e os use em diferentes partes do seu código.

Para usar uma variável em Rust, é preciso declará-la primeiro, informando o tipo de dado que ela armazenará. Por exemplo:

%\lstinputlisting[language=rust, caption = exemplo de declaração de variável ]{codigos/captulo1/variavel.rs}

Neste exemplo, a variável x é declarada como do tipo i32, o que significa que ela armazenará um número inteiro de 32 bits. O valor inicial da variável é definido como 5.


%\lstinputlisting[language=rust, caption = exemplo de manipulção de variavel ]{codigos/captulo1/soma.rs}

Em resumo, as variáveis são um elemento fundamental da programação, e são muito úteis para armazenar e manipular dados durante a execução de um programa. No Rust, é preciso declarar as variáveis explicitamente, informando o tipo de dado que elas armazenarão, o que permite que o compilador verifique a consistência e a segurança do código.

\section{Quais são os Tipos básicos da linguagem Rust}

A linguagem Rust possui uma variedade de tipos básicos que podem ser usados para armazenar diferentes tipos de dados. Alguns dos tipos básicos mais comuns são:

\begin{table}[h]
\begin{tabular}{|l|l|}
\hline
Tipos                           & Descrição                                                                                                                                                                                                                                \\ \hline
i8, i16, i32, i64, i128 e isize & \begin{tabular}[c]{@{}l@{}}Esses são tipos de inteiros de 8, 16, 32, 64, 128 bits e \\ tamanho de endereço, respectivamente. Eles são usados \\ para armazenar números inteiros sem ponto flutuante.\end{tabular}                        \\ \hline
u8, u16, u32, u64, u128 e usize & \begin{tabular}[c]{@{}l@{}}Esses são tipos de inteiros sem sinal de 8, 16, 32, 64, 128 \\ bits e tamanho de endereço, respectivamente. Eles são \\ usados para armazenar números inteiros positivos sem \\ ponto flutuante.\end{tabular} \\ \hline
f32 e f64                       & \begin{tabular}[c]{@{}l@{}}Esses são tipos de ponto flutuante de 32 e 64 bits, \\ respectivamente. Eles são usados para armazenar \\ números com ponto flutuante (números com casas\\  decimais).\end{tabular}                           \\ \hline
bool                            & Esse é tipo para verdadeiro ou false                                                                                                                                                                                                     \\ \hline
char                            & Esse tipo armazena um único caractere unicode.                                                                                                                                                                                           \\ \hline
str                             & Esse tipo armazena mais de um caractere unicode.                                                                                                                                                                                            \\ \hline
\end{tabular}
\end{table}
Além desses tipos básicos, o Rust também possui tipos compostos como arrays, tuplas e estruturas, que permitem armazenar múltiplos valores em uma única variável.

Agora que os tipos que foram apresentados, falta entender como definir uma variável. Em Rust 
para definir uma variável, basta usar a palavra-chave \textbf{let} seguida pelo nome da variável , opcionalmente, pelo tipo de dado que ela armazenará. Por exemplo:
%\lstinputlisting[language=rust, caption = exemplo de manipulção de variavel ]{codigos/captulo1/var1.rs}

No primeiro exemplo, a variável x é declarada explicitamente como do tipo i32, o que significa que ela armazenará um número inteiro de 32 bits. O valor inicial da variável é definido como 5.

No segundo exemplo, a variável y é declarada sem especificar o tipo, o que significa que o compilador Rust tentará inferir o tipo a partir do valor atribuído. No caso, o valor "Olá, mundo!" é uma string, então a variável y será do tipo str.

Aqui estão alguns exemplos de definição de variáveis do mundo real em Rust:
%\lstinputlisting[language=rust, caption = exemplo de tipos de variavel ]{codigos/captulo1/var2.rs}


Nesses exemplos, são definidas variáveis para armazenar o nome de uma pessoa, a idade, a altura, se assistiu a um filme e o filme favorito. Cada variável é declarada explicitamente com um tipo apropriado, de acordo com o tipo de dado que ela armazena.

Em resumo, esses são alguns exemplos de definição de variáveis do mundo real em Rust, mostrando como é possível armazenar diferentes tipos de dados em variáveis declaradas explicitamente com o tipo apropriado.



\subsection{Cuidado com nome de váriaveis}

 Assim como em outras linguagens, o Rust possui algumas regras para a definição de variáveis. Algumas dessas regras incluem:
\begin{enumerate}
    \item O nome de uma variável deve começar com uma letra ou um sublinhado, \\ e deve conter apenas letras, dígitos e sublinhados.
    \item O nome de uma variável não pode ser uma palavra-chave do Rust. As palavras-chave são palavras reservadas que possuem um significado especial na linguagem, e não podem ser usadas como nomes de variáveis.
    \item O nome de uma variável não pode ser um símbolo de sinal de menos (-), pois esse símbolo tem outro significado na linguagem.
    \item o Rust é "case sensitive", ou seja, letras maiúsculas e minúsculas são consideradas diferentes. Isso significa que, ao definir uma variável em Rust, é preciso escrevê-la exatamente como foi definida, caso contrário o compilador irá considerá-la uma variável diferente.

\end{enumerate}

\subsection{Operadores em Rust}

Em Rust, operadores são símbolos que representam ações a serem realizadas em cima de valores ou variáveis. Eles permitem realizar operações matemáticas, lógicas e de comparação, entre outras.

Algumas categorias de operadores em Rust incluem:

\begin{enumerate}
    \item Aritméticos: permitem realizar operações matemáticas, como soma (+), subtração (-), multiplicação (*), divisão (/) e resto da divisão ().

\item Atribuição: permitem atribuir um valor a uma variável, como o operador igual (\texttt{=}) ou operadores compostos, como (\texttt{+=}) que adiciona um valor a uma variável existente.

\item Lógicos: permitem realizar operações lógicas, como E (\&\&), OU (||) e NÃO (!).

\item Comparação: permitem comparar valores e variáveis, como igual (\texttt{==}), diferente (!\texttt{=}), maior (>), menor (<), maior ou igual (>\texttt{=}) e menor ou igual (<\texttt{=}).

\item Bitwise: permitem realizar operações em nível de bits, como "E" bitwise (\&), "OU" bitwise (|), deslocamento à esquerda (<<) e deslocamento à direita (>>).
\end{enumerate}


Além dos operadores básicos mencionados acima, Rust também oferece uma série de operadores mais avançados e específicos da linguagem, como o operador de referência (\&) e o operador de dereferência (*), usados para lidar com ponteiros e referências.

É importante lembrar que os operadores em Rust seguem regras de precedência, o que significa que alguns operadores têm prioridade sobre outros na hora de serem executados. Também é possível usar parênteses para forçar a ordem de execução dos operadores.


\section{Input e Output em RUST }

Entrada e Saída Para um programa de computador é fundamental a interação com dispositivos de entrada e de saída, pois é por meio da entrada que os programas recebem os dados e por meio de saída que são disponibilizadas às informações aos usuários. Isso é um princípio básico da computação. Essa interação pode ocorrer com vários dispositivos, mas, neste livro, será utilizado o teclado como dispositivo de entrada e o monitor como dispositivo de saída. 


%\lstinputlisting[language=rust, caption = exemplo de como ler uma linha de texto do teclado em Rust ]{codigos/captulo1/input.rs}



Para escrever dados no monitor, você pode usar a função println!(). Ela imprime uma string no monitor, seguida de um caractere de nova linha. Aqui está um exemplo de como imprimir uma string no monitor em Rust:

%\lstinputlisting[language=rust, caption = exemplo de imprimir caracter na tela ]{codigos/captulo1/print.rs}

\subsection{Formatadores no rust} 
A macro println!() em Rust permite especificar o formato de cada argumento a ser impressa usando formatadores de tipo. Os formatadores de tipo são símbolos especiais que indicam o tipo do argumento a ser impresso.

\begin{table}[]
\begin{tabular}{|l|l|}
\hline
Operador       & Tipo                                                                                                         \\ \hline
\{\}           & qualquer tipo                                                                                                \\ \hline
\{:b\}         & tipo inteiro - binário                                                                                       \\ \hline
\{  \}         & tipo caractere                                                                                               \\ \hline
\{:x\}         & tipo inteiro - hexadecimal                                                                                   \\ \hline
\{:o\}         & tipo inteiro- octal                                                                                          \\ \hline
\{:p\}         & tipo pointer                                                                                                 \\ \hline
\{:e\}ou\{:E\} & tipo float - notação cientifica                                                                              \\ \hline
\{:.2\}        & \begin{tabular}[c]{@{}l@{}}tipo float - com ate duas casa\\ decimais\end{tabular}                            \\ \hline
\{:,.2\}       & \begin{tabular}[c]{@{}l@{}}tipo float - com separação\\ de casa de milhar com 2 casa \\ decimal\end{tabular} \\ \hline
\end{tabular}
\end{table}
\vspace{8em}

%\lstinputlisting[language=rust, caption = exemplo de como ler uma linha de texto do teclado em Rust ]{codigos/captulo1/formatadores.rs}

\subsubsection{Operação de concatenação :}
Em Rust, o operador de concatenação é o ".to\_owned() +". Ele é usado para concatenar duas strings e produzir uma nova string como resultado.

Exemplo:
%\lstinputlisting[language=rust, caption = exemplo 1 de concatenar duas variavies string em Rust ]{codigos/captulo1/con.rs}

A saída para o código acima seria:
Ola, mundo!\\

Além do operador ".to\_owned() +", é possível concatenar strings usando o método ".to\_string()". Exemplo usando o método ".to\_string()":

%\lstinputlisting[language=rust, caption = exemplo 2 de concatenar duas variavies string em Rust ]{codigos/captulo1/con2.rs}


\section{Imutabilidade no rust :}
Em Rust, a imutabilidade é uma característica importante que ajuda a garantir a segurança e a estabilidade do código. Quando uma variável é declarada como imutável com a palavra-chave let, seu valor não pode ser alterado depois de ser inicializado. 

No exemplo da função de input, input é uma variável mútavel graças a palavra reservada "mut", caso não adicionado o "mut" teriamos a variavel imutável. Uma vez que input é imutável, não podemos alterar seu valor. Qualquer tentativa de mudar o valor resultará em um erro de compilação.

A imutabilidade é importante em Rust porque evita problemas de concorrência que podem surgir quando várias partes do código tentam modificar a mesma variável ao mesmo tempo. Em vez disso, cada parte do código pode ter sua própria cópia da variável e manipulá-la sem interferir nas outras partes.

A imutabilidade também ajuda a tornar o código mais fácil de entender e depurar, pois torna o comportamento da variável mais previsível. Quando uma variável é declarada como imutável, você sabe que seu valor não mudará durante a execução do programa, o que torna o código mais fácil de raciocinar e depurar.

No entanto, em alguns casos, é necessário alterar o valor de uma variável após a inicialização. Para esses casos, Rust oferece a palavra-chave mut, que torna a variável mutável. No entanto, o uso de variáveis mutáveis deve ser cuidadoso, pois pode levar a problemas de concorrência e erros difíceis de encontrar. Por isso, a imutabilidade é incentivada sempre que possível em Rust.
\section{O gerenciamento de memória seguro do Rust :} 
O gerenciamento de memória seguro é um recurso importante da linguagem Rust que ajuda a evitar erros comuns que podem ocorrer quando se trabalha com memória em linguagens de baixo nível, como o C. Em linguagens como o C, os programadores são responsáveis por alocar e liberar manualmente a memória, o que pode levar a erros como vazamentos de memória e acesso à memória inválida.

O Rust resolve esse problema com o sistema de empréstimos, que permite aos programadores controlar o acesso e o uso da memória de maneira explícita. Quando um objeto é "emprestado" a outro, o próprio Rust garante que o objeto original não será acessado enquanto o empréstimo estiver ativo, evitando problemas como acesso a memória inválida e corrupção de dados. Isso torna o código escrito em Rust mais seguro e estável.

Além disso, o Rust tem um coletor de lixo automático que ajuda a gerenciar a memória de maneira eficiente. Ele monitora a memória alocada pelo programa e libera automaticamente a memória que não está sendo mais usada, evitando vazamentos de memória e aumentando a performance do programa.


\subsection{Propriedade Exclusiva (Ownership)}
A propriedade em Rust refere-se às regras que governam como a linguagem gerencia a memória. Cada valor em Rust tem um proprietário, e só pode haver um proprietário por vez. Quando o proprietário sai do escopo, o valor é eliminado. Isso é crucial para garantir a segurança de memória e prevenir erros como dupla liberação.

Ao lidar com tipos que contêm dados no heap, como a String, a propriedade implica que, ao atribuir ou passar valores para funções, ocorre uma transferência de propriedade (move). Isso significa que o valor original não é mais válido após a transferência, evitando erros de dupla liberação.

Rust oferece a opção de clonar dados no heap usando o método clone, mas isso pode ser uma operação custosa em termos de desempenho.

Tipos armazenados na pilha, como inteiros, implementam a trait Copy se são de tamanho fixo, permitindo que sejam copiados trivialmente sem invalidar a variável original.

Além disso, é possível usar referências para permitir o uso de um valor sem transferir sua propriedade. Isso é útil quando desejamos emprestar temporariamente um valor sem assumir a propriedade.

 


\subsection{Empréstimo de variáveis (Borrowing)}

Você pode estar se perguntando se Rust tem variáveis imutáveis e como devemos manipulá-las com segurança. Na verdade, Rust oferece uma maneira elegante de manipular variáveis através do conceito de empréstimos. Com empréstimos, podemos compartilhar o acesso a uma variável sem transferir sua propriedade, permitindo que o código seja seguro e eficiente. O uso de mut deve ser feito com cuidado, pois só deve ser usado quando a variável precisa ser modificada. Em outras palavras, devemos preferir variáveis imutáveis sempre que possível e usar empréstimos quando precisarmos de acesso temporário e compartilhado a uma variável.

O empréstimo é uma forma de permitir que partes do código acessem uma variável sem possuir a propriedade completa dela. Em vez de copiar os dados da variável ou mover a propriedade inteira, o Rust permite que o código empreste a variável, permitindo que outras partes do código leiam e/ou modifiquem temporariamente seu conteúdo.

Em Rust, os empréstimos são controlados pelo compilador, que verifica se as regras de empréstimo são seguidas corretamente. Uma das principais regras é que uma variável só pode ter um empréstimo mutável ou vários empréstimos imutáveis simultâneos em um determinado ponto no tempo. Isso ajuda a evitar problemas comuns, como data races e memory leaks.

Os problemas de data races e memory leaks ocorrem em programas que gerenciam memória dinamicamente e que possuem múltiplas threads ou processos em execução.

Data races são situações em que duas ou mais threads ou processos acessam a mesma variável ao mesmo tempo, sem sincronização adequada. Isso pode levar a resultados imprevisíveis e inconsistências nos dados, causando comportamentos indesejados e até mesmo falhas no programa.

Já os memory leaks ocorrem quando um programa alocou memória dinamicamente, mas não a liberou quando ela não é mais necessária. Isso pode levar a uma queda de desempenho do sistema ou até mesmo a um travamento do programa, já que a memória não utilizada não é liberada para outros processos ou threads.


Por exemplo, suponha que temos uma função que precisa modificar uma variável que foi declarada em outro lugar:
%\lstinputlisting[language=rust, caption = exemplo empréstimo de variável  ]{codigos/captulo1/imut.rs}

Nesse exemplo, a função modify recebe um empréstimo mutável da variável my\_var por meio do parâmetro x. A função incrementa o valor de x em 1. Na função main, a variável my\_var é declarada e inicializada com o valor 42. A seguir, a função modify é chamada com um empréstimo mutável de my\_var usando \&mut my\_var. Finalmente, o valor de my\_var é impresso na tela.

Observe que a função modify recebe um empréstimo mutável da variável my\_var usando a sintaxe \&mut i32. Isso indica que a função pode ler e modificar o valor de my\_var, mas não pode criar outros empréstimos mutáveis simultâneos. Além disso, a sintaxe *x é usada para acessar o valor de x. Isso ocorre porque x é uma referência à variável my\_var, e a sintaxe * é usada para desreferenciar a referência e acessar o valor real.

\section{Exercicios}
\begin{enumerate}
    \item Faça um programa em rust que imprima o seu nome.
    \item Faça um programa em rust que imprima o produto dos valores 30 e 27.
\item Faça um programa em rust que imprima a média aritmética entre os números 3, 2,
7.
\item Faça um programa em rust que leia e imprima um número inteiro.
\item Faça um programa em rust que leia dois números reais e os imprima.
\item Faça um programa em rust que leia um número inteiro e imprima o seu antecessor
e o seu sucessor.
\item Faça um programa em rust que leia o nome o endereço e o telefone de um cliente e
ao final, imprima esses dados.
\item Faça um programa em rust que leia dois números inteiros e imprima a subtração
deles.
\item Faça um programa em rust que leia um número real e imprima ¼ deste número.
\item Faça um programa em rust que leia três números reais e calcule a média aritmética
destes números. Ao final, o programa deve imprimir o resultado do cálculo.
\item Faça um programa em rust que leia dois números reais e calcule as quatro operações
básicas entre estes dois números, adição, subtração, multiplicação e divisão. Ao
final, o programa deve imprimir os resultados dos cálculos.
\item Faça um programa em rust que leia um número real e calcule o quadrado deste
número. Ao final, o programa deve imprimir o resultado do cálculo.
\item Faça um programa em rust que leia o saldo de uma conta poupança e imprima o
novo saldo, considerando um reajuste de 2%.
\item Faça um programa em rust que leia a base e a altura de um retângulo e imprima o
perímetro (base + altura) e a área (base * altura).
\item Faça um programa em rust que leia o valor de um produto, o percentual do desconto desejado e imprima o valor do desconto e o valor do produto subtraindo o
desconto.
\item Faça um programa em rust que calcule o reajuste do salário de um funcionário. Para
isso, o programa deverá ler o salário atual do funcionário e ler o percentual de
reajuste. Ao final imprimir o valor do novo salário.
\item Faça um programa em rust que calcule a conversão entre graus centígrados e Fahrenheit. Para isso, leia o valor em centígrados e calcule com base na fórmula a
seguir. Após calcular o programa deve imprimir o resultado da conversão.
\begin{equation}
T_{\text{C}} = \frac{5}{9}(T_{\text{F}} - 32)
\end{equation}
Em que:
\begin{enumerate}
    \item F = Graus em Fahrenheit
    \item C = Graus centígrados
\end{enumerate}

\item Faça um programa em rust que calcule a quantidade de litros de combustível consumidos em uma viagem, sabendo-se que o carro tem autonomia de 12 km por
litro de combustível. O programa deverá ler o tempo decorrido na viagem e a
velocidade média e aplicar as fórmulas:
\begin{equation}
D = T \times V
\end{equation}
\begin{equation}
T_{\text{L}} = \frac{D}{12}
\end{equation}
Em que:
\begin{enumerate}
    \item D = Distância percorrida em horas
    \item T = Tempo decorrido
\item V = Velocidade média
\item L = Litros de combustível consumidos
\end{enumerate}

Ao final, o programa deverá imprimir a distância percorrida e a quantidade de
litros consumidos na viagem.
\item Faça um programa em rust que calcule o valor de uma prestação em atraso. Para
isso, o programa deve ler o valor da prestação vencida, a taxa periódica de juros
e o período de atraso. Ao final, o programa deve imprimir o valor da prestação
atrasada, o período de atraso, os juros que serão cobrados pelo período de atraso,
o valor da prestação acrescido dos juros. Considere juros simples.
\item Faça um programa em rust que efetue a apresentação do valor da conversão em
real (R\$) de um valor lido em dólar (US\$). Para isso, será necessário também ler o
valor da cotação do dólar.

\end{enumerate}
\subsection{Fixação e aprofundamento}
\begin{enumerate}
    \item Em Rust, é possível emprestar uma variável para uma função e garantir que ela será devolvida após a sua utilização. Faça um programa que leia três notas de um aluno e calcule a sua média, utilizando o empréstimo de variáveis.

    \item Em Rust, é possível fazer a troca de valores entre duas variáveis sem o uso de uma variável temporária. Faça um programa que leia dois números e troque os seus valores sem o uso de uma variável temporária.

    \item Em um jogo de RPG, o dano que um personagem causa em outro é calculado levando em conta a força do atacante e a defesa do defensor. Faça um programa que leia a força e a defesa dos personagens e calcule o dano causado pelo ataque.
\end{enumerate}
\subsection{Desafio}
\begin{enumerate}
    \item Em Rust, é possível emprestar uma variável para uma função e garantir que ela será devolvida após a sua utilização. Faça um programa que leia três notas de um aluno e calcule a sua média, utilizando o empréstimo de variáveis.

\end{enumerate}

\chapter{Estruturas de Decisão em Rust}

\begin{comment}

Quais são os operadores de concatenação em rust? Explique, apresente exemplos e saída 
:


Olá, mundo!
Espero que isso ajude a entender como os operadores de concatenação funcionam em Rust. Qualquer dúvida, só perguntar!





Note nafigura6comoasaídadoprogramafoiimpressa.Vejaqueotextoimpresso pela primeira função printf() está concatenado com o texto impresso pela segunda função. Isso ocorreu porque não foi informado para a primeira função a intenção de adicionar espaço, tabulação ou quebra de linha. Como é possível resolver isso então? AlinguagemCtemumaformabemelegantederesolverisso,elatrataocaractere"\" como sendo especial para uso combinado com outros caracteres que irão permitir operações especiais no texto. Para resolver o problema do exemplo anterior, basta adicionar uma quebra delinha. Veja a seguir: 1 int mat =335642; 2 float medF = 7; 3 printf("Matricula: %d\n", mat); 4 printf("Media Final: %2.2f", medF);como fica em rust 
Em Rust, para concatenar strings, pode-se usar o operador +. Por exemplo:


let matricula = "335642";
let media_final = "7";
println!("Matrícula: {}\nMédia final: {}", matricula, media_final);
Isso irá imprimir:


Matrícula: 335642
Média final: 7
Também é possível usar o método format da string para formatar a string de saída, assim como ocorre na linguagem C. Por exemplo:


let matricula = 335642;
let media_final = 7.0;
println!("Matrícula: {}, Média final: {:.2}", matricula, media_final);
Isso irá imprimir:


Matrícula: 335642, Média final: 7.00




Em C a a Função scanf() Comovisto afunçãoprintf() é responsável pela saída das informações do programa. Comofazerentãoparaentrar comdadosnafronteira do programa? Neste caso, deve-se utilizar a função scanf(). Similar à função printf(), a função scanf() também suporta umaquantidade"n"deargumentosepermitequeosdadosdigitadospelousuário. Como é em Rust? Explique 
Em Rust, o equivalente à função scanf() em C é a função std::io::stdin().read_line(). Esta função lê uma linha do stdin (padrão de entrada) e retorna um Result contendo uma String com o conteúdo lido. Você pode então utilizar a função .unwrap() para obter a String e atribuí-la a uma variável.

Aqui está um exemplo de como ler uma linha do stdin e atribuir o resultado a uma variável string em Rust:


use std::io;

fn main() {
    println!("Digite seu nome: ");

    let mut nome = String::new();

    io::stdin().read_line(&mut nome).unwrap();

    println!("Olá, {}!", nome);
}
Ao executar este programa, o usuário será solicitado a digitar seu nome e o nome digitado será armazenado na variável nome. Em seguida, o programa imprime "Olá, (nome do usuário)!" na tela.

É importante notar que, ao contrário da função scanf(), a função std::io::stdin().read_line() lê uma linha inteira, incluindo espaços em branco e quebra de linha. Se você deseja ler apenas um único token (palavra ou número), pode utilizar a função std::io::stdin().read_token() em vez disso.






Como ler um número inteiro do teclado em Rust 
Para ler um número inteiro do teclado em Rust, você pode usar a função std::io::stdin().read_line() e depois parsear o resultado para o tipo inteiro. Aqui está um exemplo de como fazer isso:


use std::io;

fn main() {
    println!("Digite um número inteiro:");

    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();

    let num: i32 = input.trim().parse().unwrap();
    println!("Você digitou o número: {}", num);
}
Neste exemplo, primeiro imprimimos uma mensagem pedindo para o usuário digitar um número inteiro. Em seguida, criamos uma variável input do tipo String e usamos a função stdin().read_line() para ler uma linha de entrada do teclado e armazená-la em input. Depois, usamos o método trim() para remover espaços em branco no início e no final da string e o método parse() para tentar parsear o conteúdo da string para o tipo i32. Por fim, imprimimos o número digitado pelo usuário.

É importante notar que a função read_line() retorna um resultado do tipo Result<usize>, então precisamos usar o método unwrap() para lidar com esse resultado. O mesmo vale para o método parse(), que retorna um resultado do tipo Result<i32>.






Como ler um número real do teclado em Rust
Para ler um número real do teclado em Rust, basta utilizar a função read_line() da biblioteca padrão std::io e, em seguida, usar a função parse() do tipo f32 (para ler um número de ponto flutuante de 32 bits) ou f64 (para ler um número de ponto flutuante de 64 bits) para converter o valor lido em uma variável do tipo float.

Veja um exemplo de como ler um número real do teclado e armazená-lo em uma variável do tipo f32:


use std::io;

fn main() {
    println!("Digite um número real:");

    let mut input = String::new();
    io::stdin().read_line(&mut input).expect("Falha ao ler o input");

    let num: f32 = input.trim().parse().expect("Falha ao converter para f32");

    println!("Você digitou o número: {}", num);
}
Neste exemplo, a função read_line() lê a entrada do usuário e armazena em uma string chamada input. Em seguida, a função parse() é usada para converter a string em um número do tipo f32, que é armazenado na variável num. Por fim, o valor da variável num é impresso na tela.

Se você deseja ler um número de ponto flutuante de 64 bits, basta substituir o tipo f32 por f64 na declaração da variável num e na chamada da função parse().


let num: f64 = input.trim().parse().expect("Falha ao converter para f64");




Apresente a saída no cinsole
Para ler um número real do teclado em Rust, você pode usar o método read_line da struct stdin seguido do método parse do trait FromStr:


use std::io;

fn main() {
    println!("Digite um número real:");

    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();

    let number: f64 = input.trim().parse().unwrap();

    println!("O número lido foi: {}", number);
}
Se você executar esse código e digitar, por exemplo, "3.14", a saída será "O número lido foi: 3.14".





Me dê o Códigos debarra invertida em rust

3 / 3

Em Rust, para usar barras invertidas para realizar operações especiais no texto, basta escrevê-las normalmente. Por exemplo, para adicionar uma quebra de linha, basta escrever \n.

Aqui estão alguns exemplos de uso de barras invertidas em Rust:


fn main() {
    println!("Olá,\nMundo!"); // imprime "Olá," e depois uma quebra de linha e "Mundo!"
    println!("1\\2"); // imprime "1\2"
    println!("\"Oi!\" disse ele."); // imprime "\"Oi!\" disse ele."
}
A saída seria:


Olá,
Mundo!
1\2
"Oi!" disse ele.




Me dê uma tabela com todos os Códigos debarra invertida
A seguir, apresento uma tabela com os códigos de barra invertida () mais comuns usados em Rust:

Código	Significado
\	Barra invertida ()
\n	Nova linha
\r	Retorno de carro
\t	Tabulador
\0	Caractere nulo
\xhh	Caractere ASCII com código hexadecimal hh
\uhhhh	Caractere Unicode com código hexadecimal hhhh
Para usar esses códigos, basta inserir a barra invertida seguida pelo código desejado na string. Por exemplo:


let s = "Oi, eu sou um texto com uma nova linha: \nEu sou a nova linha.";
println!("{}", s);
A saída desse código seria:


Oi, eu sou um texto com uma nova linha:
Eu sou a nova linha.




float nota1, nota2; 2 scanf("%f %f", &nota1, &nota2); A primeira linha do exemplo é a declaração de duas variáveis do tipo float e a segunda linha é oacionamentodafunçãoscanf(), neste caso, para a leitura e armazenamentoemduasvariáveis, nota1enota2.Noteque,noformatofoiescritoo"%f"duas vezes e separado por umespaço,assim,oscanf() saberá tratar a formatação dos dois próximos argumentos. E da mesmaformapode-secombinarousonãosódevariáveis diferentes, mas também de tipos diferentes. Agora que foi explicado em como declarar variáveis, fazer operações de atribuição e aritméticas, e utilizar funções de entrada e saída, é possível fazer o primeiro exercício. Como fica em rust 
Em Rust, o código para ler duas variáveis do tipo float do teclado e armazená-las nas variáveis nota1 e nota2 seria:


let mut nota1: f32 = 0.0;
let mut nota2: f32 = 0.0;

println!("Digite a primeira nota:");
io::stdin().read_line(&mut nota1).expect("Falha ao ler a entrada");

println!("Digite a segunda nota:");
io::stdin().read_line(&mut nota2).expect("Falha ao ler a entrada");

Ou, para uma versão mais curta:


let mut nota1: f32 = 0.0;
let mut nota2: f32 = 0.0;

println!("Digite a primeira nota:");
scan!("{}", &mut nota1);

println!("Digite a segunda nota:");
scan!("{}", &mut nota2);




Me dê os resultados no console 
Para ler duas variáveis do tipo float do teclado e armazená-las nas variáveis nota1 e nota2, você pode usar o seguinte código em Rust:


use std::io;

fn main() {
    let mut nota1 = String::new();
    let mut nota2 = String::new();

    println!("Digite a primeira nota:");
    io::stdin().read_line(&mut nota1).expect("Falha ao ler a entrada");
    let nota1: f32 = nota1.trim().parse().expect("Por favor, digite um número válido");

    println!("Digite a segunda nota:");
    io::stdin().read_line(&mut nota2).expect("Falha ao ler a entrada");
    let nota2: f32 = nota2.trim().parse().expect("Por favor, digite um número válido");

    println!("Notas lidas: {} e {}", nota1, nota2);
}
Se você digitar, por exemplo, as notas 7.5 e 8.9, a saída no console será:


Digite a primeira nota:
Digite a segunda nota:
Notas lidas: 7.5 e 8.9




Veja o 1ExercíciodeExemplo em cFaçaumprogramaemCquerecebadoisnúmerosinteiroseaofinalimprimaasoma deles. 1#include<stdio.h> 2#include<stdlib.h> 3voidmain(){ 4intsoma,num1,num2; 5printf("Informeoprimeironumero:"); 6scanf("%d",&num1); 7printf("Informeosegundonumero:"); 8scanf("%d",&num2); 9 10soma=num1+num2; 11 12printf("Resultadodasoma:%d",soma); 13} faça o mesmo em rust 
Para fazer o mesmo programa em Rust, você pode usar o seguinte código:


use std::io;

fn main() {
    println!("Informe o primeiro número:");

    let mut num1 = String::new();
    io::stdin().read_line(&mut num1).expect("Falha ao ler a entrada");
    let num1: i32 = num1.trim().parse().expect("Por favor, digite um número inteiro");

    println!("Informe o segundo número:");

    let mut num2 = String::new();
    io::stdin().read_line(&mut num2).expect("Falha ao ler a entrada");
    let num2: i32 = num2.trim().parse().expect("Por favor, digite um número inteiro");

    let soma = num1 + num2;

    println!("Resultado da soma: {}", soma);
}
O código acima lê dois números inteiros do teclado, armazena-os em variáveis num1 e num2, respectivamente, e imprime a soma desses números no console.

Para ler os números inteiros do teclado, o código usa a função read_line da biblioteca padrão std::io. A função read_line lê uma linha inteira de entrada como uma string e a armazena na variável passada como parâmetro. Depois, o código converte a string lida para um valor inteiro usando o método parse e armazena o resultado na variável adequada.

Para imprimir o resultado da soma, o código usa a macro println!, que é semelhante à função printf em C. A macro





Continue
Para fazer o mesmo exercício em Rust, basta seguir os passos abaixo:

Inclua as bibliotecas necessárias:

use std::io;
Declare as variáveis que serão usadas:

let mut soma: i32 = 0;
let mut num1: i32 = 0;
let mut num2: i32 = 0;
Faça a leitura dos números inteiros:

println!("Informe o primeiro número:");
io::stdin().read_line(&mut num1).expect("Falha ao ler a entrada");
num1 = num1.trim().parse().expect("Por favor, digite um número inteiro");

println!("Informe o segundo número:");
io::stdin().read_line(&mut num2).expect("Falha ao ler a entrada");
num2 = num2.trim().parse().expect("Por favor, digite um número inteiro");
Realize a operação de soma:

soma = num1 + num2;
Imprima o resultado da soma:

println!("Resultado da soma: {}", soma);
O código completo ficaria assim:


use std::io;

fn main() {
    let mut soma: i32 = 0;
    let mut num1: i32 = 0;
    let mut num2: i32 = 0;

    println!("Informe o primeiro número:");
    io::stdin().read_line(&mut num1).expect("Falha ao ler a entrada");
    num1 = num1.trim().parse().expect("Por favor, digite um número




Mostre um exemplo de execução e o resultado 
Para mostrar um exemplo de execução do programa em Rust, primeiro é preciso escrever o código em Rust. O código em Rust seria algo assim:


use std::io;

fn main() {
    println!("Informe o primeiro número:");

    let mut num1 = String::new();

    io::stdin().read_line(&mut num1).expect("Falha ao ler a entrada");

    let num1: i32 = num1.trim().parse().expect("Por favor, digite um número inteiro válido");

    println!("Informe o segundo número:");

    let mut num2 = String::new();

    io::stdin().read_line(&mut num2).expect("Falha ao ler a entrada");

    let num2: i32 = num2.trim().parse().expect("Por favor, digite um número inteiro válido");

    let soma = num1 + num2;

    println!("Resultado da soma: {}", soma);
}
Para executar esse programa, basta salvá-lo em um arquivo com a extensão .rs e compilá-lo com o seguinte comando:


cargo run
Isso irá compilar e executar o programa. Se tudo estiver correto, o programa irá pedir a entrada de dois números inteiros e, em seguida, imprimir a soma desses números. Por exemplo, ao digitar os números 5 e 7, o programa irá imprimir Resultado da soma: 12.





O que é mut em rust 

2 / 2

Em Rust, "mut" é uma palavra-chave que indica que uma variável é mutável, ou seja, pode ser alterada durante a execução do programa. Por padrão, as variáveis em Rust são imutáveis, ou seja, uma vez que uma variável é atribuída um valor, ela não pode mais ser alterada. Isso é uma característica importante do Rust que ajuda a garantir a segurança e a estabilidade do código.

Para declarar uma variável mutável em Rust, basta adicionar a palavra-chave "mut" antes do nome da variável. Por exemplo:


let mut x = 5;
Neste exemplo, a variável "x" é declarada como mutável e inicializada com o valor 5. Depois, ela pode ser alterada durante a execução do programa, assim:


x = 10;
É importante lembrar que, para alterar o valor de uma variável mutável, é preciso ter acesso a ela. Isso pode ser controlado através de empréstimos e referências, que são tópicos avançados da linguagem Rust.





Em temos o seguinte exercício 3Lendotextocomafunçãoscanf() Afunçãoscanf()funcionamuitobemparaostiposint,float,double,entreoutros,contudo,quandosetratadoarmazenamentodeumtexto,casoemque,deve-seutilizaro charcomdefiniçãodetamanho,estafunçãoapresentaumcomportamentoindesejável emumasituaçãoespecífica.Vejaaseguirumexemplo: 1#include<stdio.h> 2#include<stdlib.h> 3 4voidmain() 5{ 6charproduto[30]; 7printf("Informeonomedoproduto:\n"); 8scanf("%s",&produto); 9 10printf("Produto:%s\n",produto); 11}.  Faça em rust
Para fazer o mesmo programa em Rust, basta utilizar a função stdin() da biblioteca std::io para ler a entrada do usuário e armazená-la em uma string. O código ficaria assim:


use std::io;

fn main() {
    println!("Informe o nome do produto:");

    let mut produto = String::new();
    io::stdin().read_line(&mut produto).unwrap();

    println!("Produto: {}", produto);
}
Note que a variável produto foi declarada como mut, pois a função read_line precisa mutabilidade para poder escrever na string. Além disso, a função read_line retorna um resultado do tipo Result, então é preciso chamar o método unwrap para tratar o resultado e garantir que a leitura ocorreu corretamente.


2 / 2





Mostre um exemplo de execução e o resultado
Em Rust, para ler um texto com a função stdin, podemos usar o seguinte código:


use std::io;

fn main() {
    let mut produto = String::new();

    println!("Informe o nome do produto:");
    io::stdin().read_line(&mut produto).expect("Falha ao ler a linha");

    println!("Produto: {}", produto);
}
Ao executar esse código, o usuário será solicitado a digitar o nome do produto e, ao pressionar Enter, o texto digitado será armazenado na variável produto e impresso na tela.

Por exemplo, se o usuário digitar "Arroz" e pressionar Enter, a saída será:


Informe o nome do produto:
Produto: Arroz




Existe a Função fgets em rust? 

2 / 2

Sim, existe a função fgets em Rust. Ela é utilizada para ler uma linha de texto de um arquivo ou de uma entrada padrão (como o teclado). A função fgets recebe três parâmetros: um ponteiro para uma string (char *), o tamanho máximo da string e um ponteiro para um arquivo. Ela lê até o tamanho máximo de caracteres especificado ou até encontrar um caractere de nova linha ('\n'), o que ocorrer primeiro. Aqui está um exemplo de como usar a função fgets em Rust:


use std::io;

fn main() {
    // Declara uma string com o tamanho máximo de 50 caracteres
    let mut input = String::new();

    // Lê uma linha do teclado e armazena na string 'input'
    io::stdin().read_line(&mut input).unwrap();

    // Imprime a string lida
    println!("Você digitou: {}", input);
}
Neste exemplo, a função read_line do módulo io é utilizada para ler uma linha do teclado e armazená-la na string mutável 'input'. A função read_line é um método do tipo Reader, que é implementado para vários tipos de entrada, incluindo o teclado (stdin). A função fgets pode ser utilizada de maneira semelhante, mas é mais comum usar o método read_line em Rust devido à sua sintaxe mais limpa e intuitiva.





Quais alternativas para leitura de dados do teclado em Rust além de io::stdin().read_line
Além de usar a função io::stdin().read_line(), algumas alternativas para ler dados do teclado em Rust incluem:

Utilizar a função io::stdin().read_to_string(), que lê uma linha de texto do teclado e armazena em uma String.

Usar a função io::stdin().read_to_end(), que lê todo o conteúdo do teclado até o final e armazena em um vetor de bytes.

Utilizar a função io::stdin().read_exact(), que lê um número específico de bytes do teclado e armazena em um vetor de bytes.

Utilizar a função io::stdin().bytes(), que retorna um iterator de bytes a partir do teclado, permitindo que os dados sejam lidos e processados aos poucos.

Utilizar a biblioteca buf_redux, que permite a leitura de dados do teclado de maneira mais eficiente em aplicações que precisam ler grandes quantidades de dados.





Me dê detalhes 
Além de utilizar a função io::stdin().read_line() para ler linhas de entrada do teclado em Rust, existem outras formas de se fazer isso:

Utilizar a função read_string() da biblioteca std::io. Essa função lê uma linha de entrada e retorna uma String.

Utilizar a macro input!() do pacote std::io::prelude. Essa macro lê uma linha de entrada e atribui o valor lido a uma variável. Por exemplo:


input! {
    name: String,
    age: u8,
}

println!("Name: {}, Age: {}", name, age);
Utilizar a função read_line() do módulo std::io::BufRead. Essa função lê uma linha de entrada e retorna um Result<String, Error>. É preciso fazer o tratamento de erro manualmente.

Utilizar a função get_word() da biblioteca scanner. Essa função lê uma palavra (sequência de caracteres separada por espaços) de uma linha de entrada e retorna uma String. É preciso fazer o tratamento de erro manualmente.

Utilizar a macro scan!() do pacote scanner. Essa macro lê uma linha de entrada e atribui os valores lidos a variáveis. Por exemplo:


scan! {
    let x = i32,
    let y = String,
    let z = f64,
}

println!("x: {}, y: {}, z: {}", x, y, z);
Essas são algumas alternativas para ler





O que são comentários em uma linguagem de programação? 
Em uma linguagem de programação, os comentários são trechos de código que são ignorados pelo compilador ou interpretador. Eles são usados para incluir notas ou explicações em um código fonte, com o objetivo de torná-lo mais legível e compreensível para os desenvolvedores que o lêem.

Existem dois tipos de comentários comuns em linguagens de programação: comentários de uma linha e comentários de múltiplas linhas.

Os comentários de uma linha são denotados por um caractere especial, geralmente um símbolo de porcentagem ou barra, seguido de um caractere de admoestação, e só são válidos até o final da linha atual.

Os comentários de múltiplas linhas são denotados por uma sequência de caracteres especiais, geralmente /* para iniciar o comentário e */ para finalizá-lo, e podem abranger várias linhas de código.

Os comentários são úteis para incluir informações sobre o código, como descrições de funções, blocos de código ou variáveis, ou para explicar o funcionamento de uma parte específica do código. Eles também podem ser usados para desativar temporariamente partes de um código durante o desenvolvimento ou depuração.





Quais são as vantagens de se usar comentários? 
Existem várias vantagens em se utilizar comentários em uma linguagem de programação:

Ajudam a deixar o código mais legível e compreensível: os comentários permitem que você explique o que está acontecendo em cada parte do código, o que pode ser muito útil para outras pessoas que estejam lendo o código.

Ajudam a documentar o código: os comentários podem ser usados para documentar o que o código faz, o que pode ser útil para outras pessoas que estejam trabalhando no mesmo projeto ou para futuras referências.

Podem ser usados para desabilitar trechos de código temporariamente: os comentários podem ser usados para desabilitar trechos de código que você não quer que sejam executados no momento, o que pode ser útil para depurar o código ou para testar diferentes soluções.

Podem ajudar a evitar erros: os comentários podem ser usados para explicar a lógica por trás de determinado trecho de código, o que pode ajudar a evitar erros e a tornar o código mais robusto.





Quais são as desvantagens 
As principais desvantagens de se usar comentários em uma linguagem de programação são:

Comentários podem ficar desatualizados: à medida que o código é alterado, os comentários podem ficar desatualizados e, portanto, podem fornecer informações incorretas ou confusas.

Comentários podem aumentar o tamanho do código: a adição de comentários ao código pode torná-lo mais longo e, portanto, mais difícil de ler e entender.

Comentários podem ser redundantes: em alguns casos, os comentários podem ser redundantes com o código, o que pode levar a confusão e dificuldade na leitura.

Comentários podem ser usados incorretamente: os comentários podem ser usados incorretamente, como para esconder código ou informações importantes. Isso pode levar a problemas de segurança ou mesmo comprometer o funcionamento do programa.





Quais são os Tipos de comentários em rust
Em Rust, existem dois tipos de comentários:

Comentários de linha única: são aqueles que ocupam apenas uma linha do código e são indicados pelo símbolo "//". Por exemplo:

// Este é um comentário de linha única
Comentários de múltiplas linhas: são aqueles que ocupam mais de uma linha e são indicados pelos símbolos "/" no início e "/" no fim. Por exemplo:

/*
 Este é um comentário de múltiplas linhas
 Ele pode ser usado para explicar trechos de código mais complexos ou para deixar observações sobre o código
*/




Me dê um resumo do que foi conversado com você até agora
Até agora, conversamos sobre os seguintes tópicos em Rust:

Declaração de variáveis
Atribuição de valores a variáveis
Operações aritméticas básicas
Operadores unários
Regras de precedência em operações matemáticas
Operadores de atribuição
Entrada e saída de dados
Formatadores de tipo
Concatenação de strings
Funções de entrada (scanf) e saída (printf)
Códigos de barra invertida
Leitura de dados do teclado em Rust
Comentários em uma linguagem de programação.
Além disso, demos exemplos de código em Rust para ilustrar o uso desses tópicos e mostramos como eles podem ser aplicados em exercícios simples de programação.





Os seguintes exercícios foram especificados para a linguagem C. Especifique cada um deles em rust Osexercícios desta lista foram Adaptados de Lopes e Garcia (2002, p. 38-52). 1. FaçaumprogramaemCqueimprimaoseunome. 2. FaçaumprogramaemCqueimprimaoprodutodosvalores30e27. 3. FaçaumprogramaemCqueimprimaamédiaaritméticaentreosnúmeros5,8, 12. 4. FaçaumprogramaemCqueleiaeimprimaumnúmerointeiro. 5. FaçaumprogramaemCqueleiadoisnúmerosreaiseosimprima. 6. FaçaumprogramaemCqueleiaumnúmerointeiroeimprimaoseuantecessor e oseusucessor. 7. FaçaumprogramaemCqueleiaonomeoendereçoeotelefonedeumclientee ao final, imprima esses dados. 8. FaçaumprogramaemCqueleiadoisnúmerosinteiroseimprimaasubtração deles. 9. FaçaumprogramaemCqueleiaumnúmerorealeimprima¼destenúmero. 10. Faça umprogramaemCqueleiatrêsnúmerosreaisecalculeamédiaaritmética destes números. Ao final, o programa deveimprimir oresultado do cálculo. 11. FaçaumprogramaemCqueleiadoisnúmerosreaisecalculeasquatrooperações básicas entre estes dois números, adição, subtração, multiplicação e divisão. Ao f inal, o programa deve imprimir os resultados dos cálculos. 12. Faça um programa em rust que leia um número real e calcule o quadrado deste número. Aofinal, oprogramadeveimprimiroresultado docálculo. 13. Faça umprogramaemCqueleiaosaldodeumacontapoupançaeimprimao novo saldo, considerando um reajuste de 2%. 14. Faça umprogramaemCqueleiaabaseeaalturadeumretânguloeimprimao perímetro (base + altura) e a área (base * altura). 15. Faça um programa em rust que leia o valor de um produto, o percentual do desconto desejado e imprima ovalor dodesconto eovalor doprodutosubtraindo o desconto. 16. FaçaumprogramaemCquecalculeoreajustedosaláriodeumfuncionário.Para isso, o programa deverá ler o salário atual do funcionário e ler o percentual de reajuste. Ao final imprimir o valor do novo salário. 17. FaçaumprogramaemCquecalculeaconversãoen
Faça um programa em Rust que imprima seu nome.
Faça um programa em Rust que imprima o produto dos valores 30 e 27.
Faça um programa em Rust que imprima a média aritmética entre os números 5, 8, 12.
Faça um programa em Rust que leia e imprima um número inteiro.
Faça um programa em Rust que leia dois números reais e os imprima.
Faça um programa em Rust que leia um número inteiro e imprima o seu antecessor e o seu sucessor.
Faça um programa em Rust que leia o nome, o endereço e o telefone de um cliente e, ao final, imprima esses dados.
Faça um programa em Rust que leia dois números inteiros e imprima a subtração deles.
Faça um programa em Rust que leia um número real e imprima ¼ deste número.
Faça um programa em Rust que leia três números reais e calcule a média aritmética destes números. Ao final, o programa deve imprimir o resultado do cálculo.
Faça um programa em Rust que leia dois números reais e calcule as quatro operações básicas entre estes dois números, adição, subtração, multiplicação e divisão. Ao final, o programa deve imprimir os resultados dos cálculos.
Faça um programa em Rust que leia um número real e calcule o quadrado deste número. Ao final, o programa deve imprimir o resultado do cálculo.
Faça um programa em Rust que leia o saldo de uma conta poupança e imprima o




Continue
Faça um programa em Rust que imprima seu nome.

fn main() {
    println!("Meu nome é John Doe");
}
Faça um programa em Rust que imprima o produto dos valores 30 e 27.

fn main() {
    let produto = 30 * 27;
    println!("O produto é {}", produto);
}
Faça um programa em Rust que imprima a média aritmética entre os números 5, 8, 12.

fn main() {
    let media = (5 + 8 + 12) / 3;
    println!("A média é {}", media);
}
Faça um programa em Rust que leia e imprima um número inteiro.

use std::io;

fn main() {
    println!("Informe um número inteiro:");
    let mut num = String::new();
    io::stdin().read_line(&mut num).expect("Falha ao ler entrada");
    let num: i32 = num.trim().parse().expect("Por favor, informe um número inteiro válido");
    println!("O número informado é: {}", num);
}
Faça um programa em Rust que leia dois números reais e os imprima.

use std::io;

fn main() {
    println!("Informe dois números reais:");
    let mut nums = String::new();
    io::stdin().read_line(&mut nums).expect("Falha ao ler entrada");
    let mut nums: Vec<f64> = nums.split_whitespace()
        .map(|s| s.parse().expect("Por favor, informe números reais válidos"))
        .




Os seguintes exercícios foram especificados em C, especifique os em rust FaçaumprogramaemCqueleiadoisnúmerosreaiseosimprima. 6. FaçaumprogramaemCqueleiaumnúmerointeiroeimprimaoseuantecessor e oseusucessor. 7. FaçaumprogramaemCqueleiaonomeoendereçoeotelefonedeumclientee ao final, imprima esses dados. 8. FaçaumprogramaemCqueleiadoisnúmerosinteiroseimprimaasubtração deles. 9. FaçaumprogramaemCqueleiaumnúmerorealeimprima¼destenúmero. 10. Faça umprogramaemCqueleiatrêsnúmerosreaisecalculeamédiaaritmética destes números. Ao final, o programa deveimprimir oresultado do cálculo. 11. FaçaumprogramaemCqueleiadoisnúmerosreaisecalculeasquatrooperações básicas entre estes dois números, adição, subtração, multiplicação e divisão. Ao f inal, o programa deve imprimir os resultados dos cálculos.
Faça um programa em Rust que leia dois números reais e os imprima.

fn main() {
    let mut num1: f32 = 0.0;
    let mut num2: f32 = 0.0;

    println!("Informe o primeiro número:");
    io::stdin().read_line(&mut num1).unwrap();
    num1 = num1.trim().parse().unwrap();

    println!("Informe o segundo número:");
    io::stdin().read_line(&mut num2).unwrap();
    num2 = num2.trim().parse().unwrap();

    println!("Primeiro número: {}", num1);
    println!("Segundo número: {}", num2);
}
Faça um programa em Rust que leia um número inteiro e imprima o seu antecessor e o seu sucessor.

fn main() {
    let mut num: i32 = 0;

    println!("Informe um número inteiro:");
    io::stdin().read_line(&mut num).unwrap();
    num = num.trim().parse().unwrap();

    println!("Antecessor: {}", num - 1);
    println!("Sucessor: {}", num + 1);
}
Faça um programa em Rust que leia o nome, o endereço e o telefone de um cliente e ao final, imprima esses dados.

fn main() {
    let mut nome = String::new();
    let mut endereco = String::new();
    let mut telefone = String::new();

    println!("Informe o nome:");
    io::stdin().read_line(&mut nome).unwrap();
    nome = nome.trim().to_string();

    println!("Informe o endereço:");
    io::stdin().read_line(&mut endereco).unwrap();
    endereco = endereco.trim().to_string();

    println!("Informe o telefone:");
    io::stdin().read_line(&mut telefone).unwrap();
    telefone = telefone.trim().to_string();

    println!("Nome: {}", nome);
    println!("Endereço: {}", endereco);
    println!("Tele




Os seguintes exercícios foram especificados em C, especifique em rust FaçaumprogramaemCqueleiaonomeoendereçoeotelefonedeumclientee ao final, imprima esses dados. 8. FaçaumprogramaemCqueleiadoisnúmerosinteiroseimprimaasubtração deles. 9. FaçaumprogramaemCqueleiaumnúmerorealeimprima¼destenúmero. 10. Faça umprogramaemCqueleiatrêsnúmerosreaisecalculeamédiaaritmética destes números. Ao final, o programa deveimprimir oresultado do cálculo. 11. FaçaumprogramaemCqueleiadoisnúmerosreaisecalculeasquatrooperações básicas entre estes dois números, adição, subtração, multiplicação e divisão. Ao f inal, o programa deve imprimir os resultados dos cálculos. 12. Faça um programa em rust que leia um número real e calcule o quadrado deste número. Aofinal, oprogramadeveimprimiroresultado docálculo. 13. Faça umprogramaemCqueleiaosaldodeumacontapoupançaeimprimao novo saldo, considerando um reajuste de 2%.
Faça um programa em Rust que leia e imprima dois números reais:

use std::io;

fn main() {
    println!("Informe o primeiro número:");
    let mut num1 = String::new();
    io::stdin().read_line(&mut num1).expect("Falha ao ler entrada");
    let num1: f32 = num1.trim().parse().expect("Por favor, digite um número real válido");

    println!("Informe o segundo número:");
    let mut num2 = String::new();
    io::stdin().read_line(&mut num2).expect("Falha ao ler entrada");
    let num2: f32 = num2.trim().parse().expect("Por favor, digite um número real válido");

    println!("Números: {} e {}", num1, num2);
}
Faça um programa em Rust que leia um número inteiro e imprima seu antecessor e seu sucessor:

use std::io;

fn main() {
    println!("Informe um número inteiro:");
    let mut num = String::new();
    io::stdin().read_line(&mut num).expect("Falha ao ler entrada");
    let num: i32 = num.trim().parse().expect("Por favor, digite um número inteiro válido");

    println!("Antecessor: {}", num - 1);
    println!("Sucessor: {}", num + 1);
}
Faça um programa em Rust que leia o nome, o endereço e o telefone de um cliente e imprima esses dados:

use std::io;

fn main() {
    println!("Informe o nome:");
    let mut nome = String::new();
    io::std




Os seguintes exercícios foram especificados em C, especifique em rust FaçaumprogramaemCqueleiaonomeoendereçoeotelefonedeumclientee ao final, imprima esses dados. 
Faça um programa em Rust que leia o nome, endereço e telefone de um cliente e ao final, imprima esses dados.

use std::io;

fn main() {
    let mut nome = String::new();
    let mut endereco = String::new();
    let mut telefone = String::new();

    println!("Informe o nome do cliente:");
    io::stdin().read_line(&mut nome).expect("Erro ao ler o nome do cliente");
    println!("Informe o endereço do cliente:");
    io::stdin().read_line(&mut endereco).expect("Erro ao ler o endereço do cliente");
    println!("Informe o telefone do cliente:");
    io::stdin().read_line(&mut telefone).expect("Erro ao ler o telefone do cliente");

    println!("Nome: {}Endereço: {}Telefone: {}", nome, endereco, telefone);
}

2 / 2





É possível resolver com char? 
Sim, é possível ler os dados de nome, endereço e telefone de um cliente usando variáveis do tipo char. A seguir, apresento uma possível implementação em Rust desse exercício:


use std::io;

fn main() {
    let mut nome = String::new();
    let mut endereco = String::new();
    let mut telefone = String::new();

    println!("Informe o nome do cliente:");
    io::stdin().read_line(&mut nome).unwrap();
    nome = nome.trim().to_string();

    println!("Informe o endereço do cliente:");
    io::stdin().read_line(&mut endereco).unwrap();
    endereco = endereco.trim().to_string();

    println!("Informe o telefone do cliente:");
    io::stdin().read_line(&mut telefone).unwrap();
    telefone = telefone.trim().to_string();

    println!("Dados do cliente:");
    println!("Nome: {}", nome);
    println!("Endereço: {}", endereco);
    println!("Telefone: {}", telefone);
}
Nesse exemplo, as variáveis nome, endereco e telefone são do tipo String. Utilizei a função read_line da biblioteca std::io para ler os dados do teclado, e em seguida, removi os espaços em branco no início e no fim das strings com a função trim. Por fim





Os seguintes exercícios foram especificados em C, especifique em rust FaçaumprogramaemCqueleiadoisnúmerosinteiroseimprimaasubtração deles. 9. FaçaumprogramaemCqueleiaumnúmerorealeimprima¼destenúmero
Faça um programa em Rust que leia dois números inteiros e imprima a subtração deles.

use std::io;

fn main() {
    println!("Insira o primeiro número inteiro:");

    let mut num1 = String::new();
    io::stdin().read_line(&mut num1).expect("Falha ao ler a entrada");
    let num1: i32 = num1.trim().parse().expect("Por favor, insira um número inteiro válido");

    println!("Insira o segundo número inteiro:");

    let mut num2 = String::new();
    io::stdin().read_line(&mut num2).expect("Falha ao ler a entrada");
    let num2: i32 = num2.trim().parse().expect("Por favor, insira um número inteiro válido");

    let resultado = num1 - num2;
    println!("Resultado da subtração: {}", resultado);
}
Faça um programa em Rust que leia um número real e imprima ¼ deste número.

use std::io;

fn main() {
    println!("Insira um número real:");

    let mut num = String::new();
    io::stdin().read_line(&mut num).expect("Falha ao ler a entrada");
    let num: f64 = num.trim().parse().expect("Por favor, insira um número real válido");

    let resultado = num / 4.0;
    println!("¼ do número inserido: {}", resultado);
}

2 / 2





Faça o mesmo para Faça umprogramaemCqueleiatrêsnúmerosreaisecalculeamédiaaritmética destes números. Ao final, o programa deveimprimir oresultado do cálculo. 11. FaçaumprogramaemCqueleiadoisnúmerosreaisecalculeasquatrooperações básicas entre estes dois números, adição, subtração, multiplicação e divisão. Ao f inal, o programa deve imprimir os resultados dos cálculos.
Faça um programa em Rust que leia dois números inteiros e imprima a subtração deles.

fn main() {
    let mut num1: i32 = 0;
    let mut num2: i32 = 0;

    println!("Informe o primeiro número:");
    std::io::stdin().read_line(&mut num1).expect("Erro ao ler entrada");
    num1 = num1.trim().parse().expect("Erro ao converter para inteiro");

    println!("Informe o segundo número:");
    std::io::stdin().read_line(&mut num2).expect("Erro ao ler entrada");
    num2 = num2.trim().parse().expect("Erro ao converter para inteiro");

    let resultado = num1 - num2;
    println!("Resultado da subtração: {}", resultado);
}
Faça um programa em Rust que leia um número real e imprima ¼ deste número.

fn main() {
    let mut num: f32 = 0.0;

    println!("Informe um número real:");
    std::io::stdin().read_line(&mut num).expect("Erro ao ler entrada");
    num = num.trim().parse().expect("Erro ao converter para float");

    let resultado = num / 4.0;
    println!("Resultado: {}", resultado);
}
Faça um programa em Rust que leia três números reais e calcule a média aritmética destes números. Ao final, o programa deve imprimir o resultado do cálculo.

fn main() {
    let mut num1: f32 = 0.0;
    let mut num2: f32 = 0.0;
    let mut num3: f32 = 0.0;

    println!("Informe o primeiro número:");
    std::io::stdin().read_line(&mut num1).expect("Erro ao ler entrada");
    num1 = num1.trim().parse().expect("Erro ao converter para float");

    println!("Informe o segundo número:");
    std::io::stdin().read_line(&mut num2

2 / 2





Faça um programa em Rust que leia três números reais e calcule a média aritmética destes números. Ao final, o programa deve imprimir o resultado do cálculo.
Para calcular a média aritmética de três números reais em Rust, você pode seguir os seguintes passos:

Declare as variáveis para armazenar os números reais:

let num1: f64;
let num2: f64;
let num3: f64;
Utilize a função scanf() para ler os números do teclado:

scanf!("{} {} {}", &num1, &num2, &num3);
Calcule a média aritmética dos números:

let media = (num1 + num2 + num3) / 3.0;
Imprima o resultado da média:

println!("A média aritmética é: {}", media);
O código completo ficaria assim:


use std::io;

fn main() {
    let mut input = String::new();

    println!("Informe o primeiro número:");
    io::stdin().read_line(&mut input).unwrap();
    let num1: f64 = input.trim().parse().unwrap();

    println!("Informe o segundo número:");
    input.clear();
    io::stdin().read_line(&mut input).unwrap();
    let num2: f64 = input.trim().parse().unwrap();

    println!("Informe o terceiro número:");
    input.clear();
    io::stdin().read_line(&mut input).unwrap();
    let num3: f64 = input.trim().parse().unwrap();

    let media = (num1 + num2 + num3) / 3.0;
    println!("A média aritmética é: {}", media);
}
Observe que, neste exemplo, utilizamos a função read_line() da biblioteca std::io para ler os n





Faça o mesmo para Faça um programa em rust que leia um número real e calcule o quadrado deste número. Aofinal, oprogramadeveimprimiroresultado docálculo.
Para resolver este exercício em Rust, você pode usar o seguinte código:


use std::io;

fn main() {
    println!("Informe um número real:");

    let mut num = String::new();
    io::stdin().read_line(&mut num).expect("Falha ao ler a entrada");

    let num: f64 = num.trim().parse().expect("Por favor, digite um número válido");
    let resultado = num * num;

    println!("O quadrado do número é: {}", resultado);
}
O código acima lê um número real do teclado, armazena na variável num e, em seguida, calcula o quadrado deste número armazenando o resultado na variável resultado. Por fim, o resultado é impresso na tela.





Faça o mesmo para Faça umprogramaemCqueleiaosaldodeumacontapoupançaeimprimao novo saldo, considerando um reajuste de 2%. 
Para resolver este exercício em Rust, você pode seguir o seguinte código:


fn main() {
    let mut saldo = 0.0;
    let mut reajuste = 0.0;

    println!("Informe o saldo da conta poupança:");
    io::stdin().read_line(&mut saldo).expect("Falha ao ler o saldo da conta poupança");
    saldo = saldo.trim().parse().expect("Por favor, insira um número válido");

    println!("Informe o percentual de reajuste:");
    io::stdin().read_line(&mut reajuste).expect("Falha ao ler o percentual de reajuste");
    reajuste = reajuste.trim().parse().expect("Por favor, insira um número válido");

    let novo_saldo = saldo * (1.0 + (reajuste / 100.0));
    println!("O novo saldo é: {}", novo_saldo);
}
Neste código, primeiro pedimos para o usuário informar o saldo da conta poupança e o percentual de reajuste. Em seguida, utilizamos as funções read_line e parse para ler a entrada do usuário e converter para o tipo f64. Depois, realizamos o cálculo do novo saldo utilizando a fórmula saldo * (1.0 + (reajuste / 100.0)) e, por fim, imprimimos o resultado na tela.





Faça o mesmo para Faça umprogramaemCqueleiaabaseeaalturadeumretânguloeimprimao perímetro (base + altura) e a área (base * altura). 
Para resolver este exercício em Rust, você pode usar a seguinte estrutura:


use std::io;

fn main() {
    println!("Informe a base do retângulo:");

    let mut base = String::new();
    io::stdin().read_line(&mut base).expect("Falha ao ler a entrada");

    let base: f32 = base.trim().parse().expect("Por favor, digite um número real válido");

    println!("Informe a altura do retângulo:");

    let mut altura = String::new();
    io::stdin().read_line(&mut altura).expect("Falha ao ler a entrada");

    let altura: f32 = altura.trim().parse().expect("Por favor, digite um número real válido");

    let perimetro = 2.0 * (base + altura);
    let area = base * altura;

    println!("Perímetro do retângulo: {}", perimetro);
    println!("Área do retângulo: {}", area);
}
Neste código, primeiro solicitamos ao usuário que informe a base do retângulo. Em seguida, lemos a entrada com a função read_line e armazenamos em uma variável do tipo String. Em seguida, convertemos o valor lido para o tipo f32 (número de ponto flutuante de 32 bits) e armazenamos na mesma variável.

O processo é repetido para ler a altura do retângulo. Em seguida, calculamos o perímetro e a área do retângulo com as fórmulas especificadas no enunciado do exercício e imprimimos o resultado na tela.





Faça o mesmo para Faça um programa em rust que leia o valor de um produto, o percentual do desconto desejado e imprima ovalor dodesconto eovalor doprodutosubtraindo o desconto. 
Para resolver o exercício "Faça um programa em rust que leia o valor de um produto, o percentual do desconto desejado e imprima o valor do desconto e o valor do produto subtraindo o desconto" em Rust, você pode seguir os seguintes passos:

Declare as variáveis necessárias: uma para armazenar o valor do produto, uma para armazenar o percentual de desconto e uma para armazenar o valor do desconto.

Utilize a função std::io::stdin().read_line() para ler o valor do produto e o percentual de desconto do teclado.

Converta os valores lidos para o tipo de variável correspondente (por exemplo, f32 para números reais).

Calcule o valor do desconto multiplicando o valor do produto pelo percentual de desconto.

Subtraia o valor do desconto do valor do produto para obter o novo valor.

Imprima o valor do desconto e o novo valor do produto utilizando a função println!().

A seguir, segue um exemplo de código que implementa essas etapas em Rust:


fn main() {
    // Declaração das variáveis
    let mut valor_produto: f32 = 0.0;
    let mut percentual_desconto: f32 = 0.0;
    let mut valor_desconto: f32 = 0.0;

    // Leitura do valor do produto e do percentual de desconto
    println!("Informe o valor do produto:");
    std::io::stdin().read_line(&mut valor_produto).expect("Falha ao ler o valor do produto");
    valor_produto = valor_produto.trim().parse().expect("Falha ao converter o valor do produto para f32");

    println!("Informe o percentual de desconto:");
    std::io::stdin().read_line(&mut percentual_desconto).expect("Falha ao ler o percentual de desconto");
    percentual_desconto = percentual_desconto.trim().parse().expect("Falha ao




Faça o mesmo para FaçaumprogramaemCquecalculeoreajustedosaláriodeumfuncionário.Para isso, o programa deverá ler o salário atual do funcionário e ler o percentual de reajuste. Ao final imprimir o valor do novo salário. 17. FaçaumprogramaemCquecalculeaconversãoentregrauscentígr 
Para fazer um programa em Rust que leia três números reais e calcule a média aritmética destes números, primeiro devemos importar a biblioteca de entrada e saída padrão (stdio) e a biblioteca de conversão de string para número (from_str). Em seguida, usamos a função read_line da biblioteca stdio para ler uma linha de entrada do teclado e armazená-la em uma string. Depois, usamos a função parse da biblioteca from_str para converter essa string em um número do tipo float. Podemos fazer isso três vezes para ler os três números reais. Finalmente, basta calcular a média aritmética e imprimir o resultado usando a função println da biblioteca stdio.

O código a seguir implementa essa lógica em Rust:


extern crate stdio;
extern crate from_str;

use stdio::stdin;
use stdio::println;
use from_str::from_str;

fn main() {
    let mut input = String::new();

    println("Insira o primeiro número real:");
    stdin().read_line(&mut input).expect("Erro ao ler entrada");
    let num1: f64 = from_str(input.trim()).expect("Erro ao converter para número");

    println("Insira o segundo número real:");
    input.clear();
    stdin().read_line(&mut input).expect("Erro ao ler entrada");
    let num2: f64 = from_str(input.trim()).expect("Erro ao converter para número");

    println("Insira o terceiro número real:");
    input




Faça o mesmo para FaçaumprogramaemCquecalculeoreajustedosaláriodeumfuncionário.Para isso, o programa deverá ler o salário atual do funcionário e ler o percentual de reajuste. Ao final imprimir o valor do novo salário. 
Para resolver este exercício em Rust, você pode usar a seguinte estrutura de código:


use std::io;

fn main() {
    println!("Informe o salário atual do funcionário:");

    let mut salario_atual = String::new();
    io::stdin().read_line(&mut salario_atual).expect("Falha ao ler a entrada");

    let salario_atual: f32 = salario_atual.trim().parse().expect("Por favor, insira um número válido");

    println!("Informe o percentual de reajuste:");

    let mut percentual_reajuste = String::new();
    io::stdin().read_line(&mut percentual_reajuste).expect("Falha ao ler a entrada");

    let percentual_reajuste: f32 = percentual_reajuste.trim().parse().expect("Por favor, insira um número válido");

    let novo_salario = salario_atual + (salario_atual * percentual_reajuste / 100.0);

    println!("O novo salário do funcionário é: {}", novo_salario);
}…"


Calculando valor prestação atrasada



Me dê o código em rust para este exercício Faça umprogramaemCquecalculeovalordeumaprestaçãoematraso. Para isso, o programa deve ler o valor da prestação vencida, a taxa periódica de juros e operíodo de atraso. Ao final, o programa deve imprimir o valor da prestação atrasada, o período de atraso, os juros que serão cobrados pelo período de atraso, ovalor da prestação acrescido dos juros. Considere juros simples.

Aqui está um exemplo de código em Rust que calcula o valor da prestação atrasada:


fn main() {
    // Lê o valor da prestação vencida
    let mut valor_prestacao = String::new();
    println!("Digite o valor da prestação vencida:");
    stdin().read_line(&mut valor_prestacao).unwrap();
    let valor_prestacao: f64 = valor_prestacao.trim().parse().unwrap();

    // Lê a taxa periódica de juros
    let mut taxa_juros = String::new();
    println!("Digite a taxa periódica de juros (em %):");
    stdin().read_line(&mut taxa_juros).unwrap();
    let taxa_juros: f64 = taxa_juros.trim().parse().unwrap();

    // Lê o período de atraso
    let mut periodo_atraso = String::new();
    println!("Digite o período de atraso (em dias):");
    stdin().read_line(&mut periodo_atraso).unwrap();
    let periodo_atraso: i32 = periodo_atraso.trim().parse().unwrap();

    // Calcula os juros cobrados pelo período de atraso
    let juros = valor_prestacao * (taxa_juros / 100.0) * (periodo_atraso as f64 / 365.0);

    // Calcula o valor da prestação atrasada (valor da prestação + juros)
    let valor_atrasado = valor_prestacao + juros;

    println!("Período de atraso: {} dias", periodo_atraso);
    println!("Juros cobrados: {:.2}", juros);
    println!("Valor da prestação atrasada: {:.2}", valor_atrasado);
}
Este código lê os valores da prestação vencida, da taxa de juros e do período de atraso do usuário através da entrada padrão (teclado). Em seguida, ele calcula os juros cobrados pelo período de atraso usando a fórmula juros = valor_prestacao * (taxa_juros / 100) * (periodo_atraso / 365), onde valor_prestacao é o valor da prestação vencida, taxa_juros é a taxa de juros em porcentagem e periodo_atraso é o período de atraso em dias. Finalmente, o código calcula o valor da prestação atrasada como sendo o valor da prestação vencida mais os j





Continue

Aqui está o resto do código:


fn main() {
    // Lê o valor da prestação vencida
    let mut valor_prestacao = String::new();
    println!("Digite o valor da prestação vencida:");
    stdin().read_line(&mut valor_prestacao).unwrap();
    let valor_prestacao: f64 = valor_prestacao.trim().parse().unwrap();

    // Lê a taxa periódica de juros
    let mut taxa_juros = String::new();
    println!("Digite a taxa periódica de juros (em %):");
    stdin().read_line(&mut taxa_juros).unwrap();
    let taxa_juros: f64 = taxa_juros.trim().parse().unwrap();

    // Lê o período de atraso
    let mut periodo_atraso = String::new();
    println!("Digite o período de atraso (em dias):");
    stdin().read_line(&mut periodo_atraso).unwrap();
    let periodo_atraso: i32 = periodo_atraso.trim().parse().unwrap();

    // Calcula os juros cobrados pelo período de atraso
    let juros = valor_prestacao * (taxa_juros / 100.0) * (periodo_atraso as f64 / 365.0);

    // Calcula o valor da prestação atrasada (valor da prestação + juros)
    let valor_atrasado = valor_prestacao + juros;

    println!("Período de atraso: {} dias", periodo_atraso);
    println!("Juros cobrados: {:.2}", juros);
    println!("Valor da prestação atrasada: {:.2}", valor_atrasado);
}






Me dê a solução do exercício acima para juros compostos 

Para calcular o valor da prestação atrasada com juros compostos, você pode usar a seguinte fórmula:


valor_atrasado = valor_prestacao * (1 + taxa_juros / 100.0)^(periodo_atraso / 365)
Onde valor_prestacao é o valor da prestação vencida, taxa_juros é a taxa de juros em porcentagem e periodo_atraso é o período de atraso em dias.

Aqui está o código em Rust que implementa esta lógica:


fn main() {
    // Lê o valor da prestação vencida
    let mut valor_prestacao = String::new();
    println!("Digite o valor da prestação vencida:");
    stdin().read_line(&mut valor_prestacao).unwrap();
    let valor_prestacao: f64 = valor_prestacao.trim().parse().unwrap();

    // Lê a taxa periódica de juros
    let mut taxa_juros = String::new();
    println!("Digite a taxa periódica de juros (em %):");
    stdin().read_line(&mut taxa_juros).unwrap();
    let taxa_juros: f64 = taxa_juros.trim().parse().unwrap();

    // Lê o período de atraso
    let mut periodo_atraso = String::new();
    println!("Digite o período de atraso (em dias):");
    stdin().read_line(&mut periodo_atraso).unwrap();
    let periodo_atraso: i32 = periodo_atraso.trim().parse().unwrap();

    // Calcula o valor da prestação atrasada com juros compostos
    let valor_atrasado = valor_prestacao * (1.0 + taxa_juros / 100.0).powf(periodo_atraso as f64 / 365.0);

    println!("Período de atraso: {} dias", periodo_atraso);
    println!("Valor da prestação atrasada: {:.2}", valor_atrasado);
}
Este código lê os valores da prestação vencida, da taxa de juros e do período de atraso do usuário através da entrada padrão (teclado). Em seguida, ele calcula o valor da prestação atrasada com juros compostos usando a fórmula mencionada acima. Finalmente, o código imprime o período de atraso e o valor da prestação atrasada na tela.

Espero que isso ajude





Resolver este exercício em rust Faça um programa em rustqueefetue a apresentação do valor da conversão em real (R$) de umvalor lido em dólar (US$). Para isso, será necessário também ler o valor da cotação do dólar.

Aqui está um exemplo de código em Rust que converte um valor em dólares para reais:


fn main() {
    // Lê o valor em dólares
    let mut valor_dolares = String::new();
    println!("Digite o valor em dólares:");
    stdin().read_line(&mut valor_dolares).unwrap();
    let valor_dolares: f64 = valor_dolares.trim().parse().unwrap();

    // Lê a cotação do dólar
    let mut cotacao_dolar = String::new();
    println!("Digite a cotação do dólar:");
    stdin().read_line(&mut cotacao_dolar).unwrap();
    let cotacao_dolar: f64 = cotacao_dolar.trim().parse().unwrap();

    // Calcula o valor em reais
    let valor_reais = valor_dolares * cotacao_dolar;

    println!("O valor em reais é: {:.2}", valor_reais);
}
Este código lê o valor em dólares e a cotação do dólar do usuário através da entrada padrão (teclado). Em seguida, ele calcula o valor em reais multiplicando o valor em dólares pela cotação do dólar. Finalmente, o código imprime o valor em reais na tela.







O Na linguagem comum, entende-se por instruções “um conjunto de regras ou normas definidas para a realização ou emprego de algo”. Em informática, porém, instrução é a informação que indica a um computador uma ação elementar a executar. O que são instruções para um computador? 

As instruções para um computador são as instruções de máquina, também conhecidas como código de máquina, que são usadas para dizer ao computador o que fazer. Essas instruções são escritas em linguagem de máquina, que é uma linguagem de baixo nível compreendida diretamente pelo hardware do computador.

Cada tipo de computador possui sua própria linguagem de máquina, que é específica para esse tipo de computador e pode ser diferente de outros tipos de computadores. Essas instruções são escritas como sequências de bits (0s e 1s) e são armazenadas na memória do computador. Quando o computador precisa executar uma tarefa, ele lê as instruções de máquina armazenadas na memória e as executa, um passo de cada vez.

As instruções de máquina podem incluir operações simples, como adição, subtração, multiplicação e divisão, assim como operações mais complexas, como manipulação de dados, entrada e saída de dados e controle de fluxo de programa.

Para facilitar a escrita de programas, os programadores geralmente usam linguagens de programação de alto nível, como C, Java ou Python, que são mais fáceis de ler e escrever do que a linguagem de máquina. Essas linguagens de programação são convertidas em código de máquina pelo compilador antes de serem executadas pelo computador.





O que são instruções escritas em linguagem de programação de computadorrew? 

As instruções escritas em linguagem de programação de computador são comandos escritos em uma linguagem de programação que são usados para dizer ao computador o que fazer. Essas instruções são escritas em uma linguagem de programação de alto nível, que é uma linguagem de programação que é mais fácil de ler e escrever do que a linguagem de máquina (que é compreendida diretamente pelo hardware do computador).

As instruções escritas em uma linguagem de programação de computador podem incluir comandos para realizar operações matemáticas, manipular dados, controlar o fluxo de execução do programa, ler e escrever dados em arquivos ou na entrada e saída padrão, entre outras coisas.

Para que o computador possa entender e executar essas instruções, elas precisam ser convertidas em código de máquina, que é a linguagem compreendida diretamente pelo hardware do computador. Isso é feito por um programa chamado compilador, que lê o código escrito em uma linguagem de programação de alto nível e o converte em código de máquina. Depois que o código é compilado, ele pode ser executado pelo computador.





Seqüências lógicas
Pode-se definir uma seqüência lógica como sendo um conjunto de passos executados até atingir um objetivo ou solução de um problema.
Até mesmo as coisas mais simples, podem ser descritas por seqüências lógicas.
Em outras palavras o que são seqüências lógicas? 

As seqüências lógicas são um conjunto de passos ou etapas que são seguidos para atingir um objetivo ou solucionar um problema. Elas são um meio de organizar e estruturar a resolução de um problema, de forma a garantir que todas as etapas necessárias sejam realizadas de maneira clara e consistente.

As seqüências lógicas podem ser usadas em diversos contextos, como na resolução de problemas matemáticos, na execução de tarefas domésticas ou no desenvolvimento de programas de computador. Em todos esses casos, elas servem como uma espécie de guia para a realização de uma tarefa, de forma a garantir que nenhum passo importante seja esquecido ou ignorado.

As seqüências lógicas podem ser descritas de maneira bastante simples, como uma lista de etapas a serem seguidas, ou de maneira mais complexa, usando diagramas ou notação matemática. Independentemente da forma como são descritas, elas são um meio importante de organizar e estruturar a resolução de problemas, a fim de garantir que os objetivos sejam alcançados de maneira eficiente e precisa.





Me dê um exemplo 

Aqui está um exemplo de uma seqüência lógica simples que pode ser usada para cozinhar um omelete:

Aquecer uma frigideira em fogo médio.
Quebrar dois ovos em um prato e misturar com uma colher de sopa de água.
Adicionar uma pitada de sal e pimenta a gosto.
Bater a mistura de ovos com a colher até ficar homogênea.
Adicionar um pouco de azeite ou manteiga na frigideira aquecida.
Despejar a mistura de ovos na frigideira e cozinhar até que os ovos estejam firmes.
Usar uma espátula para dobrar a metade da omelete sobre si mesma.
Deixar cozinhar por mais um minuto, até que a omelete esteja dourada por ambos os lados.
Retirar a omelete da frigideira e servir.
Essa é uma seqüência lógica simples, que pode ser seguida para cozinhar um omelete. Ela é composta por nove passos, que devem ser seguidos na ordem especificada para garantir o sucesso na tarefa.





Exercícios
Crie uma seqüência lógica para tomar banho.

Aqui está uma seqüência lógica para tomar banho:

Preparar todos os itens necessários, como toalha, sabonete, shampoo e condicionador.
Abrir a torneira e verificar se a água está na temperatura desejada.
Entrar no box ou banheira e fechar a porta ou cortina.
Molhar o corpo com água morna.
Aplicar o sabonete ou o gel de banho e esfregar o corpo com uma esponja ou escova.
Enxaguar o sabonete do corpo.
Aplicar o shampoo e massagear o couro cabeludo.
Enxaguar o shampoo do cabelo.
Aplicar o condicionador no cabelo, se desejado, e deixar agir por alguns minutos.
Enxaguar o condicionador do cabelo.
Desligar a água e sair do box ou banheira.
Se secar com uma toalha, começar pela cabeça e depois secar o corpo.
Vestir roupas limpas e secas.
Essa é uma seqüência lógica para tomar banho, que inclui os passos necessários para se limpar e se hidratar durante o banho. É importante seguir esses passos na ordem especificada para garantir que o banho seja eficiente e agradável.





Resolver Há três suspeitos de um crime: o cozinheiro, a governanta e o mordomo.  Sabe-se que o crime foi efetivamente cometido por um ou por mais de um deles, já que podem ter agido individualmente ou não.  Sabe-se, ainda que:
se o cozinheiro é inocente, então a governanta é culpada;
ou o mordomo é culpado ou a governanta é culpada, mas não os dois; 
o mordomo não é inocente.
Logo:
(a) a governanta e o mordomo são os culpados
(b) o cozinheiro e o mordomo são os culpados
(c) somente a governanta é culpada
(d) somente o cozinheiro é inocente
(e) somente o mordomo é culpado.
 

Para resolver este problema, podemos usar uma tabela de verdade. Primeiro, precisamos criar as variáveis lógicas para cada suspeito: C para o cozinheiro, G para a governanta e M para o mordomo.

A primeira informação que temos é que "se o cozinheiro é inocente, então a governanta é culpada". Isso pode ser escrito como "C -> G".

A segunda informação é que "ou o mordomo é culpado ou a governanta é culpada, mas não os dois". Isso pode ser escrito como "M xor G".

A terceira informação é que "o mordomo não é inocente". Isso pode ser escrito como "~M".

Agora, podemos preencher a tabela de verdade para essas três expressões lógicas:

C	G	M	C -> G	M xor G	~M
T	T	T	F	F	F
T	T	F	F	F	T
T	F	T	T	T	F
T	F	F	T	T	T
F	T	T	T	T	F
F	T	F	T	T	T
F	F	T	T	T	F
F	F	F	T	T	T
A partir da tabela de verdade, podemos ver que as únicas combinações de valores que satisfazem todas as três expressões são aquelas em que a governanta é culpada e o mordomo é inocente (G = T, M = F). Isso nos leva à resposta correta: (a) a governanta e o mordomo são os culpados.





Me dê o código em rust 

Para criar uma tabela de verdade em Rust, podemos usar um laço for para iterar sobre todas as combinações possíveis de valores para as variáveis lógicas C, G e M. Em seguida, podemos usar os operadores lógicos && (e lógico) e || (ou lógico) para verificar se cada combinação satisfaz as três expressões lógicas. Aqui está o código em Rust que faz isso:


fn main() {
    // Itera sobre todas as combinações possíveis de valores para C, G e M
    for c in [true, false].iter() {
        for g in [true, false].iter() {
            for m in [true, false].iter() {
                // Verifica se a combinação atual satisfaz as três expressões lógicas
                if (!c || g) && (m ^ g) && !m {
                    // Se sim, imprime os valores de C, G e M
                    println!("C = {}, G = {}, M = {}", c, g, m);
                }
            }
        }
    }
}
Quando esse código é executado, ele imprime as únicas combinações de valores que satisfazem as três expressões lógicas:


C = false, G = true, M = false






Me dê o teste de mesa 

Para realizar o teste de mesa para as três expressões lógicas do problema, precisamos criar uma tabela com as colunas para as variáveis lógicas C, G e M, e as linhas para as possíveis combinações de valores dessas variáveis. Em seguida, basta preencher a tabela com os valores de verdade das expressões lógicas para cada combinação de valores.

Aqui está a tabela de teste de mesa:

C	G	M	C -> G	M xor G	~M
T	T	T	F	F	F
T	T	F	F	F	T
T	F	T	T	T	F
T	F	F	T	T	T
F	T	T	T	T	F
F	T	F	T	T	T
F	F	T	T	T	F
F	F	F	T	T	T
A partir da tabela de teste de mesa, podemos ver que as únicas combinações de valores que satisfazem todas as três expressões lógicas são aquelas em que a governanta é culpada e o mordomo é inocente (G = T, M = F). Isso nos leva à resposta correta: (a) a governanta e o mordomo são os culpados.

IMPORTANTE
Um teste de mesa é um método de teste de software que consiste em avaliar o comportamento de um programa ou função usando diferentes entradas e comparando os resultados obtidos com os esperados. O teste de mesa é realizado manualmente, geralmente usando uma tabela que lista as entradas e os resultados esperados para cada uma delas.
O objetivo de um teste de mesa é garantir que o programa ou função esteja funcionando corretamente e produzindo os resultados esperados para diferentes entradas. Isso é importante para garantir a qualidade do software e evitar erros ou bugs que podem afetar o seu funcionamento.
Para realizar um teste de mesa, é importante ter um entendimento claro da lógica do programa ou função e do que é esperado como resultado para cada entrada. Em seguida, é preciso definir um conjunto de entradas de teste e os resultados esperados para cada uma delas, e depois executar o programa ou função com essas entradas e comparar os resultados obtidos com os esperados. Se houver diferenças entre os resultados obtidos e os esperados, isso pode indicar um problema no programa ou função e pode ser necessário corrigi-lo.

Existem algumas maneiras diferentes de realizar um teste de mesa:
Teste de mesa manual: neste tipo de teste, o programa ou função é executado manualmente com diferentes entradas e os resultados são comparados com os esperados.
Teste de mesa automatizado: neste tipo de teste, é criado um script ou programa que executa automaticamente o teste de mesa, comparando os resultados obtidos com os esperados. Isso é útil quando são necessários muitos testes de mesa ou quando é necessário testar o programa ou função com muitas entradas diferentes.
Teste de mesa com uso de ferramentas: existem ferramentas de software que podem ser usadas para automatizar o processo de teste de mesa. Essas ferramentas permitem que você crie tabelas de teste de mesa e execute o teste automaticamente, comparando os resultados obtidos com os esperados.
Independentemente da abordagem escolhida, é importante ter um entendimento claro da lógica do programa ou função e do que é esperado como resultado para cada entrada. Além disso, é importante definir um conjunto de entradas de teste e resultados esperados de forma cuidadosa para garantir que o teste de mesa seja eficaz em identificar possíveis erros ou bugs no programa ou função.





Qual o número que completa a seqüência: 1, 3, 6, 10, ...
(a) 13
(b) 15
(c) 12
(d) 11
(e) 18

Para encontrar o próximo número da seqüência, precisamos observar a forma como os números estão sendo gerados. A cada passo, o próximo número é obtido somando o número anterior mais um. Por exemplo, para encontrar o número seguinte a 3, basta somar 3 + 1 = 4.

Aplicando esse mesmo raciocínio, podemos encontrar o próximo número da seqüência: 10 + 1 = 11. Portanto, a resposta correta é (d) 11.





Faça a seqüência lógica para somar dois números e multiplicar o resultado pelo primeiro número.

Aqui está uma seqüência lógica para somar dois números e multiplicar o resultado pelo primeiro número:

Armazenar o primeiro número em uma variável.
Armazenar o segundo número em outra variável.
Soma os dois números e armazena o resultado em uma terceira variável.
Multiplica a terceira variável pelo primeiro número e armazena o resultado em uma quarta variável.
Imprime o valor da quarta variável.
Essa é uma seqüência lógica simples, que pode ser seguida para realizar a operação descrita. É importante seguir os passos na ordem especificada para garantir o sucesso na tarefa.





Qual o número que completa a seqüência: 1, 1, 2, 3, 5, ...
(a) 5
(b) 6
(c) 7
(d) 8
(e) 9

Para encontrar o próximo número da seqüência, precisamos observar a forma como os números estão sendo gerados. A cada passo, o próximo número é obtido somando os dois números anteriores. Por exemplo, para encontrar o número seguinte a 2, basta somar 1 + 2 = 3.

Aplicando esse mesmo raciocínio, podemos encontrar o próximo número da seqüência: 3 + 5 = 8. Portanto, a resposta correta é (d) 8.

Essa seqüência é conhecida como série de Fibonacci, que é uma sequência de números inteiros em que cada termo é a soma dos dois anteriores. Ela é muito utilizada em diversas áreas da matemática e da ciência, e é gerada seguindo a regra descrita acima.





Descreva com detalhes a seqüência lógica para trocar um pneu de um carro.

Aqui está uma seqüência lógica detalhada para trocar um pneu de um carro:

Verifique se você tem todos os equipamentos necessários, como chave de roda, jack, macaco, estepe e ferramentas de bordo.
Certifique-se de que o carro esteja parado em uma superfície plana e estável, longe de tráfego e de qualquer obstáculo.
Engate o freio de estacionamento e coloque o carro em ponto morto.
Localize o ponto de apoio para o jack no carro e levante o veículo o suficiente para que o pneu danificado fique do mesmo nível que o solo.
Desaparafuse e remova a roda de liga leve ou a roda de aço, dependendo do modelo do carro.
Retire o pneu danificado do carro.
Verifique se o estepe está em bom estado de conservação, sem cortes ou rachaduras.
Posicione o estepe no lugar do pneu danificado e prenda-o com os parafusos ou porcas de roda




Num concurso de saltos, Maria foi, simultaneamente, a 13ª melhor e 13ª pior.  Quantas pessoas estavam em competição?
(a) 13
(b) 25
(c) 26
(d) 27
(e) 28

Para resolver esse problema, precisamos observar que Maria foi a 13ª melhor e 13ª pior entre os participantes do concurso. Isso significa que houve 12 pessoas que saltaram melhor do que ela e 12 pessoas que saltaram pior. No total, são 12 + 1 + 12 + 1 = 26 pessoas. Portanto, a resposta correta é (c) 26.





Bruno é mais alto que Joaquim.  Renato é mais baixo que o Bruno.  Então, Joaquim é o mais alto dos três.
(   ) Verdadeiro
(   ) Falso

Essa afirmação é falsa. De acordo com as informações fornecidas, Bruno é mais alto do que Joaquim e Renato é mais baixo do que Bruno. Portanto, Joaquim pode ser mais alto do que Renato, mas não necessariamente é o mais alto dos três. A resposta correta é (f) Falso.





Faça um algoritmo para trocar uma lâmpada.

Aqui está um algoritmo para trocar uma lâmpada:

Desligue a lâmpada. Se ela estiver no interruptor, basta desligá-lo. Se ela estiver em uma tomada, basta desplugá-la.
Certifique-se de que a lâmpada esteja fria antes de tocá-la.
Localize a lâmpada e verifique se você tem uma lâmpada de reposição do mesmo tipo.
Segure a lâmpada com cuidado e retire-a do suporte.
Coloque a nova lâmpada no suporte e verifique se ela está bem presa.
Ligue a lâmpada novamente. Se ela estiver no interruptor, basta ligá-lo. Se ela estiver em uma tomada, basta plugá-la.
Teste a lâmpada para ver se está funcionando corretamente.






Tradutores: compiladores e interpretadores
Para executar um programa escrito numa linguagem de alto nível é preciso primeiro traduzir o código-fonte para código-objeto. O processo de tradução pode dar-se em tempo de execução caso a linguagem use um interpretador (traduz e executa instrução a instrução), ou todas as instruções podem ser traduzidas antes que se inicie a execução do programa, o que ocorre no caso de linguagens que usam tradutores do tipo compilador. 

Código-fonte: não é executável diretamente pelo processador - permite apenas que o programador consiga definir o programa em uma forma legível aos humanos. 
Código-objeto: é o código produzido pelo compilador; é uma forma intermediária, similar a linguagem de máquina do computador. Apesar de estar representado em binário, não é executável diretamente pelo processador, pois normalmente, o código-objeto referencia partes de programa que não estão necessariamente definidas no mesmo arquivo que o gerou, por exemplo, arquivos de bibliotecas de sub-rotinas. 
Editores de ligação (ou linkeditores): Um programa que reúne módulos compilados e arquivos de dados para criar um programa executável. Os linkeditores têm também outras funções, como a criação de bibliotecas.
Compilador: No sentido mais geral, qualquer programa que transforme um conjunto de símbolos em outro obedecendo a uma série de regras sintáticas e semânticas; no sentido mais comum, um programa que traduz todo o código-fonte de programas escritos numa linguagem de alto nível em código-objeto antes da execução do programa. Ou seja, traduz o programa escrito em linguagem de alto nível (código-fonte) para um programa equivalente escrito em linguagem de máquina (código-objeto).

Interpretador: traduz e envia para execução, instrução por instrução e o programa permanece na forma fonte.
 Como funciona este processo em rust 

Em Rust, o processo de compilação é realizado por um compilador chamado "rustc". Ele lê o código-fonte escrito em Rust e o traduz para código-objeto, que é um arquivo executável.

O processo de compilação é iniciado quando você digita o comando "cargo build" na linha de comando, seguido do nome do projeto que deseja compilar. O compilador rustc é invocado pelo gerenciador de pacotes Cargo, que é a ferramenta padrão para gerenciamento de projetos em Rust.

O rustc compila o código-fonte em três etapas: pré-processamento, compilação e ligação. Durante o pré-processamento, o rustc expande os macros e inclui os arquivos de cabeçalho. Na etapa de compilação, o rustc transforma o código-fonte em código intermediário, que é um formato intermédio entre o código-fonte e o código-objeto. Finalmente, na etapa de ligação, o rustc combina o código intermediário com as bibliotecas de sistema e gera o código-objeto final.

Em resumo, o processo de compilação em Rust é realizado por um compilador chamado rustc, que é invocado pelo gerenciador de pacotes Cargo. O rustc transforma o código-fonte escrito em Rust em código-objeto através de três etapas: pré-processamento, compilação e ligação. Ao final, é gerado um arquivo executável que pode ser rodado no sistema.

Espero que isso ajude a entender o processo de compilação em Rust. Se você tiver alguma dúvida ou precisar de mais ajuda, basta perguntar.





Funções pré-definidas
A seguir, são apresentadas algumas funções matemáticas pré-definidas na linguagem Pascal.
Quais são as funções pré-definidas em rust 

Rust possui uma série de funções matemáticas pré-definidas no módulo "std::f64", que é parte da biblioteca padrão do Rust. Aqui estão algumas das funções mais comuns:

abs: retorna o valor absoluto de um número.
ceil: arredonda um número para cima.
floor: arredonda um número para baixo.
max: retorna o maior valor entre dois números.
min: retorna o menor valor entre dois números.
round: arredonda um número para o inteiro mais próximo.
trunc: remove a parte fracionária de um número.
Essas são apenas algumas das funções pré-definidas em Rust. Existem muitas outras, incluindo funções trigonométricas, funções de exponenciação e logaritmo, funções de conversão de radianos para graus e vice-versa, entre outras. Você pode encontrar a lista completa de funções matemáticas pré-definidas no módulo "std::f64" na documentação da biblioteca padrão do Rust.

Espero





//
\end{comment}
 


\section{Estruturas de decisão em Rust}

As estruturas de controle de fluxo são elementos fundamentais em qualquer linguagem de programação, permitindo que os programas tomem decisões e executem ações diferentes com base em condições específicas. Em Rust, as estruturas de controle de fluxo mais comuns são o "if-else" e o "match".

\subsection{Estrutura de Decisão if-else}

A estrutura de decisão "if-else" é usada em Rust para executar código condicionalmente com base em uma condição booleana. A sintaxe básica para o uso do "if-else" em Rust é a seguinte:
%\lstinputlisting[language=rust, caption = exemplo de if -else   ]{codigos/captulo2/if.rs}


Neste exemplo, a condição numero == a 0 é verificada usando o comando if. Se for verdadeira, será impressa a mensagem "O numero nao eh igual a 0", caso contrário, será testa a condição de numero == se for verdadeira executa "O numero nao eh igual a 1", caso for falsa irá escrever na tela texto "valor nao eh 0 ou 1".

A condição pode ser uma expressão booleana simples, como uma comparação entre variáveis ou constantes, ou uma chamada de função que retorna um valor booleano. Se a condição for verdadeira, o código dentro do bloco "if" será executado, caso contrário, o código dentro do bloco "else" será executado.

É importante notar que em Rust a condição não precisa estar entre parênteses, como é comum em outras linguagens de programação. Além disso, os blocos de código são delimitados por chaves "\{\}", e é obrigatório usar chaves mesmo quando o bloco contém apenas uma instrução.

 

\section{Estrutura de Decisão match}

A estrutura de decisão "match" em Rust é usada para fazer correspondências entre diferentes valores e executar ações diferentes com base no valor correspondido. A sintaxe básica para o uso do "match" em Rust é a seguinte:
Aqui está um exemplo de código em Rust usando o comando match:
%\lstinputlisting[language=rust, caption = Exemplo decisão match   ]{codigos/captulo2/match.rs}


Neste exemplo, o valor da variável numero é comparado com diferentes padrões usando o comando match. Se o valor for igual a 1, será impressa a mensagem "O numero eh 1", se for igual a 2, será impressa a mensagem "O numero eh 2", e assim por diante. O \_ é um padrão curinga que corresponde a qualquer valor e é usado como ação padrão para outros valores que não correspondem aos padrões anteriores.


A estrutura "match" é particularmente útil quando se trabalha com tipos enumerados (enums) em Rust, que são tipos que podem ter um conjunto limitado de valores possíveis. O "match" permite que você faça correspondências exaustivas entre os diferentes valores possíveis e execute ações específicas para cada valor correspondido.

\subsection{Operadores Relacionais em Rust}

Em Rust, os operadores relacionais são utilizados para comparar dois valores e retornar um valor booleano (verdadeiro ou falso). Os operadores relacionais disponíveis em Rust são:

\begin{itemize}
\item \texttt{==}: retorna verdadeiro se os valores comparados forem iguais
\item \texttt{!=}: retorna verdadeiro se os valores comparados forem diferentes
\item \texttt{>}: retorna verdadeiro se o valor à esquerda for maior que o valor à direita
\item \texttt{<}: retorna verdadeiro se o valor à esquerda for menor que o valor à direita
\item \texttt{>=}: retorna verdadeiro se o valor à esquerda for maior ou igual ao valor à direita
\item \texttt{<=}: retorna verdadeiro se o valor à esquerda for menor ou igual ao valor à direita
\item \texttt{\&\& (conjunção)}: verdadeira se e somente se ambas as expressões forem verdadeiras.
\item \texttt{|| (disjunção)}: verdadeira se pelo menos uma das expressões for verdadeira.
\item \texttt{! (negação)}: inverte o valor de uma expressão, ou seja, se a expressão for verdadeira, a negação será falsa e vice-versa.

\end{itemize}

Aqui está um exemplo de como esses operadores podem ser usados em Rust:

%\lstinputlisting[language=rust, caption = exemplo de operadores binários]{codigos/captulo2/operadores.rs}


\subsection{Pattern Matching em Rust}
Pattern matching em Rust é uma técnica para comparar um valor com diferentes padrões e executar diferentes ações de acordo com qual padrão é correspondido. É uma forma de selecionar diferentes caminhos de execução com base no formato ou no conteúdo de um dado valor.

O pattern matching é uma característica poderosa da linguagem de programação Rust, que permite verificar e extrair padrões em dados. Ele é particularmente útil quando se lida com estruturas de dados complexas ou quando se deseja realizar várias ações com base em diferentes combinações de valores.

Em Rust, o pattern matching é implementado usando a expressão \texttt{match}. A estrutura básica de uma expressão \texttt{match} em Rust é a seguinte:



Nesse exemplo, \texttt{valor} é o valor que está sendo verificado, \texttt{padrão1} e \texttt{padrão2} são padrões possíveis que podem corresponder ao \texttt{valor}. O \texttt{\_} é um curinga que corresponde a qualquer valor.

O pattern matching em Rust oferece uma maneira concisa e legível de lidar com diferentes cenários com base em padrões de dados. Ele ajuda a evitar a necessidade de múltiplos blocos \texttt{if} encadeados e simplifica o código, tornando-o mais expressivo e robusto.

%\lstinputlisting[language=rust, caption = exemplo de operadores binários]{codigos/captulo2/patternmatch.rs}


Neste exemplo, o valor da variável \texttt{valor} é comparado com diferentes padrões usando a expressão \texttt{match}. Dependendo do valor, uma ação específica é executada.

O pattern matching é uma ferramenta poderosa em Rust, e sua compreensão e aplicação adequadas podem melhorar a legibilidade e a eficiência do código. É uma das características distintivas da linguagem e um aspecto fundamental a ser dominado pelos desenvolvedores Rust.

Exercicios :



\begin{comment}
Exemplo:


if num > 20 {
    // instruções a serem executadas se a condição for verdadeira
} else {
    // instruções a serem executadas se a condição for falsa
}
Neste exemplo, as instruções que estão dentro do bloco de código da cláusula if e else estão indentadas, o que indica a relação de dependência entre elas e a cláusula. Isso torna mais fácil entender qual código será executado em cada situação.





Como ficaria sem Indentação 

3 / 3


network error

mo. Portanto, é recomendado sempre utilizar indentação em seus programas em Rust.

Sem indentação, o código ficaria mais difícil de ler e de entender a estrutura do programa. Por exemplo:


fn main() {
if (num > 20) {
resul = num * 2;
} else {
resul = num * 4;
}
println!("Resultado: {}", resul);
}
Com indentação:


fn main() {
    if (num > 20) {
        resul = num * 2;
    } else {
        resul = num * 4;
    }
    println!("Resultado: {}", resul);
}




Em C temos 4 Cláusula if-else com n blocos de instruções Até o momento foram apresentadas situações que envolvam a execução ou não de umfluxo,neste caso, a presença apenas do comando if e a execução de um fluxoou outro, nesta situação, a presença do if-else, mas e se for necessário que o programa decida entre 3 fluxos diferentes? Ou ainda, 4 fluxos ou mais? Quando precisar tratar "n" fluxos nadecisão das instruções a serem executadas, associe o uso do else com o if. Como é em Rust 

2 / 2


Em Rust, a cláusula if é utilizada de forma semelhante ao C. Você pode utilizar vários else if para tratar vários fluxos de decisão. Por exemplo:


if condicao1 {
    // instruções a serem executadas se condicao1 for verdadeira
} else if condicao2 {
    // instruções a serem executadas se condicao2 for verdadeira
} else if condicao3 {
    // instruções a serem executadas se condicao3 for verdadeira
} else {
    // instruções a serem executadas se nenhuma das condições anteriores for verdadeira
}
Você também pode utilizar o operador match em Rust para tratar vários fluxos de decisão. O match funciona como um switch em outras linguagens de programação. Por exemplo:


match expressao {
    valor1 => instrucoes1,
    valor2 => instrucoes2,
    valor3 => instrucoes3,
    _ => instrucoes_padrao, // opcional, para tratar qualquer outro valor
}




Veja um exercício em C Oescritório de contabilidade Super Contábil está realizando o reajuste do salário dos funcionários de todos os seus clientes. Para isso, estão utilizando como referência o reajuste acordadocomossindicatosdecadaclassetrabalhadora,conformeapresentado na tabela a seguir. Para ajudar o escritório nesta tarefa, faça um programa em rust que receba o salário atual, o cargo conforme especificado na tabela a seguir e realize o cálculo do reajuste do salário. Ao término do cálculo o programa deve imprimir o valor doreajuste e o novo salário do funcionário. Cód. cargo Cargo 1 Auxiliar de escritório %reajuste acordado 7% 2 Secretário(a) 9% 3 Cozinheiro(a) 5% 4 Entregador(a) 12% Para resolver este exercício foi utilizado o código do cargo para determinar a qual cargo pertence o funcionário, no qual o salário está sendo reajustado, assim, foi declarada umavariável do tipo inteiro para armazenar o cargo e foram declaradas duas variáveis do tipo real para armazenar o salário atual do funcionário e o valor do reajuste. Alémdisso,foiutilizada a estrutura dedecisãoif-else paradecidir qualfluxoexecutarde acordocomocargodofuncionário.Comosão4cargos,entãosãonecessários4fluxos distintosnaestruturadedecisão.Vejaaseguirarespostadoexercícioeoscomentários. 1#include<stdio.h> 2#include<stdlib.h> 3voidmain(){ 4intcargo; 5floatsalAtual,reajuste; 6printf("Informeocargodofuncionario:"); 7scanf("%d",&cargo); 8printf("Informeosalarioatual:"); 9scanf("%f",&salAtual); 10 11if(cargo==1) 12reajuste=(salAtual*7)/100; 13elseif(cargo==2) 14reajuste=(salAtual*9)/100; 15elseif(cargo==3) 16reajuste=(salAtual*5)/100; 17else 18reajuste=(salAtual*12)/100; 19printf("Oreajustee:%f",reajuste); 20printf("Onovosalarioe:%f",salAtual+reajuste); 21}. Como fica em rust 

Em Rust, a estrutura de decisão if-else é usada da mesma forma que em C. Você pode usar o operador de igualdade == para verificar se um valor é igual a um determinado valor e o operador else if para adicionar mais condições. Aqui está como ficaria o código acima em Rust:


fn main() {
    let mut cargo = String::new();
    let mut sal_atual = String::new();

    println!("Informe o cargo do funcionário:");
    io::stdin().read_line(&mut cargo).expect("Falha ao ler entrada");
    let cargo: i32 = cargo.trim().parse().expect("Por favor, digite um número inteiro válido");

    println!("Informe o salário atual:");
    io::stdin().read_line(&mut sal_atual).expect("Falha ao ler entrada");
    let sal_atual: f32 = sal_atual.trim().parse().expect("Por favor, digite um número real válido");

    let reajuste: f32;
    if cargo == 1 {
        reajuste = (sal_atual * 7.0) / 100.0;
    } else if cargo == 2 {
        reajuste = (sal_atual * 9.0) / 100.0;
    } else if cargo == 3 {
        reajuste = (sal_atual * 5.0) / 100.0;
    } else {
        reajuste = (sal_atual * 12.0) / 100.0;
    }

    println!("O reajuste é: {}", reajuste);
    println!("O novo salário é: {}", sal_atual + reajuste);
}
Note que, diferentemente do código em C, aqui é necessário ler os valores de cargo e sal_atual como strings e, em seguida, convertê-los para os tipos de dados desejados (i32 e f32, respectivamente). Além disso, é preciso adicionar o mut ao lado das declarações de cargo e sal_atual, pois estamos usando o método read_line da interface stdin para atribuir valores a elas.





Em C  Cláusula if-else com condições compostas Até agora, foi ensinado a utilizar a estrutura de decisão if-else com apenas um bloco, com dois blocos, e com n blocos de instruções. Foi ensinado também a utilizar os operadores relacionais apresentados na tabela 8. Agora é necessário aprender a fazer testes de condição com acombinaçãodeoperadoreslógicos, emqueépossível fazer uso de conjunções, disjunções e negação (LOPES; GARCIA, 2002). Em linguagem C é possível combinar vários operadores em uma mesma condição, inclusive pode-se também combinar operadores diferentes. Como funciona em rust

Em Rust, assim como em C, é possível combinar operadores relacionais e lógicos para criar condições compostas. Alguns exemplos de operadores lógicos são:

&& (conjunção): verdadeira se e somente se ambas as expressões forem verdadeiras.
|| (disjunção): verdadeira se pelo menos uma das expressões for verdadeira.
! (negação): inverte o valor de uma expressão, ou seja, se a expressão for verdadeira, a negação será falsa e vice-versa.
Veja um exemplo de uso de operadores lógicos em uma estrutura de decisão if-else:


let x = 10;
let y = 20;

if (x > 5 && y < 30) {
    println!("A condição é verdadeira");
} else {
    println!("A condição é falsa");
}
Neste exemplo, a condição composta é x > 5 && y < 30, que será verdadeira se ambas as expressões forem verdadeiras. Como x > 5 é verdadeiro e y < 30 também é verdadeiro, a condição será verdadeira e o bloco de instruções dentro do if será executado.

Também é possível combinar operadores relacionais e lógicos em uma mesma condição. Por exemplo:


let a = 10;
let b = 20;
let c = 30;

if ((a < b || a > c) && b != c) {
    println!("A condição é verdadeira");
} else {
    println!("A condição é falsa");
}
Neste exemplo, a condição composta é (a < b || a > c) && b != c, que será verdadeira se pelo menos uma das expressões entre parênteses for verdadeira E b for diferente de c. Como a < b é verdadeiro, a disjunção a < b || a > c será verdadeira e, como b != c também é verdadeiro, a condição composta será verdadeira e o bloco de instruções dentro do if será executado.





Me dê uma tabela com Operadores lógicos, significado em português, como é na linguagem Rust e um exemplo

A seguir, apresentamos uma tabela com os operadores lógicos em Rust, seus significados em português e um exemplo de uso de cada um:

Operador	Significado	Exemplo
&&	E	(a > b) && (c < d)
||	OU	(a == b) || (c != d)
!	NÃO	!(a > b)
Os operadores lógicos são utilizados para combinar condições em uma estrutura de decisão, por exemplo:


if ((a > b) && (c < d)) {
  // Instruções a serem executadas caso a condição seja verdadeira
}
Neste exemplo, a condição só será verdadeira se a for maior que b E c for menor que d.


if ((a == b) \|\| (c != d)) {
  // Instruções a serem executadas caso a condição seja verdadeira
}
Neste exemplo, a condição só será verdadeira se a for igual a b OU c for diferente de d.


if (!(a > b)) {
  // Instruções a serem executadas caso a condição seja verdadeira
}
Neste exemplo, a condição só será verdadeira se a não for maior que b.





Veja mais 1 Exercício de Exemplo em c Ohospital local está fazendo uma campanha para receber doação de sangue. O propenso doador deveinicialmente se cadastrar informando o seu nome completo, sua idade, seu peso, responder a um breve questionário e apresentar um documento oficial comfoto.Façaumprogramaquepermitaaohospitalrealizarocadastrodosvoluntários para avaliar a aptidão quanto à doação de sangue. Para estar apto a doar, o voluntário deve ter idade entre 16 e 69, pesar pelo menos 50 kg, estar bem alimentado e nãoestar resfriado. O programa deve ler os dados e imprimir no final o nomedovoluntárioese ele está apto ou não. #include <stdio.h> 2 #include <stdlib.h> 3 void main() { 4 char nome[30]; 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 } int idade, bemAlimentado, resfriado; float peso; printf("Informe o nome:"); scanf("%s", &nome); printf("Informe o peso:"); scanf("%f", &peso); printf("Informe a idade:"); scanf("%d", &idade); printf("Esta bem alimentado? <1-SIM / 0-NAO>"); scanf("%d", &bemAlimentado); printf("Esta resfriado? <1-SIM / 0-NAO>"); scanf("%d", &resfriado); if (peso >= 50 && (idade >= 16 && idade <= 69) && bemAlimentado && !resfriado) printf("O voluntario %s esta apto!", nome); else printf("O voluntario %s NAO esta apto", nome); me dê o código em rust 

Para resolver esse exercício em Rust, é necessário utilizar o mesmo tipo de lógica e estruturas de controle de fluxo presentes no código em C apresentado. Além disso, é preciso levar em consideração algumas diferenças sintáticas entre as duas linguagens, como a forma de declarar e ler variáveis, e a forma de imprimir texto na tela. A seguir, apresento uma possível implementação do código em Rust:


use std::io;

fn main() {
    println!("Informe o nome:");

    let mut nome = String::new();
    io::stdin().read_line(&mut nome).unwrap();
    let nome = nome.trim();

    println!("Informe o peso:");
    let mut peso = String::new();
    io::stdin().read_line(&mut peso).unwrap();
    let peso: f32 = peso.trim().parse().unwrap();

    println!("Informe a idade:");
    let mut idade = String::new();
    io::stdin().read_line(&mut idade).unwrap();
    let idade: i32 = idade.trim().parse().unwrap();

    println!("Está bem alimentado? <1-SIM / 0-NAO>");
    let mut bem_alimentado = String::new();
    io::stdin().read_line(&mut bem_alimentado).unwrap();
    let bem_alimentado: i32 = bem_alimentado.trim().parse().unwrap();

    println!("Está resfriado? <1-SIM / 0-NAO>");
    let mut resfriado = String::new();
    io::stdin().read_line(&mut resfriado).unwrap();
    let resfriado: i32 = resfriado.trim().parse().unwrap();

    if peso >= 50.0 && (idade >= 16 && idade <= 69) && bem_alimentado == 1 && resfriado == 0 {
        println!("O voluntário {} está apto!", nome);
    } else {
        println!("O voluntário {} NÃO está apto", nome);
    }
}




Mais um Exercício de Exemplo em c Segundoumatabelamédica,opesoidealestá relacionado com aaltura e osexo. Faça umprograma em rustque receba a altura e o sexo de uma pessoa, após isso calcule e imprimaoseupesoideal, utilizando as seguintes fórmulas: • Parahomens:(72,7 *A)–58 • Paramulheres: (62,1 * A)– 44,7 • Emque: A=Altura do #include <stdio.h> 2 #include <stdlib.h> 3 void main() { 4 int altura; 5 6 7 8 9 10 11 12 13 14 15 16 } char sexo; float pesoIdeal; printf("Informe a altura:"); scanf("%d", &altura); printf("Informe o sexo: <M ou F>"); scanf("%c", &sexo); if (sexo == 'm' || sexo == 'M') pesoIdeal = (72.7 * altura)- 58; else pesoIdeal = (62.1 * altura)- 44.7; printf("O peso ideal e: %f", pesoIdeal); Oobjetivo deste exemplo é mostrar o uso dooperadorlógico de disjunção, o "OU". Entre as linhas 1 e 10 foi feita a declaração das variáveis e a leitura dos valores informados pelo usuário, é importante notar que a variável sexo foi declarada como char, ou seja, para possibilitar ao usuário que informe uma letra. As letras tem variações entre minúscula e maiúscula, neste exemplo, serão utilizadas duas consoantes, "M"ou "m"e "F"ou "f". Desta forma, ao informar o sexo, pode ocorrer do usuário informar com letra maiúscula ou minúscula mesmocomaorientaçãodalinha9. Aestrutura de decisão será responsável então, por tratar essa variação entre letras minúsculas ou maiúsculas. Na linha 11 da resposta proposta são apresentadas então as duas condições para a validade da condição geral, ou seja, se o usuário informar "M"ou "m"acondiçãogeral será verdadeira e a instrução para o cálculo do peso ideal será feito para ohomemnalinha12.Seousuárioinformarqualqueroutraletra,entãoacondição será considerada falsa e será executado o cálculo para o peso ideal da mulher na linha 14. Após realizar o cálculo, o resultado do peso ideal é impresso pela instrução da linha 16 daresposta do exercício. Me dê o código em rust 

Aqui está como ficaria o código em Rust:


use std::io;

fn main() {
    let mut altura = String::new();
    let mut sexo = String::new();

    println!("Informe a altura:");
    io::stdin().read_line(&mut altura).expect("Erro ao ler a altura");
    let altura: i32 = altura.trim().parse().expect("Erro ao converter a altura para inteiro");

    println!("Informe o sexo: <M ou F>");
    io::stdin().read_line(&mut sexo).expect("Erro ao ler o sexo");
    let sexo = sexo.trim();

    let peso_ideal: f32;
    if sexo == "M" || sexo == "m" {
        peso_ideal = (72.7 * altura as f32) - 58.0;
    } else {
        peso_ideal = (62.1 * altura as f32) - 44.7;
    }

    println!("O peso ideal é: {}", peso_ideal);
}
Algumas observações sobre o código:

Em Rust, ao invés de usar a função scanf, é preciso ler a entrada do usuário com a função read_line da biblioteca std::io.
A leitura do sexo foi feita como uma string, já que o Rust não possui o tipo char como em C.
As strings em Rust são imutáveis por padrão, então é preciso usar a declaração mut para torná-las mutáveis.
O método `trim




Continuar 

Para continuar a resolução do exercício proposto em Rust, basta utilizar a mesma lógica do código em C, adaptando a sintaxe para a linguagem Rust. Veja a seguir a resposta proposta:


fn main() {
    let mut altura: i32;
    let mut sexo: char;
    let mut peso_ideal: f32;

    println!("Informe a altura:");
    io::stdin().read_line(&mut altura).expect("Falha ao ler a altura");
    altura = altura.trim().parse().expect("Falha ao converter a altura em número inteiro");

    println!("Informe o sexo: <M ou F>");
    io::stdin().read_line(&mut sexo).expect("Falha ao ler o sexo");

    if sexo == 'M' || sexo == 'm' {
        peso_ideal = (72.7 * altura as f32) - 58.0;
    } else {
        peso_ideal = (62.1 * altura as f32) - 44.7;
    }

    println!("O peso ideal é: {:.1}", peso_ideal);
}
Observe que foi necessário realizar algumas adaptações no código em C, como a utilização da função read_line para a leitura das variáveis altura e sexo, e a conversão da variável altura para o tipo f32 antes de realizar os cálculos. Além disso, foi utilizado o formato de impressão `{:.





Em C temos  Cláusula if-else com condições aninhadas Aestrutura de decisão if-else permite também o uso de condições aninhadas (encaixadas) que são úteis quando é necessário tomar umadecisão dentro de outra. A seguir umexercício para exemplificar o uso de if aninhado. Como funciona em rust 

Em Rust, o uso de condições aninhadas funciona da mesma forma que em C. Para exemplificar o uso de if aninhado em Rust, veja o seguinte exemplo:


fn main() {
    let idade = 25;

    if idade < 18 {
        println!("Menor de idade");
    } else {
        if idade < 60 {
            println!("Maior de idade, mas ainda não aposentado");
        } else {
            println!("Maior de idade e aposentado");
        }
    }
}
Neste exemplo, o programa verifica se a idade informada é menor que 18. Se sim, a mensagem "Menor de idade" é impressa. Se não, é verificado se a idade é menor que 60. Se sim, a mensagem "Maior de idade, mas ainda não aposentado" é impressa. Se não, a mensagem "Maior de idade e aposentado" é impressa.

Assim como em C, é importante tomar cuidado para não aninhar demais as condições, pois isso pode deixar o código difícil de ler e de entender. É recomendado utilizar condições anin





Em C temos o seguinte Exercício de Exemplo Faça umprogramaemCqueleiaodestinodopassageiro, se aviageminclui retorno (ida e volta) e informe o preço da passagem conformeatabela aseguir: CÓD.DESTINO DESTINO IDA 1 Região Norte 500,00 IDAEVOLTA 900,00 2 Região Nordeste 350,00 650,00 3 Região Centro-oeste 350,00 600,00 4 Região Sul 300,00 Fonte: Adaptado de Lopes eGarcia (2002, p. 113) Pararesolveresteexercícioseránecessárioprimeiroverificarqualéodestino,depois deverificarodestino,verificarseotrechoincluisomenteidaouidaevolta,ouseja,há umaverificaçãocondicionadaaoutra,aprimeiraseráodestinoeasegundaeaninhada àprimeira,seráacondiçãodotrecho. 1#include<stdio.h> 2#include<stdlib.h> 3voidmain(){ 4intdestino,trecho; 5printf("Informeodestinoconformetabelaaseguir:\n"); 6printf("1-RegiaoNorte\t3-RegiaoCentro-oeste\n"); 7printf("2-RegiaoNordeste\t4-RegiaoSul\n"); 8scanf("%d",&destino); 9printf("Informeotrecho:<1-IDAou2-IDAEVOLTA>"); 10scanf("%d",&trecho); 11if(destino==1){ 12if(trecho==1) 13printf("Regiaonorte[IDA]=500,00"); 14else 15printf("Regiaonorte[IDAEVOLTA]=900,00"); 16} 17elseif(destino==2){ 18if(trecho==1) 19printf("Regiaonordeste[IDA]=350,00"); 20else 21printf("Regiaonordeste[IDAEVOLTA]=650,00"); 22} 23elseif(destino==3){ 24if(trecho==1) 25printf("Regiaocentro-oeste[IDA]=350,00"); 26else 27printf("Regiaocentro-oeste[IDAEVOLTA]=600,00"); 28} 29else{ 30if(trecho==1) 31printf("Regiaosul[IDA]=300,00"); 32else 33printf("Regiaosul[IDAEVOLTA]=550,00"); 34} 35} como fica a solução em rust 

Aqui está como o código ficaria em Rust:


use std::io;

fn main() {
    println!("Informe o destino conforme tabela a seguir:");
    println!("1- Região Norte\t3- Região Centro-oeste");
    println!("2- Região Nordeste\t4- Região Sul");

    let mut destino = String::new();
    io::stdin().read_line(&mut destino).expect("Falha ao ler entrada");
    let destino: u32 = destino.trim().parse().expect("Por favor, insira um número válido");

    println!("Informe o trecho: <1- IDA ou 2- IDA E VOLTA>");

    let mut trecho = String::new();
    io::stdin().read_line(&mut trecho).expect("Falha ao ler entrada");
    let trecho: u32 = trecho.trim().parse().expect("Por favor, insira um número válido");

    if destino == 1 {
        if trecho == 1 {
            println!("Região norte [IDA] = 500,00");
        } else {
            println!("Região norte [IDA E VOLTA] = 900,00");
        }
    } else if destino == 2 {
        if trecho == 1 {
            println!("Região nordeste [IDA] = 350,00");
        } else {
            println!("Região nordeste

3 / 3





Continue

Para continuar, é importante ressaltar que o uso de condições aninhadas em linguagem C é bastante útil em diversos tipos de programas, pois permite que o programador adicione uma camada de decisão a mais em suas aplicações. No exemplo apresentado, o uso de condições aninhadas permitiu que o programa verificasse primeiramente o destino do passageiro, e depois, de acordo com o destino escolhido, verificasse se o trecho incluía somente ida ou ida e volta. Dessa forma, foi possível determinar o preço correto da passagem para cada combinação de destino e trecho. Em Rust, o uso de condições aninhadas é feito de forma semelhante ao C. As condições são verificadas em sequência, começando pela primeira e, caso seja verdadeira, executa o bloco de código correspondente. Caso contrário, passa para a próxima condição. Veja a seguir uma possível solução para o exercício apresentado em linguagem Rust:


fn main() {
    let mut destino = String::new();
    let mut trecho = String::new();
    
    println!("Informe o destino conforme tabela a seguir:");
   

2 / 2





Observe o seguinte Exercício em C #include<stdio.h> 2#include<stdlib.h> 3voidmain(){ 4intdestino,trecho; 5printf("Informeodestinoconformetabelaaseguir:\n"); 6printf("1-RegiaoNorte\t3-RegiaoCentro-oeste\n"); 7printf("2-RegiaoNordeste\t4-RegiaoSul\n"); 8scanf("%d",&destino); 9printf("Informeotrecho:<1-IDAou2-IDAEVOLTA>"); 10scanf("%d",&trecho); 11if(destino==1){ 12if(trecho==1) 13printf("Regiaonorte[IDA]=500,00"); 14else 15printf("Regiaonorte[IDAEVOLTA]=900,00"); 16} 17elseif(destino==2){ 18if(trecho==1) 19printf("Regiaonordeste[IDA]=350,00"); 20else 21printf("Regiaonordeste[IDAEVOLTA]=650,00"); 22} 23elseif(destino==3){ 24if(trecho==1) 25printf("Regiaocentro-oeste[IDA]=350,00"); 26else 27printf("Regiaocentro-oeste[IDAEVOLTA]=600,00"); 28} 29else{ 30if(trecho==1) 31printf("Regiaosul[IDA]=300,00"); 32else 33printf("Regiaosul[IDAEVOLTA]=550,00"); 34} 35} faça em rust 

Para resolver este exercício em Rust, você pode usar a estrutura de decisão if e else if da seguinte forma:


fn main() {
    let destino: i32;
    let trecho: i32;

    println!("Informe o destino conforme tabela a seguir:");
    println!("1-Região Norte\t3-Região Centro-oeste");
    println!("2-Região Nordeste\t4-Região Sul");

    io::stdin().read_line(&mut destino).expect("Falha ao ler o destino");
    destino = destino.trim().parse().expect("Destino inválido");

    println!("Informe o trecho: <1-IDA ou 2-IDA E VOLTA>");
    io::stdin().read_line(&mut trecho).expect("Falha ao ler o trecho");
    trecho = trecho.trim().parse().expect("Trecho inválido");

    if destino == 1 {
        if trecho == 1 {
            println!("Região norte [IDA]=500,00");
        } else {
            println!("Região norte [IDA E VOLTA]=900,00");
        }
    } else if destino == 2 {
        if trecho == 1 {
            println!("Região nordeste [IDA]=350,00");
        } else {
            println!("Região nordeste [IDA E VOLTA]=650




Em c a Cláusula switch Oswitch é um comando com possibilidades mais simplificadas que o if-else, desta forma, permite apenas a comparação de igualdade com variáveis do tipo int, char e long. O switch é vantajoso quando é necessário fazer muitas comparações, pois neste caso, o switch irá oferecer maior agilidade na implementação (LAUREANO, 2005; MIZRAHI,2008). Veja a seguir a sintaxe: 1 //Sintaxe: 2 switch (expressao) { 3 case constante1: 4 5 6 7 8 9 10 11 12 } instrucoes1; break; case constante2: instrucoes2; break; ... default: instrucoes; como fica em rust 

3 / 3


Em Rust, a cláusula match é utilizada para fazer comparações de igualdade com variáveis do tipo int, char, long e outros tipos de dados. A sintaxe da cláusula match é semelhante à cláusula switch em C:


// Sintaxe:
match expressao {
    constante1 => instrucoes1,
    constante2 => instrucoes2,
    ...
    _ => instrucoes
}
Ao contrário da cláusula switch, não é necessário utilizar o comando break para sair da cláusula match após cada caso. Além disso, a cláusula match em Rust permite realizar comparações mais avançadas, incluindo comparações de intervalos, valores de enumeração, estruturas de dados e outros tipos de dados.

Veja a seguir um exemplo de como utilizar a cláusula match em Rust:


fn main() {
    let destino = 2;
    let trecho = 1;

    match destino {
        1 => {
            match trecho {
                1 => println!("Região Norte [IDA]= 500,00"),
                2 => println!("Região Norte [IDA E VOLTA]= 900,00"),
                _ => println!("Trecho inválido"),
            }
       




Veja o seguinte Exercício em C 1 Exercício de Exemplo Escreva umprogramaemlinguagemCqueleiaumpesonaTerraeonúmerodeum planeta e imprima ovalor correspondente do peso neste planeta. A relação de planetas é dadaaseguir juntamente comovalordasgravidades relativas à Terra. CódigoGravidadeRelativaPlaneta 10,37Mercúrio 20,88Vênus 30,38Marte 42,64Júpiter 51,15Saturno 61,17Urano Paracalcularopesonoplanetauseafórmula: PP=PT 10×G(2.1) Emque: •PP=Pesonoplaneta •PT=PesonaTerra •G=Gravidaderelativa Fonte:AdaptadodeLopeseGarcia(2002,p.77)

Para resolver esse exercício em Rust, primeiramente você precisará declarar as variáveis necessárias, que neste caso são o código do planeta, a gravidade relativa do planeta, o peso na Terra e o peso no planeta. Em seguida, você deve ler o código do planeta e o peso na Terra do usuário. Depois disso, você pode utilizar a estrutura de decisão switch para comparar o código do planeta e atribuir o valor da gravidade relativa do planeta de acordo com o código informado pelo usuário. Por fim, você pode calcular o peso no planeta utilizando a fórmula fornecida no exercício e imprimir o resultado.

Segue o código em Rust:


use std::io;

fn main() {
    println!("Informe o código do planeta:");

    let mut codigo = String::new();
    io::stdin().read_line(&mut codigo).expect("Falha ao ler entrada");
    let codigo: i32 = codigo.trim().parse().expect("Por favor, insira um número inteiro válido");

    println!("Informe o peso na Terra:");

    let mut peso_terra = String::new();
    io::stdin().read_line(&mut peso_terra).expect("Falha ao ler entrada");
    let peso_terra: f32 = peso_terra.trim().parse().expect("Por favor, insira um número válido");

    let gravidade_relativa = match codigo {
        10 => 10.37,
        20 => 20.88,
        30 => 30.38,
        42 => 42.64,
        51 => 51.15,
        61 => 61.17,
        _ => 0.0, // caso o código informado não corresponda a nenhum planeta
    };

    let peso_planeta = peso_terra * gravidade_relativa / 10.0;

    println!("O peso no planeta é de {}", peso_planeta);
}




#include<stdio.h> 2#include<stdlib.h> 3 4voidmain() 5{ 6//declaracaodasvariaveis 7floatpesoTerra,pesoPlaneta; 8intnumPlaneta; 9//leituradopesonaterraeescolhadoplaneta 10printf("Informeopesonaterra:\n"); 11scanf("%f",&pesoTerra); 12printf("Informeonumerodoplanetaconformeatabela:\n"); 13printf("1-Mercurio\t2-Venus\t3-Marte\n"); 14printf("4-Jupiter\t5-Saturno\t6-Urano\n"); 15scanf("%d",&numPlaneta); 16 17//switchresponsavelpelaescolhadocalculo 18switch(numPlaneta){ 19case1: 20pesoPlaneta=(pesoTerra/10)*0.37; 21break; 22case2: 23pesoPlaneta=(pesoTerra/10)*0.88; 24break; 25case3: 26pesoPlaneta=(pesoTerra/10)*0.38; 27break; 28case4: 29pesoPlaneta=(pesoTerra/10)*2.64; 30break; 31case5: 32pesoPlaneta=(pesoTerra/10)*1.15; 33break;case6: 35pesoPlaneta=(pesoTerra/10)*1.17; 36break; 37default: 38printf("Planetainvalido!\n"); 39} 40//impressaodopesonoplanetaescolhido 41printf("Pesonoplanetaescolhido:%f\n",pesoPlaneta); 42} faça em rust 

Para fazer o mesmo código em Rust, basta fazer as seguintes mudanças:

Remover os includes, pois em Rust não é preciso incluir bibliotecas.
Trocar o nome da função main() para main().
Trocar os tipos de variável float para f32 e int para i32.
Trocar o scanf() pelo método read_line() da struct stdin.
Trocar o printf() pelo método print() e println() da struct stdout.
O código ficaria assim:


fn main() {
    // declaração das variáveis
    let mut peso_terra: f32 = 0.0;
    let mut peso_planeta: f32 = 0.0;
    let mut num_planeta: i32 = 0;

    // leitura do peso na terra e escolha do planeta
    println!("Informe o peso na terra:");
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();
    peso_terra = input.trim().parse().unwrap();

    println!("Informe o número do planeta conforme a tabela:");
    println!("1-Mercúrio\t2-Vênus\t3-Marte");
    println!("4-Júpiter\t5-Saturno\t6-Urano");
    input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();
    num_planeta = input.trim().parse().unwrap();

    // switch responsável pela escolha do cálculo
    match num_planeta {
        1 => peso_planeta = (peso_terra / 10.




Me dê um resumo do que foi conversado até agora

Até agora, conversamos sobre a estrutura de decisão if-else em C e Rust. Vimos que é possível utilizar a estrutura if-else para tomar decisões com base em uma condição, utilizando operadores lógicos e relacionais. Também foi mencionado o uso de condições aninhadas e a estrutura switch para fazer comparações de igualdade em variáveis do tipo int, char e long. Alguns exemplos de exercícios foram apresentados para exemplificar o uso destas estruturas de decisão em ambas as linguagens.



Regenerate response

ChatGPT Dec 15 Version. Free Research Preview. Our goal is to make AI systems more natural and safe to interact with. Your feedback will help us improve.
"
 https://chat.openai.com/chat#:~:text=Open%20sidebar,help%20us%20improve.





O padrão de codificação em Rust é definido pelo livro "The Rust Programming Language" e é usado como guia para a comunidade Rust. Ele estabelece regras para a formatação do código, nomenclatura de variáveis e funções, estrutura de projetos, entre outros aspectos.
Aqui estão alguns dos principais aspectos do padrão de codificação em Rust:
Formatação do código: o código deve ser formatado de acordo com o estilo "Cargo" do Rustfmt. Isso inclui usar 4 espaços como indentação, limitar o tamanho das linhas em 100 caracteres, usar chaves em todas as declarações de bloco, entre outras regras.
Nomenclatura de variáveis e funções: as variáveis e funções devem ter nomes claros e descritivos, usando camelCase. Os nomes devem ser escritos em inglês. As variáveis e funções devem ser nombradas de acordo com seu propósito e tipo. Por exemplo, uma variável que armazena um número inteiro pode ser chamada de numero_inteiro, enquanto uma função que calcula a média de um conjunto de números pode ser chamada de calcular_media.
Estrutura de projetos: os projetos devem ter uma estrutura clara e organizada, com cada módulo (arquivo .rs) responsável por uma tarefa específica. Os módulos devem ser organizados em pastas de acordo com seu propósito. Por exemplo, os módulos relacionados ao banco de dados podem ser colocados em uma pasta chamada banco_de_dados, enquanto os módulos relacionados ao processamento de dados podem ser colocados em uma pasta chamada processamento_de_dados.
O padrão de codificação em Rust é um guia importante para ajudar a manter o código legível, fácil de entender e consistente. Ele também ajuda a promover a colaboração eficiente entre os desenvolvedores.


*****************************************************

Em programação, o termo "cast" se refere ao processo de converter um valor de um tipo de dados para outro. Isso é comumente chamado de "fazer cast" ou "converter tipos".

Existem várias razões para se fazer cast em uma linguagem de programação. Algumas das mais comuns são:

Converter um valor de um tipo numérico para outro (por exemplo, de inteiro para ponto flutuante ou vice-versa).
Converter um valor de um tipo de referência para um tipo de ponteiro (ou vice-versa).
Converter um valor de um tipo de dados complexo para um tipo mais simples (por exemplo, um objeto para uma string).
O processo de fazer cast pode ser feito de diferentes maneiras, dependendo da linguagem de programação. Algumas linguagens possuem operadores específicos para fazer cast, como o operador as em Rust ou o operador (T) em Rust e C++. Outras linguagens possuem funções ou métodos pré-definidos para fazer cast, como o método to_i32 em Ruby ou a função int em Python.

É importante lembrar que fazer cast pode ser arriscado, pois o valor pode não ser compatível com o tipo para o qual está sendo convertido. Isso pode levar a erros em tempo de execução ou resultados incorretos. Por isso, é importante tomar cuidado ao fazer cast e garantir que o valor é válido para o tipo para o qual está sendo convertido.

O operador as é usado em Rust para fazer cast de um tipo de dados para outro. Isso é útil quando você tem um valor em um tipo específico, mas precisa usá-lo como um tipo diferente.

Por exemplo, você pode usar o operador as para converter um valor de u32 para i32, que é um tipo de inteiro de sinalizado com 32 bits:


let x: u32 = 5;
let y: i32 = x as i32;
O operador as também pode ser usado para fazer cast de um tipo de ponto flutuante para um tipo de inteiro. Neste caso, o valor será truncado (isto é, arredondado para baixo) para o tipo de inteiro mais próximo:


let x: f32 = 3.14;
let y: i32 = x as i32; // y é 3

É importante observar que o operador as só pode ser usado para fazer cast entre tipos que são compatíveis. Se você tentar fazer cast de um tipo para outro que não é compatível, o código não compilará. Além disso, o operador as pode falhar em tempo de execução se o valor não puder ser convertido para o tipo desejado. Por isso, é importante ter cuidado ao usar o operador as.

******************************************************













Clayton V. Fraga Filho
extensao de arquivo codigo-fonte rust
O arquivo de código-fonte em Rust geralmente tem a extensão ".rs". Por exemplo, um arquivo de código-fonte em Rust chamado "main.rs" conteria o código fonte principal do programa escrito em Rust.

Em geral, o código em Rust é escrito em arquivos com a extensão ".rs" e pode ser compilado usando o compilador Rust, chamado "rustc". Você pode usar o comando "rustc" seguido pelo nome do arquivo de código-fonte para compilar o código em Rust. Por exemplo, para compilar o arquivo "main.rs", você pode usar o comando:


rustc main.rs
Isso criará um executável chamado "main" que pode ser executado para rodar o seu programa em Rust.

Além da extensão ".rs", os arquivos em Rust também podem ter outras extensões, como ".rlib" para bibliotecas estáticas ou ".rmeta" para metadados associados ao arquivo de código-fonte.




Clayton V. Fraga Filho
Faça em Rust:

Faça um programa em Rust que leia dois valores numéricos inteiros e efetue a adição,
caso o resultado seja maior que 10, apresentá-lo.
Aqui está um exemplo de como você poderia escrever esse programa em Rust:


use std::io;


fn main() {
   println!("Digite o primeiro valor:");


   let mut numero1 = String::new();
   io::stdin().read_line(&mut numero1).expect("Falha ao ler a entrada");


   println!("Digite o segundo valor:");


   let mut numero2 = String::new();
   io::stdin().read_line(&mut numero2).expect("Falha ao ler a entrada");


   let numero1: i32 = numero1.trim().parse().expect("Por favor, digite um número inteiro válido");
   let numero2: i32 = numero2.trim().parse().expect("Por favor, digite um número inteiro válido");


   let resultado = numero1 + numero2;
   if resultado > 10 {
       println!("O resultado é: {}", resultado);
   }
}


O código acima lê dois valores inteiros do usuário, adiciona-os e, se o resultado for maior que 10, imprime o resultado.

Para ler a entrada do usuário, o código usa a função read_line da biblioteca padrão de entrada/saída (I/O). O valor lido é armazenado em uma variável String e, em seguida, é convertido em um i32 (um tipo de número inteiro de 32 bits) usando o método parse.

O código também verifica se houve algum erro ao ler a entrada ou converter para um número inteiro usando a sintaxe de "unwrapping" de resultados. Se houver algum erro, a função expect exibirá uma mensagem de erro.

Finalmente, o código verifica se o resultado da adição é maior que 10 e, se for, imprime o resultado.




Clayton V. Fraga Filho
Faça em Rust:

Faça um programa em Rust que leia dois valores inteiros e efetue a adição. Caso o
valor somado seja maior que 20, este deverá ser apresentado somando-se a ele
mais 8, caso o valor somado seja menor ou igual a 20, este deverá ser apresentado
subtraindo-se 5.
Aqui está como você poderia escrever esse programa em Rust:


use std::io;

fn main() {
    println!("Digite o primeiro valor:");

    let mut num1 = String::new();
    io::stdin().read_line(&mut num1).expect("Falha ao ler a entrada");

    println!("Digite o segundo valor:");

    let mut num2 = String::new();
    io::stdin().read_line(&mut num2).expect("Falha ao ler a entrada");

    let num1: i32 = num1.trim().parse().expect("Por favor, digite um número inteiro válido");
    let num2: i32 = num2.trim().parse().expect("Por favor, digite um número inteiro válido");

    let resultado = num1 + num2;
    if resultado > 20 {
        println!("O resultado é: {}", resultado + 8);
    } else {
        println!("O resultado é: {}", resultado - 5);
    }
}
O código acima lê dois valores inteiros do usuário, adiciona-os e, em seguida, verifica se o resultado é maior que 20. Se for, o resultado é impresso acrescido de 8. Caso contrário, o resultado é impresso subtraindo-se 5.

O resto do código é semelhante ao exemplo anterior de leitura de entrada e conversão para um número inteiro.




Clayton V. Fraga Filho
Faça em Rust

Faça um programa que leia um número e imprima uma das duas mensagens: "É
múltiplo de 3"ou "Não é múltiplo de 3".
Aqui está como você poderia escrever esse programa em Rust:


use std::io;

fn main() {
    println!("Digite um número:");

    let mut num = String::new();
    io::stdin().read_line(&mut num).expect("Falha ao ler a entrada");

    let num: i32 = num.trim().parse().expect("Por favor, digite um número inteiro válido");

    if num % 3 == 0 {
        println!("É múltiplo de 3");
    } else {
        println!("Não é múltiplo de 3");
    }
}
O código acima lê um valor inteiro do usuário e, em seguida, verifica se ele é múltiplo de 3 usando o operador de módulo (%). Se o resto da divisão do número por 3 for zero, o número é um múltiplo de 3 e a mensagem "É múltiplo de 3" é impressa. Caso contrário, a mensagem "Não é múltiplo de 3" é impressa.

O resto do código é semelhante ao exemplo anterior de leitura de entrada e conversão para um número inteiro.




Clayton V. Fraga Filho
Faça em RUST

Faça um programa que leia um número e informe se ele é ou não divisível por 5.
Aqui está como você poderia escrever esse programa em Rust:


use std::io;

fn main() {
    println!("Digite um número:");

    let mut num = String::new();
    io::stdin().read_line(&mut num).expect("Falha ao ler a entrada");

    let num: i32 = num.trim().parse().expect("Por favor, digite um número inteiro válido");

    if num % 5 == 0 {
        println!("O número é divisível por 5");
    } else {
        println!("O número não é divisível por 5");
    }
}
O código acima lê um valor inteiro do usuário e, em seguida, verifica se ele é divisível por 5 usando o operador de módulo (%). Se o resto da divisão do número por 5 for zero, o número é divisível por 5 e a mensagem "O número é divisível por 5" é impressa. Caso contrário, a mensagem "O número não é divisível por 5" é impressa.

O resto do código é semelhante ao exemplo anterior de leitura de entrada e conversão para um número inteiro.




Clayton V. Fraga Filho
Faça em rust:

Faça um programa em Rust que leia um número e informe se ele é divisível por 3 e
por 7.
Aqui está como você poderia escrever esse programa em Rust:


use std::io;

fn main() {
    println!("Digite um número:");

    let mut num = String::new();
    io::stdin().read_line(&mut num).expect("Falha ao ler a entrada");

    let num: i32 = num.trim().parse().expect("Por favor, digite um número inteiro válido");

    if num % 3 == 0 && num % 7 == 0 {
        println!("O número é divisível por 3 e por 7");
    } else {
        println!("O número não é divisível por 3 e por 7");
    }
}
O código acima lê um valor inteiro do usuário e, em seguida, verifica se ele é divisível por 3 e por 7 usando o operador de módulo (%). Se o resto da divisão do número por 3 e por 7 for zero, o número é divisível por 3 e por 7 e a mensagem "O número é divisível por 3 e por 7" é impressa. Caso contrário, a mensagem "O número não é divisível por 3 e por 7" é impressa.

O resto do código é semelhante ao exemplo anterior de leitura de entrada e conversão para um número inteiro.




Clayton V. Fraga Filho
Faça em Rust

A prefeitura do Rio de Janeiro abriu uma linha de crédito para os funcionários
estatutários. O valor máximo da prestação não poderá ultrapassar 30% do salário
bruto. Faça um programa em linguagem Rust que permita entrar com o salário bruto
e o valor da prestação e informar se o empréstimo pode ou não ser concedido.
Aqui está como você poderia escrever esse programa em Rust:


use std::io;

fn main() {
    println!("Digite o salário bruto:");

    let mut salario_bruto = String::new();
    io::stdin().read_line(&mut salario_bruto).expect("Falha ao ler a entrada");

    println!("Digite o valor da prestação:");

    let mut prestacao = String::new();
    io::stdin().read_line(&mut prestacao).expect("Falha ao ler a entrada");

    let salario_bruto: f32 = salario_bruto.trim().parse().expect("Por favor, digite um número válido");
    let prestacao: f32 = prestacao.trim().parse().expect("Por favor, digite um número válido");

    if prestacao / salario_bruto <= 0.3 {
        println!("O empréstimo pode ser concedido");
    } else {
        println!("O empréstimo não pode ser concedido");
    }
}
O código acima lê o salário bruto e o valor da prestação do usuário e, em seguida, verifica se o valor da prestação é menor ou igual a 30% do salário bruto. Se for, a mensagem "O empréstimo pode ser concedido" é impressa. Caso contrário, a mensagem "O empréstimo não pode ser concedido" é impressa.

O resto do código é semelhante ao exemplo anterior de leitura de entrada e conversão para um número. No entanto, neste caso, os valores são convertidos para o tipo f32 (um tipo de ponto flutuante de precisão simples) em vez de i32 (um tipo de número inteiro). Isso é necessário porque os valores de salário e prestação podem ser decimais.




Clayton V. Fraga Filho
faça um programa em rust

Faça um programa em Rust que leia um número e indique se o número está compre-
endido entre 20 e 50 ou não.
Aqui está como você poderia escrever esse programa em Rust:


use std::io;

fn main() {
    println!("Digite um número:");

    let mut num = String::new();
    io::stdin().read_line(&mut num).expect("Falha ao ler a entrada");

    let num: i32 = num.trim().parse().expect("Por favor, digite um número inteiro válido");

    if num >= 20 && num <= 50 {
        println!("O número está compreendido entre 20 e 50");
    } else {
        println!("O número não está compreendido entre 20 e 50");
    }
}
O código acima lê um valor inteiro do usuário e, em seguida, verifica se ele está compreendido entre 20 e 50 usando os operadores de comparação >= (maior ou igual a) e <= (menor ou igual a). Se o número estiver compreendido nesse intervalo, a mensagem "O número está compreendido entre 20 e 50" é impressa. Caso contrário, a mensagem "O número não está compreendido entre 20 e 50" é impressa.

O resto do código é semelhante ao exemplo anterior de leitura de entrada e conversão para um número inteiro.

Clayton V. Fraga Filho
faça os exercicios abaixo em Rust


Faça um programa que leia um número e imprima uma das mensagens: "Maior
do que 20", "Igual a 20"ou "Menor do que 20".
9. Faça um programa em Rust que permita entrar com o ano de nascimento da pessoa
e com o ano atual. O programa deve imprimir a idade da pessoa. Não se esqueça
de verificar se o ano de nascimento informado é válido.
Exercício 1:


fn main() {
    println!("Insira um número:");

    let mut num = String::new();
    std::io::stdin().read_line(&mut num).expect("Falha ao ler a entrada");

    let num: i32 = num.trim().parse().expect("Por favor, insira um número válido");

    if num > 20 {
        println!("Maior do que 20");
    } else if num == 20 {
        println!("Igual a 20");
    } else {
        println!("Menor do que 20");
    }
}
Exercício 2:


fn main() {
    println!("Insira o ano de nascimento:");

    let mut ano_nascimento = String::new();
    std::io::stdin().read_line(&mut ano_nascimento).expect("Falha ao ler a entrada");

    let ano_nascimento: i32 = ano_nascimento.trim().parse().expect("Por favor, insira um ano de nascimento válido");

    println!("Insira o ano atual:");

    let mut ano_atual = String::new();
    std::io::stdin().read_line(&mut ano_atual).expect("Falha ao ler a entrada");

    let ano_atual: i32 = ano_atual.trim().parse().expect("Por favor, insira um ano atual válido");

    if ano_nascimento > ano_atual {
        println!("Ano de nascimento inválido");
    } else {
        let idade = ano_atual - ano_nascimento;
        println!("A idade da pessoa é: {}", idade);
    }
}

10. Faça um programa em Rust que leia três números inteiros e imprima os três em
ordem Rustrescente.
fn main() {
let mut num1 = 0;
let mut num2 = 0;
let mut num3 = 0;


println!("Insira o primeiro número: ");
std::io::stdin().read_line(&mut num1).expect("Falha ao ler a entrada");
num1 = num1.trim().parse().expect("Entrada inválida");

println!("Insira o segundo número: ");
std::io::stdin().read_line(&mut num2).expect("Falha ao ler a entrada");
num2 = num2.trim().parse().expect("Entrada inválida");

println!("Insira o terceiro número: ");
std::io::stdin().read_line(&mut num3).expect("Falha ao ler a entrada");
num3 = num3.trim().parse().expect("Entrada inválida");

if num1 > num2 {
    std::mem::swap(&mut num1, &mut num2);
}
if num2 > num3 {
    std::mem::swap(&mut num2, &mut num3);
}
if num1 > num2 {
    std::mem::swap(&mut num1, &mut num2);
}

println!("Números em ordem Rustrescente: {} {} {}", num1, num2, num3);
}




Clayton V. Fraga Filho
Faça em Rust:

11. Faça um programa que leia 3 números e imprima o maior deles.
fn main() {
let mut num1 = 0;
let mut num2 = 0;
let mut num3 = 0;


println!("Insira o primeiro número: ");
std::io::stdin().read_line(&mut num1).expect("Falha ao ler a entrada");
num1 = num1.trim().parse().expect("Entrada inválida");

println!("Insira o segundo número: ");
std::io::stdin().read_line(&mut num2).expect("Falha ao ler a entrada");
num2 = num2.trim().parse().expect("Entrada inválida");

println!("Insira o terceiro número: ");
std::io::stdin().read_line(&mut num3).expect("Falha ao ler a entrada");
num3 = num3.trim().parse().expect("Entrada inválida");

let mut maior = num1;
if num2 > maior {
    maior = num2;
}
if num3 > maior {
    maior = num3;
}

println!("O maior número é: {}", maior);

12. Faça um programa que leia a idade de uma pessoa e informe:
• Se é maior de idade
• Se é menor de idade
• Se é maior de 65 anos
Aqui está como você poderia fazer isso em Rust:


fn main() {
    // Ler a idade da pessoa
    println!("Insira sua idade: ");
    let mut idade = String::new();
    std::io::stdin().read_line(&mut idade).expect("Falha ao ler a linha");

    // Convertemos a idade de String para u32
    let idade: u32 = idade.trim().parse().expect("Por favor, digite um número válido");

    // Verificamos se a pessoa é maior de idade
    if idade >= 18 {
        println!("Você é maior de idade.");
    } else {
        println!("Você é menor de idade.");
    }

    // Verificamos se a pessoa é maior de 65 anos
    if idade >= 65 {
        println!("Você é maior de 65 anos.");
    }
}


Clayton V. Fraga Filho
faça em Rust

13. Faça um programa que permita entrar com o nome, a nota da prova 1 e a nota da
prova 2 de um aluno. O programa deve imprimir o nome, a nota da prova 1, a nota
da prova 2, a média das notas e uma das mensagens: "Aprovado", "Reprovado"ou
"em Prova Final"(a média é 7 para aprovação, menor que 3 para reprovação e as
demais em prova final).
Aqui está um exemplo de como você poderia escrever este programa em Rust:


fn main() {
    println!("Insira o nome do aluno:");

    let mut nome = String::new();
    std::io::stdin().read_line(&mut nome).expect("Falha ao ler o nome do aluno");

    println!("Insira a nota da prova 1:");

    let mut nota1_input = String::new();
    std::io::stdin().read_line(&mut nota1_input).expect("Falha ao ler a nota da prova 1");
    let nota1: f32 = nota1_input.trim().parse().expect("Por favor, insira uma nota válida");

    println!("Insira a nota da prova 2:");

    let mut nota2_input = String::new();
    std::io::stdin().read_line(&mut nota2_input).expect("Falha ao ler a nota da prova 2");
    let nota2: f32 = nota2_input.trim().parse().expect("Por favor, insira uma nota válida");

    let media = (nota1 + nota2) / 2.0;

    println!("Nome: {}", nome);
    println!("Nota da prova 1: {}", nota1);
    println!("Nota da prova 2: {}", nota2);
    println!("Média: {}", media);

    if media >= 7.0 {
        println!("Aprovado");
    } else if media < 3.0 {
        println!("Reprovado");
    } else {
        println!("em Prova Final");
    }
}
Este programa começa solicitando que o usuário insira o nome do aluno e lendo a entrada do usuário com std::io::stdin().read_line(&mut nome). Em seguida, ele faz o mesmo para as duas notas da prova, convertendo-as para o tipo f32 (que representa números de ponto flutuante de precisão simples). Depois de calcular a média das notas, o programa imprime o nome do aluno, as notas da prova 1 e 2 e a média. Finalmente, o programa verifica a média e imprime a mensagem apropriada.




Regenerate response

ChatGPT Dec 15 Version. Free Research Preview. Our goal is to make AI systems more natural and safe to interact with. Your feedback will help us improve.
New chat
Rust - Programa Média Aluno


Rust - verificar idade
Faça em Rust desconto INSS
Exercícios em Rust
Exercícios em Rust
Extensão de arquivo Rust
About Rust Programming Language
Clear conversations
Dark mode
OpenAI Discord
Updates & FAQ
Log out
Clayton V. Fraga Filho
faça em rust

Faça um programa que permita entrar com o salário de uma pessoa e imprima o
desconto do INSS segundo a tabela seguir:

Salário
Menor ou igual à R$600,00
Maior que R$600,00 e menor ou igual a R$1200,00
Maior que R$1200,00 e menor ou igual a R$2000,00
Maior que R$2000,00
Faixa de Desconto
Isento
20%
25%
30%
Aqui está um exemplo de como o programa poderia ser implementado em Rust:


fn main() {
    println!("Informe o salário: ");

    let mut salario = String::new();
    std::io::stdin().read_line(&mut salario).expect("Falha ao ler entrada");

    let salario: f32 = salario.trim().parse().expect("Por favor, informe um número válido");
    let desconto = calcular_desconto(salario);

    println!("O desconto do INSS é de: {:.2}%", desconto);
}

fn calcular_desconto(salario: f32) -> f32 {
    if salario <= 600.0 {
        return 0.0;
    } else if salario <= 1200.0 {
        return 20.0;
    } else if salario <= 2000.0 {
        return 25.0;
    } else {
        return 30.0;
    }
}
Espero que isso ajude!



Regenerate response

ChatGPT Dec 15 Version. Free Research Preview. Our goal is to make AI systems more natural and safe to interact with. Your feedback will help us improve.
New chat
New chat
New chat
Programa INSS Rust


Rust - Programa Média Aluno
Rust - verificar idade
Faça em Rust desconto INSS
Exercícios em Rust
Exercícios em Rust
Extensão de arquivo Rust
About Rust Programming Language
Clear conversations
Dark mode
OpenAI Discord
Updates & FAQ
Log out





====================================================
Um comerciante comprou um produto e quer vendê-lo com um lucro de 45% se
o valor da compra for menor que R$20,00, caso contrário, o lucro será de 30%.
Faça um programa em Rust que leia o valor do produto e imprima o valor da venda.
Aqui está um exemplo de como você poderia escrever esse programa em Rust:


fn main() {
    // Lê o valor do produto
    println!("Insira o valor do produto:");
    let mut valor_produto = String::new();
    std::io::stdin().read_line(&mut valor_produto).expect("Falha ao ler entrada");

    // Converte o valor do produto em um número flutuante (f64)
    let valor_produto: f64 = valor_produto.trim().parse().expect("Por favor, insira um número válido");

    // Calcula o lucro
    let lucro: f64 = if valor_produto < 20.0 {
        valor_produto * 0.45
    } else {
        valor_produto * 0.3
    };

    // Calcula o valor de venda
    let valor_venda = valor_produto + lucro;

    // Imprime o valor de venda
    println!("Valor de venda: R$ {:.2}", valor_venda);
}
Este código faz as seguintes coisas:

Lê o valor do produto como uma string da entrada padrão (o teclado).
Converte o valor do produto em um número flutuante (f64).
Calcula o lucro com base no valor do produto, usando uma expressão if condicional.
Calcula o valor de venda adicionando o lucro ao valor do produto.
Imprime o valor de venda com duas casas decimais.

====================================================
Clayton V. Fraga Filho
faça em rust
16. A confederação brasileira de natação irá promover eliminatórias para o próximo
mundial. Faça um programa em Rust que receba a idade de um nadador e imprima
a sua categoria segundo a tabela a seguir:
Categoria
Infantil A
Infantil B
Juvenil A
Juvenil B
Sênior
Idade
5 - 7 anos
8 - 10 anos
11 - 13 anos
14 - 17 anos
maiores de 18 anos
Aqui está um exemplo de como você poderia escrever esse programa em Rust:


fn main() {
    println!("Insira a idade do nadador: ");

    // Lê a idade do nadador como uma string
    let mut age = String::new();
    std::io::stdin().read_line(&mut age).expect("Falha ao ler entrada");

    // Converte a idade para um inteiro
    let age: i32 = age.trim().parse().expect("Por favor, insira um número inteiro válido");

    // Verifica a categoria do nadador
    if age >= 5 && age <= 7 {
        println!("Categoria: Infantil A");
    } else if age >= 8 && age <= 10 {
        println!("Categoria: Infantil B");
    } else if age >= 11 && age <= 13 {
        println!("Categoria: Juvenil A");
    } else if age >= 14 && age <= 17 {
        println!("Categoria: Juvenil B");
    } else if age >= 18 {
        println!("Categoria: Sênior");
    } else {
        println!("Idade inválida para competição");
    }
}
Espero que isso ajude!



Regenerate response

ChatGPT Dec 15 Version. Free Research Preview. Our goal is to make AI systems more natural and safe to interact with. Your feedback will help us improve.
New chat
New chat
Programa em Rust para categorias de natação


Programa em Rust para calcular valor de venda
Programa INSS Rust
Rust - Programa Média Aluno
Rust - verificar idade
Faça em Rust desconto INSS
Exercícios em Rust
Exercícios em Rust
Extensão de arquivo Rust
About Rust Programming Language
Clear conversations
Dark mode
OpenAI Discord
Updates & FAQ
Log out
====================================================
Clayton V. Fraga Filho
Faça em Rust:

Depois da liberação do governo para as mensalidades dos planos de saúde, as
pessoas começaram a fazer pesquisas para descobrir um bom plano, não muito
caro. Um vendedor de um plano de saúde apresentou a tabela a seguir. Faça um
programa que entre com o nome e a idade de uma pessoa e imprima o nome e o
valor que ela deverá pagar.
Idade
Até 10 anos
Acima de 10 até 29 anos
Acima de 29 até 45 anos
Acima de 45 até 59 anos
Acima de 59 até 65 anos
Maior que 65 anos
Valor
R$30,00
R$60,00
R$120,00
R$150,00
R$250,00
R$400,00
Aqui está uma solução em Rust:


fn main() {
    // Entrada dos dados
    println!("Insira o nome e a idade da pessoa:");
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();
    let mut iter = input.split_whitespace();
    let nome = iter.next().unwrap();
    let idade: i32 = iter.next().unwrap().parse().unwrap();

    // Cálculo do valor a pagar
    let valor: f64 = match idade {
        age if age <= 10 => 30.0,
        age if age <= 29 => 60.0,
        age if age <= 45 => 120.0,
        age if age <= 59 => 150.0,
        age if age <= 65 => 250.0,
        _ => 400.0,
    };

    // Saída dos resultados
    println!("Nome: {}", nome);
    println!("Valor a pagar: R$ {:.2}", valor);
}
Espero que isso ajude!



Regenerate response

ChatGPT Dec 15 Version. Free Research Preview. Our goal is to make AI systems more natural and safe to interact with. Your feedback will help us improve.
New chat
Programa em Rust para planos de saúde


Programa em Rust para categorias de natação
Programa em Rust para calcular valor de venda
Programa INSS Rust
Rust - Programa Média Aluno
Rust - verificar idade
Faça em Rust desconto INSS
Exercícios em Rust
Exercícios em Rust
Extensão de arquivo Rust
About Rust Programming Language
Clear conversations
Dark mode
OpenAI Discord
Updates & FAQ
Log out
====================================================
18. Faça um programa que leia um número inteiro entre 1 e 12 e escreva o mês
correspondente. Caso o usuário digite um número fora desse intervalo, deverá
aparecer uma mensagem informando que não existe mês com este número.
Utilize o switch para este problema.
Aqui está uma solução em Rust:


fn main() {
    let mut numero = String::new();

    println!("Digite um número inteiro entre 1 e 12:");

    std::io::stdin().read_line(&mut numero).expect("Falha ao ler a entrada");

    let numero: u32 = match numero.trim().parse() {
        Ok(num) => num,
        Err(_) => {
            println!("Você não digitou um número inteiro válido.");
            return;
        }
    };

    let mes = match numero {
        1 => "janeiro",
        2 => "fevereiro",
        3 => "março",
        4 => "abril",
        5 => "maio",
        6 => "junho",
        7 => "julho",
        8 => "agosto",
        9 => "setembro",
        10 => "outubro",
        11 => "novembro",
        12 => "dezembro",
        _ => {
            println!("Não existe mês com o número {}.", numero);
            return;
        }
    };

    println!("O mês correspondente é {}.", mes);
}
A primeira coisa que este programa faz é ler uma entrada do usuário como uma string. Em seguida, usamos a função parse() para tentar converter essa string em um número inteiro. Se a conversão for bem-sucedida, o número é armazenado na variável numero. Caso contrário, exibimos uma mensagem de erro e terminamos o programa.

Em seguida, usamos um match para comparar o valor de numero com diferentes casos. Se o valor corresponder a um dos casos entre 1 e 12, exibimos o nome do mês correspondente. Caso contrário, exibimos uma mensagem de erro e terminamos o programa.


====================================================
19. Em um campeonato nacional de arco-e-flecha, tem-se equipes de três jogadores
para cada estado. Sabendo-se que os arqueiros de uma equipe não obtiveram o
mesmo número de pontos, criar um programa em Rust que informe se uma equipe
foi classificada, de acordo com a seguinte especificação:
• Ler os pontos obtidos por cada jogador da equipe;
• Mostrar esses valores em ordem decrescente;
• Se a soma dos pontos for maior do que 100, imprimir a média aritmética
entre eles, caso contrário, imprimir a mensagem "Equipe desclassificada".
Aqui está como fazer isso em Rust:


fn main() {
    // Ler os pontos obtidos por cada jogador da equipe
    println!("Insira os pontos do primeiro jogador:");
    let mut points1 = String::new();
    std::io::stdin().read_line(&mut points1).expect("Falha ao ler a entrada");
    let points1: u32 = points1.trim().parse().expect("Por favor, insira um número inteiro positivo");

    println!("Insira os pontos do segundo jogador:");
    let mut points2 = String::new();
    std::io::stdin().read_line(&mut points2).expect("Falha ao ler a entrada");
    let points2: u32 = points2.trim().parse().expect("Por favor, insira um número inteiro positivo");

    println!("Insira os pontos do terceiro jogador:");
    let mut points3 = String::new();
    std::io::stdin().read_line(&mut points3).expect("Falha ao ler a entrada");
    let points3: u32 = points3.trim().parse().expect("Por favor, insira um número inteiro positivo");

    // Mostrar esses valores em ordem decrescente
    let mut points = vec![points1, points2, points3];
    points.sort_by(|a, b| b.cmp(a));
    println!("Pontos em ordem decrescente: {:?}", points);

    // Se a soma dos pontos for maior do que 100, imprimir a média aritmética
    let total_points = points1 + points2 + points3;
    if total_points > 100 {
        let average = total_points as f32 / 3.0;
        println!("Média aritmética dos pontos: {}", average);
    } else {
        println!("Equipe desclassificada");
    }
}




====================================================

20. O banco XXX concederá um crédito especial com juros de 2% aos seus clientes
de acordo com o saldo médio no último ano. Faça um programa que leia o saldo
médio de um cliente e calcule o valor do crédito de acordo com a tabela a seguir.
O programa deve imprimir uma mensagem informando o saldo médio e o valor
de crédito.
Saldo Médio
de 0 a 500
de 501 a 1000
de 1001 a 3000
acima de 3001
Percentual
nenhum crédito
30% do valor do saldo médio
40% do valor do saldo médio
50% do valor do saldo médio
Aqui está um exemplo de como você poderia escrever esse programa em Rust:


fn main() {
    // Lê o saldo médio do usuário
    println!("Insira o saldo médio: ");
    let mut saldo = String::new();
    std::io::stdin().read_line(&mut saldo).expect("Falha ao ler entrada");

    // Converte o saldo médio em um número inteiro
    let saldo: i32 = saldo.trim().parse().expect("Por favor, insira um número válido");

    // Calcula o valor do crédito de acordo com a tabela
    let mut credito = 0;
    if saldo <= 500 {
        credito = 0;
    } else if saldo <= 1000 {
        credito = saldo * 30 / 100;
    } else if saldo <= 3000 {
        credito = saldo * 40 / 100;
    } else {
        credito = saldo * 50 / 100;
    }

    // Imprime o saldo médio e o valor do crédito
    println!("Saldo médio: {}", saldo);
    println!("Valor do crédito: {}", credito);
}
Espero que isso ajude!

====================================================

faça em rust:

21. A biblioteca de uma Universidade deseja fazer um programa que leia o nome do
livro que será emprestado, o tipo de usuário (professor ou aluno) e possa imprimir
um recibo conforme mostrado a seguir. Considerar que o professor tem dez dias
para devolver o livro e o aluno só três dias.
• Nome do livro:
• Tipo de usuário:
• Total de dias:
Aqui está um exemplo de como você poderia escrever este programa em Rust:


use std::io;

fn main() {
    println!("Nome do livro:");
    let mut book_name = String::new();
    io::stdin().read_line(&mut book_name).expect("Falha ao ler o nome do livro");

    println!("Tipo de usuário (professor ou aluno):");
    let mut user_type = String::new();
    io::stdin().read_line(&mut user_type).expect("Falha ao ler o tipo de usuário");

    let total_days = if user_type.trim().to_lowercase() == "professor" {
        10
    } else {
        3
    };

    println!("Recibo:");
    println!("Nome do livro: {}", book_name.trim());
    println!("Tipo de usuário: {}", user_type.trim());
    println!("Total de dias: {}", total_days);
}
Este código lê o nome do livro e o tipo de usuário do usuário, usando a função read_line da biblioteca std::io. Em seguida, ele determina o número total de dias para devolução do livro com base no tipo de usuário. Por fim, ele imprime o recibo com o nome do livro, o tipo de usuário e o número total de dias para devolução.

==============================================================
22. Construa um programa que leia o percurso em quilómetros, o tipo do carro e
informe o consumo estimado de combustível, sabendo-se que um carro tipo C
faz 12 km com um litro de gasolina, um tipo B faz 9 km e o tipo C, 8 km por litro.
Para construir um programa em Rust que leia o percurso em quilômetros, o tipo do carro e informe o consumo estimado de combustível, você pode usar a estrutura de decisão match para verificar o tipo do carro e calcular o consumo estimado de combustível de acordo com a informação fornecida.

Aqui está um exemplo de como você poderia implementar esse programa em Rust:


fn main() {
    // Lê o percurso em quilómetros e o tipo do carro
    println!("Insira o percurso em quilómetros:");
    let mut distance = String::new();
    std::io::stdin().read_line(&mut distance).expect("Falha ao ler a entrada");
    let distance: f64 = distance.trim().parse().expect("Por favor, insira um número válido");

    println!("Insira o tipo do carro (C, B ou A):");
    let mut car_type = String::new();
    std::io::stdin().read_line(&mut car_type).expect("Falha ao ler a entrada");
    let car_type = car_type.trim();

    // Calcula o consumo estimado de combustível de acordo com o tipo do carro
    let consumption = match car_type {
        "C" => distance / 12.0,
        "B" => distance / 9.0,
        "A" => distance / 8.0,
        _ => {
            println!("Tipo de carro inválido");
            return;
        }
    };

    println!("O consumo estimado de combustível é de {} litros.", consumption);
}
Nesse exemplo, primeiro nós lemos o percurso em quilómetros e o tipo do carro a partir da entrada do usuário. Em seguida, usamos a estrutura de decisão match para verificar o tipo do carro e calcular o consumo estimado de combustível de acordo com a informação fornecida. Se o tipo do carro for inválido (ou seja, não for "C", "B" ou "A"), o programa exibe uma mensagem de erro e encerra.

==============================================================
23. Crie um programa que informe a quantidade total de calorias de uma refeição a
partir da escolha do usuário que deverá informar o prato, a sobremesa, e bebida
conforme a tabela a seguir.
Prato
Vegetariano 180cal
Peixe 230cal
Frango 250cal
Carne 350cal
Sobremesa
Abacaxi 75cal
Sorvete diet 110cal
Mousse diet 170cal
Mousse chocolate 200cal
Bebida
Chá 20cal
Suco de laranja 70cal
Suco de melão 100cal
Refrigerante diet 65cal
Para resolver este problema em Rust, você pode usar o match para comparar o prato, sobremesa e bebida escolhidos pelo usuário com as opções disponíveis e adicionar a quantidade de calorias correspondente a uma variável total.

Aqui está um exemplo de como fazer isso:


fn main() {
    let mut total_calories = 0;

    // Pergunte ao usuário qual prato eles escolheram
    println!("Escolha um prato: Vegetariano, Peixe, Frango, Carne");
    let prato = read_input();

    // Adicione a quantidade de calorias do prato ao total
    match prato {
        "Vegetariano" => total_calories += 180,
        "Peixe" => total_calories += 230,
        "Frango" => total_calories += 250,
        "Carne" => total_calories += 350,
        _ => println!("Opção de prato inválida"),
    }

    // Pergunte ao usuário qual sobremesa eles escolheram
    println!("Escolha uma sobremesa: Abacaxi, Sorvete diet, Mousse diet, Mousse chocolate");
    let sobremesa = read_input();

    // Adicione a quantidade de calorias da sobremesa ao total
    match sobremesa {
        "Abacaxi" => total_calories += 75,
        "Sorvete diet" => total_calories += 110,
        "Mousse diet" => total_calories += 170,
        "Mousse chocolate" => total_calories += 200,
        _ => println!("Opção de sobremesa inválida"),
    }

    // Pergunte ao usuário qual bebida eles escolheram
    println!("Escolha uma bebida: Chá, Suco de laranja, Suco de melão, Refrigerante diet");
    let bebida = read_input();

    // Adicione a quantidade de calorias da bebida ao total
    match bebida {
        "Chá" => total_calories += 20,
        "Suco de laranja" => total_calories += 70,
        "Suco de melão" => total_calories += 100,
        "Refrigerante diet" => total_calories += 65,
        _ => println!("Opção de bebida inválida"),
    }

    // Exiba o total de calorias da refeição
    println!("O total de calorias da refeição é {}", total_calories);
}

// Esta função lê a entrada do usuário e retorna uma string
fn read_input() -> String {
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();
    input.trim().to_string()
}
Neste c
==============================================================
24. A polícia rodoviária resolveu fazer cumprir a lei e vistoriar veículos para cobrar
dos motoristas o DUT. Sabendo-se que o mês em que o emplacamento do carro
deve ser renovado é determinado pelo último número da placa do mesmo, faça
um programa que, a partir da leitura da placa do carro, informe o mês em que o
emplacamento deve ser renovado.
Aqui está um exemplo de como você poderia fazer isso em Rust:


fn main() {
    // Solicita a placa do carro ao usuário
    println!("Insira a placa do carro: ");

    // Lê a placa do carro
    let mut placa = String::new();
    std::io::stdin().read_line(&mut placa).expect("Falha ao ler a placa do carro");

    // Remove o caractere de nova linha da string
    placa.pop();

    // Obtém o último caractere da placa
    let ultimo_caractere = placa.chars().rev().next().unwrap();

    // Verifica em qual mês o emplacamento deve ser renovado com base no último caractere da placa
    let mes_renovacao = match ultimo_caractere {
        '1' => "Janeiro",
        '2' => "Fevereiro",
        '3' => "Março",
        '4' => "Abril",
        '5' => "Maio",
        '6' => "Junho",
        '7' => "Julho",
        '8' => "Agosto",
        '9' => "Setembro",
        '0' => "Outubro",
        _ => "Mês inválido",
    };

    // Imprime o resultado
    println!("O emplacamento deve ser renovado em {}.", mes_renovacao);
}

==========================================================
25. A prefeitura contratou uma firma especializada para manter os níveis de poluição
considerados ideais para um país do 1º mundo. As indústrias, maiores responsá-
veis pela poluição, foram classificadas em três grupos. Sabendo-se que a escala
utilizada varia de 0,05 e que o índice de poluição aceitável é até 0,25, fazer um
programa que possa imprimir intimações de acordo com o índice e a tabela a
seguir:
Índice
0,3
0,4
0,5
Indústrias que receberão intimação
1º gurpo
1º e 2º grupos
1º, 2º e 3º grupos
Aqui está um exemplo de como você poderia fazer isso em Rust:


fn main() {
    // O índice de poluição
    let pollution_index = 0.4;

    // Verificamos o índice de poluição e imprimimos a intimação adequada
    if pollution_index > 0.25 {
        if pollution_index > 0.5 {
            println!("Intimação enviada para todos os grupos de indústrias");
        } else if pollution_index > 0.3 {
            println!("Intimação enviada para os grupos 1 e 2 de indústrias");
        } else {
            println!("Intimação enviada para o grupo 1 de indústrias");
        }
    } else {
        println!("Nenhuma intimação necessária");
    }
}
Este código verifica primeiro se o índice de poluição é maior que o limite aceitável (0,25). Se for, então verifica em qual intervalo o índice de poluição se encontra e imprime a intimação adequada. Se o índice de poluição for menor ou igual a 0,25, então nenhuma intimação é necessária.

Você também poderia usar o operador de "match" para fazer isso, como mostrado abaixo:


fn main() {
    // O índice de poluição
    let pollution_index = 0.4;

    // Verificamos o índice de poluição e imprimimos a intimação adequada
    match pollution_index {
        x if x > 0.5 => println!("Intimação enviada para todos os grupos de indústrias"),
        x if x > 0.3 => println!("Intimação enviada para os grupos 1 e 2 de indústrias"),
        x if x > 0.25 => println!("Intimação enviada para o grupo 1 de indústrias"),
        _ => println!("Nenhuma intimação necessária"),
    }
}
Neste exemplo, o operador "match" verifica o índice de poluição e executa o código adequado para o intervalo em que o índice se encontra. Se o índice de poluição não se encaixar em nenhum dos intervalos especificados, então o código correspondente ao "case" "_" será executado.

======================================================================================
Estruturas de Iteração
Metas da Aula
1. Entender e praticar os conceitos da sintaxe utilizada na linguagem Rust para estruturas de iteração.
2. Aplicar variadas situações relacionadas ao fluxo de iteração em programação com o objetivo de
cobrir diversificadas possibilidades vivenciadas na programação cotidiana.
3. Escrever programas que farão uso de estruturas de iteração.
Ao término desta aula, você será capaz de:
1. Escrever programas em linguagem Rust que sejam capazes de resolver problemas que envolvam, por
exemplo, a repetição de várias instruções em função de uma determinada condição.
2. Escrever programas que manipulem informações repetidas vezes considerando variadas situações
e condições.



As estruturas de iteração em Rust são muito semelhantes às estruturas de iteração em Rust. A estrutura while permite que um bloco de código seja executado enquanto uma determinada condição for verdadeira. A sintaxe é a seguinte:


while condição {
    // bloco de código
}
A estrutura do-while é similar à estrutura while, mas garante que o bloco de código seja executado pelo menos uma vez, independentemente da condição inicial. A sintaxe é a seguinte:


do {
    // bloco de código
} while (condição);
Por fim, a estrutura for é usada para iterar sobre uma sequência de valores, como um vetor ou uma string. A sintaxe é a seguinte:


for elemento in sequência {
    // bloco de código
}
Além dessas estruturas de iteração, Rust também oferece o comando loop, que permite que um bloco de código seja executado repetidamente até que seja explicitamente interrompido com o comando break. A sintaxe é a seguinte:


loop {
    // bloco de código
    if condição {
        break;
    }
}
Todas essas estruturas de iteração em Rust são semelhantes às estruturas de iteração em Rust, mas oferecem algumas vantagens em termos de segurança e facilidade de uso. Além disso, Rust também possui outras estruturas de iteração mais avançadas, como o Iterator e o Iterable, que permitem iterar de maneira mais flexível e eficiente.



Em Rust, a cláusula for é usada de maneira similar ao que é descrito acima. A sintaxe básica é a seguinte:


for variavel in intervalo {
    // instruções
}
Onde variavel é uma variável que é usada para armazenar os valores gerados pelo intervalo a cada iteração, e intervalo é um objeto que gera os valores que serão iterados. O laço continuará enquanto houver valores disponíveis no intervalo.

Aqui está um exemplo de um laço for que imprime os números de 0 a 9:


for i in 0..10 {
    println!("{}", i);
}
Você também pode usar a cláusula for para iterar sobre elementos de uma coleção, como um vetor ou uma lista ligada. Por exemplo:


let v = vec![1, 2, 3];

for elemento in v {
    println!("{}", elemento);
}
Note que, ao contrário do C, o Rust não permite modificar o valor da variável de iteração dentro do laço for. Isso é porque o Rust é uma linguagem de propósito geral que se preocupa em evitar erros de programação comuns, como acessos inválidos à memória ou comportamentos não determinísticos.

Em Rust, o laço for é usado de maneira semelhante a outras linguagens de programação. Aqui está um exemplo de como usar o laço for em Rust:


for i in 0..10 {
    println!("O valor de i é {}", i);
}
Neste exemplo, o laço for irá iterar de 0 a 9, imprimindo o valor de i em Rustada iteração. A sintaxe 0..10 cria um intervalo de números inteiros de 0 a 9. O laço for irá iterar por esse intervalo e atribuir o valor atual da iteração para a variável i.

Você também pode usar o laço for para iterar sobre uma coleção, como um vetor ou uma lista. Aqui está um exemplo de como fazer isso:


let vec = vec![1, 2, 3, 4, 5];

for val in vec {
    println!("O valor atual é {}", val);
}
Neste exemplo, o laço for irá iterar sobre os elementos do vetor vec e imprimir o valor atual em Rustada iteração.

Você também pode usar o laço for com um bloco de instruções, assim como mencionado na sua pergunta. Aqui está um exemplo de como fazer isso:


for i in 0..10 {
    let mut sum = 0;
    sum += i;
    println!("A soma atual é {}", sum);
}
Neste exemplo, o laço for irá iterar de 0 a 9 e calcular a soma de cada número nesse intervalo. O bloco de instruções é delimitado pelas chaves {}.

Espero que isso tenha ajudado a esclarecer como usar o laço for em Rust. Qualquer dúvida adicional, sinta-se à vontade para perguntar.

Faça um programa em Rust que leia 10 valores e ao final imprima a média aritmética dos
valores lidos.
Fonte: Adaptado de Lopes e Garcia (2002, p. 152)

Em Rust, o código para calcular a média aritmética de 10 números lidos pelo usuário seria o seguinte:


use std::io;

fn main() {
    let mut soma = 0;
    let mut media = 0;

    for _i in 0..10 {
        println!("Informe o número:");

        let mut num = String::new();
        io::stdin().read_line(&mut num)
            .expect("Falha ao ler a entrada");

        let num: f32 = num.trim().parse()
            .expect("Por favor, digite um número");

        soma += num;
    }

    media = soma / 10.0;
    println!("A média é: {}", media);
}
Neste código, usamos a função read_line da biblioteca padrão io para ler a entrada do usuário como uma string. Em seguida, convertemos a string para o tipo f32 (número de ponto flutuante de 32 bits) usando o método parse.

Depois de ler os 10 números, calculamos a média dividindo a soma dos números pelo número de elementos (10). Por fim, imprimimos a média usando a macro println!.

Note que, no Rust, é preciso especificar o tipo da variável na declaração. Além disso, é necessário usar o mut para indicar que uma variável é mutável (pode ser alterada ao longo da execução do programa).

=====================================================
O exercício
de exemplo pode nos levar a uma questão, e se não é conhecido previamente o número
de iterações necessárias? Neste caso, pode-se utilizar uma variável para determinar o
número total de iterações. Para exemplificar, veja a seguir um exercício ajustado em
relação ao exemplo anterior.

Exercício de Exemplo
Faça um programa em Rust que leia "n" valores. O programa deve inicialmente solicitar ao
usuário que informe a quantidade desejada de valores a ser informada, depois ler os
"n" valores e ao final imprimir a média aritmética dos valores lidos.


A seguir está o código em Rust equivalente ao exemplo em Rust acima:


use std::io;

fn main() {
    let mut qtde_num = String::new();

    println!("Informe a quantidade de números:");

    io::stdin()
        .read_line(&mut qtde_num)
        .expect("Falha ao ler a entrada");

    let qtde_num: i32 = qtde_num.trim().parse().expect("Por favor, digite um número inteiro válido");

    let mut soma = 0.0;

    for _ in 0..qtde_num {
        println!("Informe o número:");

        let mut num = String::new();

        io::stdin()
            .read_line(&mut num)
            .expect("Falha ao ler a entrada");

        let num: f32 = num.trim().parse().expect("Por favor, digite um número válido");

        soma += num;
    }

    let media = soma / qtde_num as f32;

    println!("A média é: {}", media);
}
Explicação:

A primeira linha use std::io permite ao código acessar funções de entrada e saída (I/O).
Na linha 6, declaramos uma variável mutável (mut) chamada qtde_num do tipo String. Ela será usada para armazenar a quantidade de números informada pelo usuário.
Na linha 8, usamos a macro println! para imprimir uma mensagem solicitando a quantidade de números.
Na linha 10, usamos a função read_line do módulo stdin para ler a entrada do usuário e armazená-la em qtde_num.
Na linha 11, usamos a função expect para tratar o possível erro de falha ao ler a entrada.
Na linha 13, usamos a função trim para remover os espaços em branco do início e do fim de qtde_num, e a função parse para converter o valor de qtde_num de String para i32. Usamos novamente a função expect para tratar o possível erro de conversão para um número inteiro inválido.
Na linha 15, declaramos uma variável mutável (mut) chamada soma do tipo f32 (ponto flutuante de precisão simples) com o valor inicial de 0.0. Ela será usada para armazenar a soma dos números lidos.
Na linha 17, inic



Faça um programa em Rust que imprima todos os valores entre 0 e 100 múltiplos de 10.


fn main() {
    for i in (0..=100).step_by(10) {
        println!("Multiplo de 10: {}", i);
    }
}

Examinando cada linha do código:

fn main(): Esta linha define a função principal do programa. Em Rust, a função principal é a função que é executada quando o programa é iniciado.

for i in (0..=100).step_by(10): Esta linha cria um loop for que percorre os números de 0 a 100, de 10 em 10. O operador ..= é usado para criar um intervalo que inclui o número final (100), enquanto o método step_by especifica o tamanho do passo a ser usado (neste caso, 10).

println!("Multiplo de 10: {}", i);: Esta linha imprime a mensagem "Multiplo de 10" seguida pelo valor de i atual. O símbolo {} é usado como um marcador de posição para o valor de i, que é passado como um argumento para a função println!.

}: Esta chave fecha o loop for.




==========================================================

Além de poder incrementar valores diferentes de 1, conforme visto, é possível tam-
bém decrementar valores, permitindo assim, executar laços do final para o início, per-
mitindo assim resolver facilmente alguns problemas computacionais que demandam
este tipo de situação. A seguir um exercício para exemplificar.
3.2.4
Exercício de Exemplo
Faça um programa em Rust que imprima todos os valores entre 0 e 10 em ordem decres-
cente.

fn main() {
    for i in (0..=10).rev() {
        println!("Numero: {}", i);
    }
}
Explicando cada linha:

fn main(): declara a função principal do programa. Todo programa em Rust deve ter uma função main.
for i in (0..=10).rev(): inicia um loop for que percorre os números de 0 a 10 em ordem reversa. O intervalo é criado com 0..=10 e, em seguida, é chamado o método rev para reverter a ordem.
println!("Numero: {}", i);: imprime o número atual no loop. O símbolo {} é um espaço reservado para o valor de i, que é inserido na string de saída.
}: fecha o loop for.


Faça um programa em Rust que imprima todos os valores pares entre 1 e 20.

fn main() {
    for i in 1..=20 {
        if i % 2 == 0 {
            println!("Numero par: {}", i);
        }
    }
}
Explicação:

fn main(): indica o início da função principal do programa.
for i in 1..=20: inicia um loop que itera sobre os valores de 1 a 20 (inclusive). O valor de i é atualizado a cada iteração.
if i % 2 == 0: verifica se o valor de i é par (divisível por 2).
println!("Numero par: {}", i): imprime a mensagem "Numero par: [valor de i]" na tela, onde [valor de i] é o valor atual de i.


=========================================

Cláusula for com laços aninhados



Laços aninhados são estruturas de iteração que são colocadas dentro de outra estrutura de iteração. Por exemplo, você pode ter um laço "for" dentro de outro laço "for". Quando um laço aninhado é executado, o laço externo é executado primeiro, completando todas as suas iterações. Em seguida, o laço interno é executado completamente, antes que o laço externo faça sua próxima iteração. Isso é repetido até que o laço externo tenha completado todas as suas iterações.

Um diagrama em LaTeX para um laço aninhado pode ser criado da seguinte forma:


\begin{algorithm}
  \caption{Exemplo de Laço Aninhado}
  \label{alg:nested_loop}
  \begin{algorithmic}
    \For{$i \gets 1$ to $n$}
      \For{$j \gets 1$ to $m$}
        \State $x \gets x + 1$
      \EndFor
    \EndFor
  \end{algorithmic}
\end{algorithm}
No exemplo acima, temos um laço "for" externo que itera de 1 a n, e um laço "for" interno que itera de 1 a m. Cada iteração do laço interno é completada antes que o laço externo faça sua próxima iteração.

Em Rust, um laço aninhado pode ser escrito da seguinte forma:


for i in 1..=n {
  for j in 1..=m {
    x += 1;
  }
}
Neste exemplo, o laço "for" externo itera de 1 a n, e o laço "for" interno itera de 1 a m. Cada iteração do laço interno é completada antes que o laço externo faça sua próxima iteração.


Exercício de Exemplo
Faça um programa em Rust que imprima uma matriz de 4 linhas por 4 colunas, sendo que
na primeira linha devem ser impressos os valores de 1 à 4 e partir da segunda linha, os
valores impressos devem ser múltiplos da linha anterior.


fn main() {
    for i in 1..=4 {
        for j in 1..=4 {
            if j < 4 {
                print!("{}\t", j * i);
            } else {
                println!("{}", j * i);
            }
        }
    }
}
Explicação da código:

A função main() é a função principal de um programa em Rust. Ela é chamada quando o programa é executado.
O loop for i in 1..=4 itera pelos números de 1 a 4, incluindo o 4. O ..= é o operador de range que inclui o último número da faixa.
O loop for j in 1..=4 itera pelos números de 1 a 4, incluindo o 4.
O if verifica se j é menor que 4. Se for, imprime o valor de j * i seguido de uma tabulação (\t). Se não for, imprime o valor de j * i seguido de uma quebra de linha (\n).
A função print! é semelhante à função printf do C, mas não adiciona uma quebra de linha no final da string de saída. A função println! é semelhante à função println do Java, adicionando uma quebra de linha no final da string de saída.








=========================================


Loop inﬁnito na cláusula for
O uso de estruturas de iteração implica em repetir um determinado número de ins-
truções, ou seja, um número finito de repetições, contudo, por erro de programação,
é possível provocar um número infinito de repetições, em geral, o nome dado a este
efeito é "loop infinito"ou "laço infinito". Essa situação é indesejável, pois uma vez
provocada, o programa não conseguirá concluir a operação e o menor dos problemas
será o estouro de memória do computador, ocasionando em travamento (KERNIGHAN;
RITCHIE, 1988; SCHILDT, 1996; ANICHE, 2015). Desta forma, é necessário ter cuidado
ao estabelecer a condição de saída do laço. Veja a seguir um exemplo de programa com
loop infinito.



Para fazer um loop infinito com a cláusula for em Rust, basta usar o range 0.. como o intervalo de iteração:


for _ in 0.. {
    // código a ser executado no loop
}
Ou você pode usar a palavra-chave loop para criar um loop infinito:


loop {
    // código a ser executado no loop
}
Lembre-se de que um loop infinito só deve ser usado com moderação, pois ele continuará executando o código dentro dele indefinidamente a menos que você adicione uma condição de saída. É importante garantir que o código dentro do loop não bloqueie ou trave o programa de alguma forma.



=========================================

Cláusula while
Diferente do for o while geralmente é empregado quando não se pode determinar com
certeza quantas vezes um bloco de comandos será executado. A condição do while é
definida de forma muito similar à definição da condição no if. A diferença é que no if
o objetivo é desviar o caminho de execução para um fluxo de instruções ou outro, no
while o objetivo será manter a execução de um bloco de instruções em execução, assim
como no for. Veja a seguir a sintaxe while:
Em Rust, a cláusula while é usada da mesma forma que em outras linguagens de programação. Ela permite que um bloco de código seja executado enquanto uma determinada condição for verdadeira. Aqui está um exemplo de como usar a cláusula while em Rust:


let mut counter = 0;

while counter < 10 {
    println!("O contador é {}", counter);
    counter += 1;
}
Neste exemplo, o bloco de código será executado enquanto o contador for menor que 10. A cada iteração, o valor do contador é impresso e, em seguida, é incrementado em 1. Quando o contador atingir o valor de 10, a condição de parada será falsa e o loop será interrompido.

Você também pode usar a cláusula break dentro de um loop while para interromper a execução do loop antes que a condição de parada se torne falsa. Por exemplo:


let mut counter = 0;

while counter < 10 {
    if counter == 5 {
        break;
    }
    println!("O contador é {}", counter);
    counter += 1;
}
Neste exemplo, o loop será interrompido quando o contador atingir o valor de 5, pois a cláusula break é executada.

Essa é a sintaxe geral de um loop while em Rust. A condição de parada é especificada entre parênteses logo após a palavra-chave while. Se a condição for verdadeira, o bloco de código entre chaves será executado. O loop continuará a ser executado enquanto a condição for verdadeira. Quando a condição for falsa, o loop será interrompido e o código após o loop será executado.

O código dentro do loop pode incluir uma ou mais instruções separadas por ponto e vírgula. Essas instruções são executadas na ordem em que aparecem, uma vez que o loop é iniciado.

Por exemplo, aqui está um loop while que imprime os números de 1 a 10:


let mut counter = 1;

while counter <= 10 {
    println!("{}", counter);
    counter += 1;
}
Neste exemplo, o loop será executado enquanto o contador for menor ou igual a 10. A cada iteração, o valor do contador é impresso e, em seguida, é incrementado em 1. Quando o contador atingir o valor de 11, a condição de parada será falsa e o loop será interrompido.

Exercício de Exemplo
Faça um programa em Rust que realize a soma de todos os valores inteiros de 1 a n, sendo
que n deve ser informado pelo usuário.

use std::io;

fn main() {
println!("Informe o número n:");


let mut n = String::new();
io::stdin().read_line(&mut n)
    .expect("Falha ao ler a entrada");

let n: i32 = n.trim().parse()
    .expect("Por favor, insira um número inteiro válido");

let mut i = 1;
let mut soma = 0;
while i <= n {
    soma += i;
    i += 1;
}

println!("Soma: {}", soma);
}

Explanation:

O primeiro comando inclui a biblioteca de entrada e saída padrão (stdio).
Em seguida, é definida a função principal (main) que será executada pelo programa.
O comando println! exibe uma mensagem na tela solicitando o valor de n.
O comando let mut n = String::new() cria uma variável mutável (mut) chamada n do tipo String e a inicializa como vazia.
O método read_line do objeto stdin da biblioteca io é utilizado para ler a entrada do usuário e armazená-la na variável n.
O método expect é usado para lidar com possíveis erros durante a leitura da entrada.
O comando let n: i32 = n.trim().parse() converte a string lida para um número inteiro (i32) e armazena o resultado na mesma variável n.
Novamente, o método expect é usado para lidar com possíveis erros na conversão.
A variável i é inicializada com 1 e a variável soma com 0.
O loop while é iniciado e a cada iteração a variável soma é incrementada com o valor de i. A variável i também é incrementada em 1.
Quando o loop é finalizado, a variável soma armazena o resultado da soma de todos os valores inteiros de 1 a n.
Por fim, o comando println! exibe o resultado na tela.



Exercício de Exemplo
Uma agência bancária de uma cidade do interior tem, no máximo, 10 mil clientes. Criar
um programa em Rust que possa entrar com o número da conta, o nome e o saldo de cada
cliente. Imprimir todas as contas, os respectivos saldos e uma das mensagens: positivo
/ negativo. A digitação acaba quando se digita -999 para número da conta ou quando
chegar a 10 mil clientes. Ao final, deverá sair o total de clientes com saldo negativo, o
total de clientes da agência e o saldo da agência.
Fonte: Adaptado de Lopes e Garcia (2002, p. 197)
Aqui está o código equivalente em Rust:


use std::io;

fn main() {
    let mut conta = 0;
    let mut c_tot_neg = 0;
    let mut c_tot = 0;
    let mut saldo = 0.0;
    let mut soma = 0.0;
    let mut nome = String::new();

    println!("Digite o número da conta ou -999 para terminar:");
    io::stdin().read_line(&mut conta)
        .expect("Falha ao ler o número da conta");
    conta = conta.trim().parse().expect("Por favor, digite um número válido");

    while conta > 0 && c_tot < 10000 {
        c_tot += 1;
        println!("Nome:");
        io::stdin().read_line(&mut nome)
            .expect("Falha ao ler o nome");
        println!("Saldo:");
        io::stdin().read_line(&mut saldo)
            .expect("Falha ao ler o saldo");
        saldo = saldo.trim().parse().expect("Por favor, digite um número válido");
        soma += saldo;
        if saldo < 0.0 {
            c_tot_neg += 1;
            println!("{} - {} - negativo", conta, saldo);
        } else {
            println!("{} - {} - positivo", conta, saldo);
        }
        println!("Digite o número da conta ou -999 para terminar:");
        io::stdin().read_line(&mut conta)
            .expect("Falha ao ler o número da conta");
        conta = conta.trim().parse().expect("Por favor, digite um número válido");
    }

    println!("\nTotal de clientes com saldo negativo: {}", c_tot_neg);
    println!("Total de clientes da agência: {}", c_tot);
}

=====================================================================
Validação de dados com while

Para validar os dados com while em Rust, você pode usar um loop while para ler o valor de entrada do usuário e verificar se ele está dentro da faixa de valores permitidos. Se o valor não estiver dentro da faixa, você pode exibir uma mensagem de erro e solicitar ao usuário que informe um novo valor. Aqui está um exemplo de como isso pode ser feito:


use std::io;

fn main() {
    // Faixa de valores permitidos: 1 para Sim e 0 para Não
    println!("Por favor, informe um valor (1 para Sim e 0 para Não):");

    // Lê o valor de entrada do usuário
    let mut valor = String::new();
    io::stdin().read_line(&mut valor).expect("Falha ao ler a entrada");

    // Converte o valor de String para u32
    let valor: u32 = match valor.trim().parse() {
        Ok(num) => num,
        Err(_) => {
            println!("O valor informado não é um número válido");
            return;
        }
    };

    // Loop while para validar o valor
    while valor != 1 && valor != 0 {
        println!("O valor informado está fora da faixa permitida (1 para Sim e 0 para Não)");
        println!("Por favor, informe um novo valor:");

        // Lê o valor de entrada do usuário
        let mut valor = String::new();
        io::stdin().read_line(&mut valor).expect("Falha ao ler a entrada");

        // Converte o valor de String para u32
        let valor: u32 = match valor.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("O valor informado não é um número válido");
                return;
            }
        };
    }

    // Se o loop terminou, o valor está dentro da faixa permitida
    println!("Obrigado por informar um valor válido!");
}

Neste exemplo, usamos a função read_line da biblioteca std::io para ler a entrada do usuário como uma string, em seguida convertemos essa string para o tipo u32 com a função parse. Em seguida, usamos um loop while para verificar se o valor está dentro da faixa de valores permitidos (1 para Sim e 0 para Não). Se o valor não estiver dentro da faixa, exibimos uma mensagem de erro e solicitamos ao usuário que informe um novo valor. O loop continua até que o valor esteja dentro da faixa permitida. 

O comando continue é usado para interromper a execução do loop atual e passar para a próxima iteração. Isso é útil quando você deseja pular determinadas iterações do loop dependendo de alguma condição.

Aqui está um exemplo de como o comando continue pode ser usado em um loop while:


fn main() {
    // Define uma variável contadora
    let mut i = 0;

    // Loop while
    while i < 10 {
        i += 1; // Incrementa o contador

        // Pula a iteração atual se o contador for igual a 5
        if i == 5 {
            continue;
        }

        println!("O contador é {}", i);
    }
}
Neste exemplo, o loop while é executado 10 vezes, de 0 a 9. No entanto, quando o contador é igual a 5, o comando continue é executado e a iteração atual é puleada, fazendo com que o loop passe diretamente para a próxima iteração. Portanto, a saída deste exemplo seria:


O contador é 1
O contador é 2
O contador é 3
O contador é 4
O contador é 6
O contador é 7
O contador é 8
O contador é 9
O contador é 10
Observe que o valor 5 não aparece na saída, pois foi puleado pelo comando continue.


===============================================================================
Exercício de Exemplo
Faça um programa em linguagem Rust que leia 10 números positivos e imprima o quadrado
de cada número. Para cada entrada de dados deverá haver um trecho de validação para
que um número negativo não seja aceito pelo programa.
Fonte: Adaptado de Lopes e Garcia (2002, p. 192)

use std::io;

fn main() {
    let mut num: f32;
    let mut i = 1;

    while i <= 10 {
        println!("Informe um número:");

        let mut input = String::new();
        io::stdin().read_line(&mut input).expect("Falha ao ler entrada");
        num = input.trim().parse().expect("Por favor, insira um número");

        while num <= 0.0 {
            println!("\nATENÇÃO! Informe um número maior que zero:");

            let mut input = String::new();
            io::stdin().read_line(&mut input).expect("Falha ao ler entrada");
            num = input.trim().parse().expect("Por favor, insira um número");
        }

        println!("Quadrado: {}", num * num);
        i += 1;
    }
}
Explicação das linhas:

use std::io;: Importa a biblioteca io do módulo std, que fornece funções para entrada e saída de dados.

fn main() {: Define a função principal do programa. Em Rust, todo programa deve ter uma função main, que é a primeira a ser executada quando o programa é iniciado.

let mut num: f32;: Declara uma variável mutável chamada num do tipo f32. f32 é um tipo de ponto flutuante de precisão simples, que armazena números reais com precisão de 32 bits.

let mut i = 1;: Declara uma variável mutável chamada i e atribui o valor 1 a ela.

while i <= 10 {: Inicia um loop while, que será executado enquanto a condição i <= 10 for verdadeira.

println!("Informe um número:");: Imprime a string "Informe um número:". O símbolo de exclamação (!) indica que esta é uma macro, não uma função. Macros são similarmente a funções, mas são processadas pelo pré-processador do Rust antes da compilação.

let mut input = String::new();: Declara uma variável mutável chamada input do tipo String e inicializa-a como uma string vazia. String é uma estrutura de dados do Rust que representa uma sequência de caracteres Unicode.

io::stdin().read_line(&mut input).expect("Falha ao ler entrada");: Lê uma linha de entrada do usuário e arm

num = input.trim().parse().expect("Por favor, insira um número");: Remove espaços em branco do início e do fim da string de entrada e converte a string em um número do tipo f32. O método trim remove os espaços em branco, o método parse tenta converter a string em um número e o método expect retorna o valor de sucesso ou lança uma exceção com a mensagem de erro especificada.

while num <= 0.0 {: Inicia um loop while, que será executado enquanto a condição num <= 0.0 for verdadeira. Este loop é usado para garantir que o usuário insira um número positivo.

println!("\nATENÇÃO! Informe um número maior que zero:");: Imprime a string "ATENÇÃO! Informe um número maior que zero:".

let mut input = String::new();: Declara uma variável mutável chamada input do tipo String e inicializa-a como uma string vazia.

io::stdin().read_line(&mut input).expect("Falha ao ler entrada");: Lê uma linha de entrada do usuário e armazena-a na variável input.

num = input.trim().parse().expect("Por favor, insira um número");: Remove espaços em branco do início e do fim da string de entrada e converte a string em um número do tipo f32.

println!("Quadrado: {}", num * num);: Imprime o quadrado do número lido. O símbolo {} é usado como um mar
======================================================================

Cláusula while com laços aninhados


Em Rust, assim como em outras linguagens de programação, é possível aninhar laços while dentro de outros laços while ou mesmo outros laços for. Isso é útil em situações em que é necessário iterar sobre uma estrutura de dados complexa ou realizar operações repetidas em diferentes níveis de hierarquia.

No entanto, é importante lembrar que o uso excessivo de laços aninhados pode afetar o desempenho do seu código, pois aumenta o número de instruções que precisam ser executadas. Portanto, é importante usar essa técnica de forma consciente e evitar aninhar laços desnecessariamente.

Aqui está um exemplo de como aninhar laços while em Rust:


let mut i = 0;
let mut j = 0;

while i < 10 {
    j = 0;
    while j < 10 {
        println!("i = {}, j = {}", i, j);
        j += 1;
    }
    i += 1;
}
Neste exemplo, o primeiro laço while itera de 0 a 9 e o segundo laço while itera de 0 a 9 em Rustada iteração do primeiro laço. Isso resulta em 100 iterações do segundo laço (10 x 10) e, portanto, 100 mensagens sendo impressas.

É importante lembrar de inicializar as variáveis de contagem (i e j neste exemplo) antes de entrar nos laços while e também de incrementá-las de alguma forma dentro dos laços para garantir que eles eventualmente cheguem ao seu valor final e que os laços encerrem. Do contrário, os laços poderão se tornar infinitos.

Exercício de Exemplo
Na Usina de Angra dos Reis, os técnicos analisam a perda de massa de um material
radioativo. Sabendo-se que este perde 25% de sua massa a cada 30 segundos, criar um
programa em Rust que imprima o tempo necessário para que a massa deste material se
torne menor que 0,10 grama. O programa deve calcular o tempo para várias massas.
Fonte: Adaptado de Lopes e Garcia (2002, p. 204)
Aqui está a versão em Rust do código acima:


fn main() {
    let mut con_tempo = 0;
    let mut massa: f32;
    let mut tempo: f32;
    let mut resp: char;

    println!("Digite S se desejar novo cálculo ou qualquer letra para terminar:");
    std::io::stdin().read_line(&mut resp).expect("Falha ao ler a entrada");

    while resp == 'S' || resp == 's' {
        println!("Digite a massa em gramas do material:");
        std::io::stdin().read_line(&mut massa).expect("Falha ao ler a entrada");

        massa = massa.trim().parse().expect("Por favor, insira um número válido");

        while massa >= 0.10 {
            con_tempo += 1;
            massa *= 0.75;
        }

        tempo = (con_tempo * 30) as f32 / 60 as f32;
        println!("O tempo foi de: {} minutos.", tempo);

        println!("\n Digite S se desejar novo cálculo ou qualquer letra para terminar:");
        std::io::stdin().read_line(&mut resp).expect("Falha ao ler a entrada");
    }
}
Agora, vamos explicar cada linha do código:

fn main() é a função principal do programa em Rust. Todo programa em Rust deve ter uma função main, que é onde o código começa a ser executado.

let mut con_tempo = 0; declara uma variável chamada con_tempo e a inicializa com o valor 0. A palavra-chave mut indica que a variável é mutável, ou seja, seu valor pode ser alterado ao longo da execução do programa.

let mut massa: f32; declara uma variável chamada massa do tipo f32, que é um tipo de ponto flutuante com precisão de 32 bits. A palavra-chave mut indica que a variável é mutável.

let mut tempo: f32; declara uma variável chamada tempo do tipo f32, que é um tipo de ponto flutuante com precisão de 32 bits. A palavra-chave mut indica que a variável é mutável.

let mut resp: char; declara uma variável chamada resp do tipo char, que é um tipo de caractere. A palavra-chave mut indica que a variável é mutável.

`println!("Digite S se desejar novo cálculo ou qualquer letra




Loop inﬁnito na cláusula while


Assim como na cláusula for, a estrutura while também está sujeita há erros de progra-
mação que levem ao loop ou laço infinito (KERNIGHAN; RITCHIE, 1988; SCHILDT,
1996; ANICHE, 2015). Como já mencionado o loop infinito é indesejado em nosso pro-
grama, desta forma, é preciso ter cuidado para não cometer erros que levem a este
problema. A seguir um exemplo desta situação com a cláusula while.

fn main() {
    let mut resp = 1;
    while resp == 1 {
        println!("Digite a idade:");

        let mut idade = String::new();
        io::stdin().read_line(&mut idade).expect("Falha ao ler a entrada");
        let idade: i32 = match idade.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("A idade é: {}", idade);

        println!("\nDigite 1 para continuar ou outro número para terminar:");

        let mut resp_str = String::new();
        io::stdin().read_line(&mut resp_str).expect("Falha ao ler a entrada");
        resp = match resp_str.trim().parse() {
            Ok(num) => num,
            Err(_) => break,
        };
    }
}

Para corrigir este problema, temos o seguinte código:

Aqui está a mesma função escrita em Rust:


use std::io;

fn main() {
    let mut resp = 1;
    while resp == 1 {
        println!("Digite a idade:");

        let mut idade = String::new();
        io::stdin().read_line(&mut idade).expect("Falha ao ler a entrada");

        let idade: i32 = match idade.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("A idade é: {}", idade);
        println!("\n Digite 1 para continuar ou outro número para terminar:");

        let mut resp_str = String::new();
        io::stdin().read_line(&mut resp_str).expect("Falha ao ler a entrada");

        resp = match resp_str.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
    }
}
Agora, vamos explicar cada linha:

use std::io;: importa o módulo io da biblioteca padrão do Rust, que fornece funções para ler e escrever em fluxos de entrada e saída.

fn main() {: define o ponto de entrada da aplicação. Todo código Rust precisa de uma função main para começar a ser executado.

let mut resp = 1;: declara uma variável mutável chamada resp e a inicializa com o valor 1.

while resp == 1 {: inicia um loop que será executado enquanto resp for igual a 1.

println!("Digite a idade:");: imprime a mensagem "Digite a idade:" na saída padrão. O println! é uma macro que permite imprimir mensagens formatadas.

let mut idade = String::new();: declara uma variável mutável chamada idade do tipo String e a inicializa como uma string vazia. O String é um tipo de dados que representa uma string mutável (que pode ser alterada).

io::stdin().read_line(&mut idade).expect("Falha ao ler a entrada");: lê uma linha da entrada padrão e armazena o resultado na variável idade. O expect é usado para lidar com erros que podem ocorrer durante a leitura da entrada.



Em Rust, um loop infinito pode ser criado utilizando o comando loop sem uma condição de saída especificada. Por exemplo:


loop {
    println!("Este é um loop infinito!");
}
Esse loop irá imprimir a mensagem "Este é um loop infinito!" repetidamente até que o programa seja interrompido manualmente.

Um loop infinito pode ser útil em alguns casos, como quando você quer criar um programa que fica rodando indefinidamente e espera por entrada do usuário. No entanto, é importante ter cuidado ao criar loops infinitos, pois eles podem levar a problemas de performance e podem ser difíceis de depurar se ocorrerem erros dentro do loop.

Para evitar loops infinitos indesejados, é importante garantir que haja uma condição de saída especificada na cláusula while ou for. Isso fará com que o loop pare de ser executado assim que a condição de saída for atendida.

==============================================================================

Cláusula do-while

A cláusula do-while é uma estrutura de loop em Rust que permite que um bloco de código seja executado pelo menos uma vez, independentemente da condição de loop. Isso é feito verificando a condição após a execução do bloco, em vez de antes, como acontece com o loop while.

A sintaxe da cláusula do-while em Rust é semelhante à sintaxe apresentada na sua pergunta:


loop {
    // Bloco de código a ser executado pelo menos uma vez
    if !condicao {
        break;
    }
}
Ou


let mut condicao = true;
while condicao {
    // Bloco de código a ser executado pelo menos uma vez
    condicao = false;
}
A cláusula do-while é útil em situações em que você deseja garantir que um bloco de código seja executado pelo menos uma vez, mesmo que a condição de loop não seja atendida. É importante lembrar de que a condição de loop deve ser atualizada dentro do bloco de código para evitar loop infinito.

Exemplo:


let mut i = 0;
loop {
    println!("i = {}", i);
    i += 1;
    if i > 10 {
        break;
    }
}
O código acima imprimirá os números de 0 a 10.


Exercício de Exemplo
Faça um programa em linguagem Rust que permita entrar com números e imprimir o
quadrado de cada número digitado até entrar um número múltiplo de 6 que deverá ter
seu quadrado impresso também.
Fonte: Adaptado de Lopes e Garcia (2002, p. 189)

Aqui está o código em Rust:


fn main() {
    let mut num: i32;

    loop {
        println!("\n Digite um número ou múltiplo de 6 para encerrar:");
        num = read!();

        println!("Quadrado: {}", num * num);

        if num % 6 == 0 {
            break;
        }
    }
}
Explicação das linhas:

fn main() define a função principal do programa.
let mut num: i32; declara uma variável num como um número inteiro de 32 bits e a marca como mutável, o que significa que seu valor pode ser alterado posteriormente.
loop { ... } cria um loop infinito que só será interrompido quando encontrar um break.
println!("\n Digite um número ou múltiplo de 6 para encerrar:") exibe uma mensagem solicitando ao usuário que digite um número ou múltiplo de 6.
num = read!() lê um número inteiro digitado pelo usuário e atribui esse valor à variável num.
println!("Quadrado: {}", num * num) exibe o quadrado do número digitado pelo usuário.
if num % 6 == 0 verifica se o número digitado é um múltiplo de 6. Se for, o programa entra no bloco de código seguinte.
break interrompe o loop e encerra o programa.

Exercício de Exemplo
Faça um programa em linguagem Rust que funcione através do menu a seguir:
1-S OMA VARIOS NUMEROS
2-M ULTIPLICA VARIOS NUMEROS
3-S AI DO PROGRAMA
OPCAO : |


Aqui está o código em Rust:


use std::io;

fn main() {
    let mut op: i32;
    let mut num: f32;
    let mut soma: f32 = 0.0;
    let mut prod: f32 = 1.0;

    loop {
        println!("1-Soma vários números");
        println!("2-Multiplica vários números");
        println!("3-Encerrar o programa");
        println!("Opção:");

        let mut op_str = String::new();
        io::stdin().read_line(&mut op_str).expect("Falha ao ler entrada");
        op = op_str.trim().parse().expect("Por favor, insira um número inteiro válido");

        if op == 1 {
            soma = 0.0;
            println!("\nDigite um número ou -999 para finalizar:");

            let mut num_str = String::new();
            io::stdin().read_line(&mut num_str).expect("Falha ao ler entrada");
            num = num_str.trim().parse().expect("Por favor, insira um número válido");

            while num != -999.0 {
                soma += num;
                println!("\nDigite um número ou -999 para finalizar:");

                let mut num_str = String::new();
                io::stdin().read_line(&mut num_str).expect("Falha ao ler entrada");
                num = num_str.trim().parse().expect("Por favor, insira um número válido");
            }

            println!("\nSoma: {}", soma);
        } else if op == 2 {
            prod = 1.0;
            println!("\nDigite um número ou -999 para finalizar:");

            let mut num_str = String::new();
            io::stdin().read_line(&mut num_str).expect("Falha ao ler entrada");
            num = num_str.trim().parse().expect("Por favor, insira um número válido");

            while num != -999.0 {
                prod *= num;
                println!("\nDigite um número ou -999 para finalizar:");

                let mut num_str = String::new();
                io::stdin().read_line(&mut num_str).expect("Falha ao ler entrada");
                num = num_str.trim().parse().expect("Por favor, insira um número válido");
            }

            println!("\nProduto: {}", prod);
        } else if op == 3 {
            println!("\nPrograma encerrado!");
            break;
        } else {
            println!("\nOpção não disponível!");
        }
    }
}
===========================================================

Exemplos adicionais

Exercício de Exemplo

Uma transportadora utiliza caminhões que suportam até 10 toneladas de peso, as caixas
transportadas tem tamanho fixo e o caminhão comporta no máximo 200 volumes,
assim, esta transportadora precisa controlar a quantidade e o peso dos volumes para
acomodar nos caminhões. Faça um programa que leia n caixas e seu peso, ao final, o
programa deve imprimir a quantidade de volumes, o peso total dos volumes e o peso
médio dos volumes.


Aqui está a solução em Rust:


fn main() {
    let mut resp = 0;
    let mut qtd_volumes = 0;
    let mut peso_total = 0.0;
    let mut peso_medio = 0.0;

    println!("Deseja cadastrar uma caixa? 1-SIM / 2-NAO");
    scanf!("{}", &resp);

    while resp == 1 {
        qtd_volumes += 1;
        println!("Informe o peso da caixa: ");
        scanf!("{}", &peso);
        peso_total += peso;
        println!("Deseja cadastrar uma caixa? 1-SIM / 2-NAO");
        scanf!("{}", &resp);
    }
    peso_medio = peso_total / qtd_volumes as f64;
    println!("Quantidade de volumes: {}", qtd_volumes);
    println!("Peso total dos volumes: {}", peso_total);
    println!("Peso médio dos volumes: {}", peso_medio);
}
Aqui está uma explicação de cada linha do código:

A função main é a função principal do programa em Rust. Todo código Rust deve ter uma função main.
As linhas 2 a 5 são declarações das variáveis necessárias para o programa. A variável resp será usada para controlar a condição do laço. A variável qtd_volumes será usada para contar a quantidade de volumes, a variável peso_total será usada para armazenar o peso total dos volumes e a variável peso_medio será usada para armazenar o peso médio dos volumes.
A linha 6 é uma chamada da função println!, que imprime uma mensagem na tela.
A linha 7 é uma chamada da função scanf!, que lê um valor do usuário.
A linha 9 inicia um laço while que será executado enquanto a variável resp for igual a 1.
A linha 10 adiciona 1 à variável qtd_volumes.
A linha 11 é uma chamada da função println!, que imprime uma mensagem na tela.
A linha 12 é uma chamada da função scanf!, que lê um valor do usuário e o armazena na variável peso.
A linha 13 adiciona o valor da variável peso à variável peso_total.
A linha 14 é uma chamada da função println!, que imprime uma mensagem na


Exercicio de exemplo

Num frigorífico existem 90 bois. Cada boi traz preso em seu pescoço um cartão contendo
seu número de identificação e seu peso. Faça um programa que imprima a identificação
e o peso do boi mais gordo e do boi mais magro (supondo que não haja empates).

fn main() {
    let mut id_boi: i32;
    let mut id_boi_gordo: i32 = 0;
    let mut id_boi_magro: i32 = 0;
    let mut peso_boi: f32;
    let mut boi_gordo: f32 = 0.0;
    let mut boi_magro: f32 = 0.0;

    for i in 1..=90 {
        println!("Informe a identificação do boi:");
        id_boi = read!();
        println!("Informe o peso do boi:");
        peso_boi = read!();

        if peso_boi > boi_gordo {
            id_boi_gordo = id_boi;
            boi_gordo = peso_boi;
        }
        if peso_boi < boi_magro || i == 1 {
            id_boi_magro = id_boi;
            boi_magro = peso_boi;
        }
    }

    println!("Identificação do boi mais gordo: {}", id_boi_gordo);
    println!("Peso do boi mais gordo: {}", boi_gordo);
    println!("Identificação do boi mais magro: {}", id_boi_magro);
    println!("Peso do boi mais magro: {}", boi_magro);
}




Agora, explicarei cada linha do código:

fn main() {: Esta linha define o início da função principal do programa. Todas as instruções a seguir estarão dentro da função main.
let mut id_boi: i32;: Declara a variável id_boi como um inteiro mutável.
let mut id_boi_gordo: i32 = 0;: Declara a variável id_boi_gordo como um inteiro mutável e inicializa-a com o valor 0.
let mut id_boi_magro: i32 = 0;: Declara a variável id_boi_magro como um inteiro mutável e inicializa-a com o valor 0.
let mut peso_boi: f32;: Declara a variável peso_boi como um ponto flutuante de 32 bits mutável.
let mut boi_gordo: f32 = 0.0;: Declara a variável boi_gordo como um ponto flutuante de 32 bits mutável e inicializa-a com o valor 0.0.
let mut boi_magro: f32 = 0.0;: Declara a variável `












Exercícios

Os exercícios desta lista foram Adaptados de Lopes e Garcia (2002, p. 136-226).

Faça um programa em Rust que imprima todos os números de 1 até 100.

fn main() {
    for i in 1..101 {
        println!("{}", i);
    }
}
Explicação:

fn main() é a função principal em Rust. Todos os programas em Rust precisam ter uma função main.
for i in 1..101 é uma estrutura de iteração que irá iterar de 1 até 100 (inclusive). A variável i é criada para armazenar cada valor da iteração.
println!("{}", i) é uma função que imprime na saída padrão. O {} é um espaço reservado para um valor, que neste caso é a variável i.


Faça um programa que imprima todos os números pares de 100 até 1.


fn main() {
    for i in (1..101).rev() {
        if i % 2 == 0 {
            println!("{}", i);
        }
    }
}
Explicação das linhas:

fn main(): essa é a função principal do programa, o ponto de entrada para a execução do código.
for i in (1..101).rev(): essa linha inicia uma iteração de loop através de um intervalo de números de 1 a 100 (inclusive), em ordem reversa. Isso significa que o loop começa no número 100 e decrementa o contador i a cada iteração até chegar a 1.
if i % 2 == 0: essa linha verifica se o número atualmente armazenado em i é par. O operador módulo % retorna o resto da divisão de i por 2. Se o resto for zero, então i é um número par.
println!("{}", i): essa linha imprime o número atualmente armazenado em i na saída padrão. O símbolo {} é um marcador de posição para um valor que será inserido na saída da string. No caso, o valor é o próprio número armazenado em i.
}: essa chave fecha o corpo do loop for.

3. Faça um programa que imprima os múltiplos de 5, no intervalo de 1 até 500.

fn main() {
    // Define o intervalo de 1 até 500
    for i in 1..501 {
        // Verifica se o número é múltiplo de 5
        if i % 5 == 0 {
            // Imprime o número
            println!("{}", i);
        }
    }
}

Vou explicar cada linha da solução:

fn main() {: esta linha define o início da função principal do programa.

for i in 1..501 {: esta linha inicia uma estrutura de iteração (loop) que vai repetir o código dentro das chaves ({}) para cada número no intervalo de 1 até 500 (inclusive). A variável i vai ser usada para armazenar o número atual da iteração.

if i % 5 == 0 {: esta linha verifica se o número atual é múltiplo de 5. O operador % é o operador de módulo, que retorna o resto da divisão inteira de um número por outro. Se o resto da divisão de i por 5 for igual a zero, significa que i é múltiplo de 5.

println!("{}", i);: esta linha imprime o número atual da iteração. O println! é uma função que imprime uma string (texto) na saída padrão (tela). O {} é um "marcador de posição" que é substituído pelo valor da variável i quando a função é chamada.

}: esta chave fecha a estrutura de iteração (loop).

}: esta chave fecha a função principal do programa.


===============================================================
4. Faça um programa em Rust que permita entrar com o nome, a idade e o sexo de 20
pessoas. O programa deve imprimir o nome da pessoa se ela for do sexo masculino
e tiver mais de 21 anos.

Aqui está a solução em Rust:


fn main() {
    for i in 0..20 {
        println!("Entre com o nome da pessoa {}:", i+1);
        let mut nome = String::new();
        std::io::stdin().read_line(&mut nome).expect("Falha ao ler o nome");

        println!("Entre com a idade da pessoa {}:", i+1);
        let mut idade = String::new();
        std::io::stdin().read_line(&mut idade).expect("Falha ao ler a idade");
        let idade: i32 = idade.trim().parse().expect("Por favor, digite um número inteiro");

        println!("Entre com o sexo da pessoa {} (M ou F):", i+1);
        let mut sexo = String::new();
        std::io::stdin().read_line(&mut sexo).expect("Falha ao ler o sexo");
        let sexo: char = sexo.trim().parse().expect("Por favor, digite 'M' ou 'F'");

        if sexo == 'M' && idade > 21 {
            println!("Nome: {}", nome);
        }
    }
}
Explicação:

A primeira linha define a função main, que é o ponto de entrada do programa em Rust.
A seguir, temos um loop for que itera de 0 a 19 (inclusive). Isso significa que o código dentro do loop será executado 20 vezes.
Na primeira linha dentro do loop, usamos a macro println! para imprimir uma mensagem solicitando o nome da pessoa. O {} é um placeholder que será substituído pelo valor de i+1.
Em seguida, declaramos uma variável mutável nome do tipo String e a inicializamos como uma string vazia. Em seguida, usamos a função read_line da biblioteca std::io para ler uma linha de entrada do usuário e armazená-la em nome. O método expect é usado para tratar o erro de leitura (por exemplo, se o usuário pressionar CTRL+C para interromper o programa).
As próximas três linhas são similares às anteriores, mas solicitam a idade e o sexo da pessoa em vez do nome. A idade é lida como uma string e, em seguida, convertida para um número inteiro usando o método parse e o tipo i32. O sexo é lido como uma string e, em seguida, convertido para um caractere usando o método parse e o tipo char.

===============================================================================
5. Sabendo-se que a unidade lógica e aritmética calcula o produto através de somas
sucessivas, crie um programa que calcule o produto de dois números inteiros
lidos. Suponha que os números lidos sejam positivos e que o multiplicando seja
menor do que o multiplicador.

Aqui está um exemplo de solução em Rust para o exercício proposto:


fn main() {
    // Lê os dois números inteiros
    println!("Informe o multiplicando: ");
    let mut multiplicando = String::new();
    std::io::stdin().read_line(&mut multiplicando).unwrap();
    let multiplicando: i32 = multiplicando.trim().parse().unwrap();

    println!("Informe o multiplicador: ");
    let mut multiplicador = String::new();
    std::io::stdin().read_line(&mut multiplicador).unwrap();
    let multiplicador: i32 = multiplicador.trim().parse().unwrap();

    // Inicializa a variável resultado com o valor do multiplicando
    let mut resultado = multiplicando;

    // Realiza as somas sucessivas enquanto o multiplicando for maior do que 1
    let mut contador = multiplicando - 1;
    while contador > 0 {
        resultado += multiplicador;
        contador -= 1;
    }

    // Imprime o resultado
    println!("O produto é {}", resultado);
}
Explicação:

A primeira etapa é ler os dois números inteiros do usuário, usando a função read_line da biblioteca padrão std::io. O método read_line lê uma linha do terminal e armazena o resultado em uma variável String.
Em seguida, usamos o método trim para remover os espaços em branco no início e no final da string lida, e o método parse para converter a string em um inteiro (i32).
Depois de ler e converter os dois números, inicializamos a variável resultado com o valor do multiplicando.
Em seguida, criamos uma variável contador inicializada com o valor do multiplicando menos 1, pois queremos realizar as somas sucessivas enquanto o multiplicando for maior do que 1.
Usamos um loop while para iterar enquanto o contador for maior do que 0. Dentro do loop, adicionamos o multiplicador ao resultado e decrementamos o contador em 1.
Quando o loop acaba, o resultado final é armazenado na variável resultado, que é então impresso com a função println.

=================================================
6. Crie um programa em Rust que imprima os 20 primeiros termos da série de Fibo-
nacci.
Observação: os dois primeiros termos desta série são 1 e 1 e os demais são gerados
a partir da soma dos anteriores. Exemplo:
• 1 + 1 = 2, terceiro termo;
• 1 + 2 = 3, quarto termo, etc.

Aqui está a solução em Rust:


fn main() {
    // Declara as variáveis para armazenar os termos da série
    let mut n1: u32 = 1;
    let mut n2: u32 = 1;
    let mut n3: u32 = 0;

    // Imprime os dois primeiros termos da série
    println!("1");
    println!("1");

    // Itera 20 vezes para calcular os demais termos da série
    for _i in 0..20 {
        // Calcula o próximo termo da série
        n3 = n1 + n2;
        // Imprime o próximo termo da série
        println!("{}", n3);
        // Atualiza os valores de n1 e n2 para o próximo cálculo
        n1 = n2;
        n2 = n3;
    }
}
Agora, vamos explicar cada linha do código:

A função main é a função principal do programa em Rust. Todas as outras funções são chamadas a partir dela.

As linhas 4 e 5 declaram as variáveis n1 e n2 como sendo do tipo u32 (unsigned 32-bit integer) e inicializam-nas com os valores 1. A variável n3 é declarada como sendo do tipo u32 e inicializada com o valor 0. Essas variáveis serão usadas para armazenar os termos da série de Fibonacci.

As linhas 7 e 8 imprimem os dois primeiros termos da série de Fibonacci, que são 1 e 1.

A linha 10 inicia uma estrutura de iteração for que irá iterar 20 vezes. A variável _i é uma variável de iteração que não é usada no corpo da iteração.

Na linha 12, o próximo termo da série é calculado como sendo a soma dos dois termos anteriores, armazenados nas variáveis n1 e n2. O resultado é armazenado na variável n3.

Na linha 14, o próximo termo da série é impresso.

Na linhas 16 e 17, os valores das variáveis n1 e n2 são atualizados para os valores armazenados nas variáveis n2 e n3, respectivamente. Isso permite que os próximos termos da série sejam calculados corretamente na próxima iteração.

Quando a iteração for é concluída, o programa termina.



=================================================================

7. Crie um programa em linguagem Rust que permita entrar com o nome, a nota da
prova 1 e da prova 2 de 15 alunos. Ao final, imprimir uma listagem, contendo:
nome, nota da prova 1, nota da prova 2, e média das notas de cada aluno. Ao final,
imprimir a média geral da turma.


Aqui está uma solução em linguagem Rust para o problema:


#include <stdio.h>

int main(void) {
  char nome[15][50];
  float nota1[15], nota2[15], media[15], mediaGeral = 0;

  // Entrada de dados
  for (int i = 0; i < 15; i++) {
    printf("Entre com o nome do aluno %d: ", i + 1);
    scanf("%s", nome[i]);
    printf("Entre com a nota da prova 1 do aluno %d: ", i + 1);
    scanf("%f", &nota1[i]);
    printf("Entre com a nota da prova 2 do aluno %d: ", i + 1);
    scanf("%f", &nota2[i]);
  }

  // Cálculo da média de cada aluno
  for (int i = 0; i < 15; i++) {
    media[i] = (nota1[i] + nota2[i]) / 2;
  }

  // Cálculo da média geral da turma
  for (int i = 0; i < 15; i++) {
    mediaGeral += media[i];
  }
  mediaGeral /= 15;

  // Impressão dos resultados
  printf("\nListagem de alunos:\n");
  for (int i = 0; i < 15; i++) {
    printf("Nome: %s\n", nome[i]);
    printf("Nota da prova 1: %.2f\n", nota1[i]);
    printf("Nota da prova 2: %.2f\n", nota2[i]);
    printf("Média: %.2f\n", media[i]);
    printf("\n");
  }
  printf("Média geral da turma: %.2f\n", mediaGeral);

  return 0;
}
Explicação do código:

A primeira linha inclui a biblioteca stdio.h, que fornece funções de entrada e saída, como printf e scanf.

As linhas seguintes declaram as variáveis que serão usadas no programa:

nome é um array de strings que armazenará os nomes dos alunos. Cada string tem tamanho máximo 50 caracteres.
nota1 e nota2 são arrays de floats que armazenarão as notas das provas 1 e 2, respectivamente.
media é um array de floats que armazenará a média das notas de cada aluno.
mediaGeral é uma variável do tipo float que armazenará a média geral da turma.
O primeiro laço for (linhas 9 a 15) é usado para














======================================================
8. Faça um programa que permita entrar com o nome e o salário bruto de 10 pessoas.
Após ler os dados, imprimir o nome e o valor da alíquota do imposto de renda
calculado conforme a tabela a seguir:
Salário
Salário menor que R$1300,00
Salário maior ou igual a R$1300,00 e menor que R$2300,00
Salário maior ou igual a R$2300,00
IRRF
Isento
10% do salário bruto
15% do salário bruto

Aqui está a solução em Rust:


fn main() {
    let mut nomes: Vec<String> = Vec::new();
    let mut salarios: Vec<f32> = Vec::new();

    for i in 0..10 {
        println!("Entre com o nome da pessoa {}:", i+1);
        let mut nome = String::new();
        std::io::stdin().read_line(&mut nome).expect("Falha ao ler nome");
        nomes.push(nome.trim().to_string());

        println!("Entre com o salário bruto da pessoa {}:", i+1);
        let mut salario = String::new();
        std::io::stdin().read_line(&mut salario).expect("Falha ao ler salário");
        salarios.push(salario.trim().parse().expect("Falha ao converter salário para float"));
    }

    for i in 0..10 {
        let salario = salarios[i];
        let nome = &nomes[i];
        let irrf: f32;

        if salario < 1300.0 {
            irrf = 0.0;
        } else if salario < 2300.0 {
            irrf = salario * 0.1;
        } else {
            irrf = salario * 0.15;
        }

        println!("Nome: {}\nImposto de Renda: {}", nome, irrf);
    }
}
Explicação:

A primeira coisa a ser feita é declarar duas listas: uma para armazenar os nomes das pessoas e outra para armazenar os salários brutos. Essas listas são declaradas como Vec<String> e Vec<f32>, respectivamente.

Em seguida, usamos um loop for para ler os dados de cada pessoa. Para ler o nome, usamos a função read_line da biblioteca std::io, que lê uma linha inteira do teclado e armazena em uma string. Em seguida, adicionamos o nome lido à lista de nomes. Para ler o salário, usamos a mesma função para ler uma linha do teclado, mas precisamos converter o valor lido de string para float para poder armazenar na lista de salários. Usamos a função parse da string para fazer essa conversão.

Depois de ler todos os dados, usamos outro loop for para calcular e imprimir o imposto de renda de cada pessoa. Para cada pessoa, verificamos qual a faixa de salário em que ela se encaixa, de acordo com a tabela fornecida, e calculamos o imposto de renda a ser pago. Por fim, imprimim

===================================================================

9. No dia da estréia do filme "Procurando Dory", uma grande emissora de TV reali-
zou uma pesquisa logo após o encerramento do filme. Cada espectador respondeu
a um questionário no qual constava sua idade e a sua opinião em relação ao filme:
excelente - 3; bom - 2; regular - 1. Criar um programa que receba a idade e a
opinião de 20 espectadores, calcule e imprima:
• A média das idades das pessoas que responderam excelente;
• A quantidade de pessoas que responderam regular;
• A percentagem de pessoas que responderam bom entre todos os expectado-
res analisados.

Aqui está a solução em Rust:


fn main() {
    let mut excelente_soma = 0;
    let mut excelente_cont = 0;
    let mut regular_cont = 0;
    let mut bom_cont = 0;

    for i in 0..20 {
        println!("Informe a idade do espectador {}:", i+1);
        let mut idade = String::new();
        std::io::stdin().read_line(&mut idade).expect("Falha ao ler a idade");
        let idade: i32 = idade.trim().parse().expect("Por favor, insira um número inteiro");

        println!("Informe a opinião do espectador {}: (excelente - 3, bom - 2, regular - 1)", i+1);
        let mut opiniao = String::new();
        std::io::stdin().read_line(&mut opiniao).expect("Falha ao ler a opinião");
        let opiniao: i32 = opiniao.trim().parse().expect("Por favor, insira um número inteiro");

        if opiniao == 3 {
            excelente_soma += idade;
            excelente_cont += 1;
        } else if opiniao == 1 {
            regular_cont += 1;
        } else if opiniao == 2 {
            bom_cont += 1;
        }
    }

    let media_excelente = excelente_soma as f32 / excelente_cont as f32;
    println!("A média das idades das pessoas que responderam excelente é {:.2}", media_excelente);
    println!("A quantidade de pessoas que responderam regular é {}", regular_cont);
    let percentagem_bom = (bom_cont as f32 / 20 as f32) * 100 as f32;
    println!("A percentagem de pessoas que responderam bom entre todos os expectadores analisados é {:.2}%", percentagem_bom);
}
Explicando cada linha:

Declaramos três variáveis para armazenar a soma das idades das pessoas que responderam excelente, a quantidade de pessoas que responderam regular e a quantidade de pessoas que responderam bom. Inicialmente, todas são inicializadas com zero.
Iniciamos um loop for que vai iterar de 0 até 19 (já que queremos ler as informações de 20 espectadores).
Pedimos a idade do espectador atual usando a função println! para imprimir a mensagem na tela e a função std::io::stdin().read_line para ler a entrada do usuário. A idade é lida como uma string e depois convertida para um inteiro com o método parse.


==========================================================================


10. Em um campeonato Europeu de Volleyball, se inscreveram 30 países. Sabendo-se
que na lista oficial de cada país consta, além de outros dados, peso e idade de 12
jogadores, crie um programa que apresente as seguintes informações:
• O peso médio e a idade média de cada um dos times;
• O atleta mais pesado de cada time;
• O atleta mais jovem de cada time;
• O peso médio e a idade média de todos os participantes.



==================================================================================
11. Construa um programa em Rust que leia vários números e informe quantos números
entre 100 e 200 foram digitados. Quando o valor 0 (zero) for lido, o algoritmo
deverá cessar sua execução.


Aqui está a solução em Rust:


fn main() {
    let mut num = 0; // Declara a variável `num` e inicializa com o valor 0
    let mut count = 0; // Declara a variável `count` e inicializa com o valor 0

    // Loop infinito
    loop {
        println!("Insira um número: ");
        // Lê um número digitado pelo usuário e armazena na variável `num`
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).expect("Falha ao ler entrada");
        num = input.trim().parse().expect("Falha ao converter para inteiro");

        // Verifica se o número lido é igual a 0. Se for, sai do loop
        if num == 0 {
            break;
        }

        // Verifica se o número lido está entre 100 e 200 (inclusive)
        if num >= 100 && num <= 200 {
            count += 1; // Incrementa o contador
        }
    }

    // Exibe o resultado final
    println!("Foram digitados {} números entre 100 e 200", count);
}
Explicação:

A primeira linha declara a variável num e a inicializa com o valor 0.
A segunda linha declara a variável count e a inicializa com o valor 0. Esta variável será usada para contar o número de números entre 100 e 200 digitados pelo usuário.
Em seguida, um loop infinito é iniciado. O loop só será interrompido quando o usuário digitar o valor 0.
Dentro do loop, o programa exibe uma mensagem solicitando que o usuário digite um número. Em seguida, o número digitado é lido e armazenado na variável num.
Em seguida, é verificado se o número lido é igual a 0. Se for, o loop é interrompido usando a instrução break.
Se o número lido não for igual a 0, é verificado se ele está entre 100 e 200 (inclusive). Se sim, o contador é incrementado usando a instrução count += 1.
Quando o loop é interrompido, o programa exibe o resultado final, que é o número de números entre 100 e 200 digitados pelo usuário.

=========================================================================================================
12. Dado um país A, com 5 milhões de habitantes e uma taxa de natalidade de 3% ao
ano, e um país B com 7 milhões de habitantes e uma taxa de natalidade de 2% ao
ano, fazer um programa que calcule e imprima o tempo necessário para que a
população do país A ultrapasse a população do país B.



fn main() {
    // Define as variáveis iniciais
    let mut populacao_a = 5_000_000;
    let mut populacao_b = 7_000_000;
    let taxa_natalidade_a = 0.03;
    let taxa_natalidade_b = 0.02;
    let mut anos = 0;

    // Loop até que a população do país A seja maior que a do país B
    while populacao_a <= populacao_b {
        // Incrementa o número de anos
        anos += 1;

        // Calcula o aumento da população para o próximo ano
        populacao_a += (populacao_a as f64 * taxa_natalidade_a) as i32;
        populacao_b += (populacao_b as f64 * taxa_natalidade_b) as i32;
    }

    // Imprime o resultado
    println!("Serão necessários {} anos para que a população do país A ultrapasse a população do país B", anos);
}

Vamos explicar cada linha do código:

fn main() {: inicia a definição da função principal do programa.

let mut populacao_a = 5_000_000;: define uma variável populacao_a com o valor inicial de 5 milhões de habitantes. Ela é marcada como mutável, o que significa que o seu valor pode ser alterado durante a execução do programa.

let mut populacao_b = 7_000_000;: define uma variável populacao_b com o valor inicial de 7 milhões de habitantes. Ela também é marcada como mutável.

let taxa_natalidade_a = 0.03;: define uma variável taxa_natalidade_a com o valor da taxa de natalidade do país A, que é de 3%.

let taxa_natalidade_b = 0.02;: define uma variável taxa_natalidade_b com o valor da taxa de natalidade do país B, que é de 2%.

let mut anos = 0;: define uma variável anos que contabiliza o número de anos que passaram desde o início do loop. Ela também é marcada como mutável.

while populacao_a <= populacao_b {: inicia um loop que continuará enquanto a população do país A for menor ou igual à população do país B.

anos += 1;: incrementa o nú

===============================================================================================
13. Uma empresa de fornecimento de energia elétrica faz a leitura mensal dos medi-
dores de consumo. Para cada consumidor, são digitados os seguintes dados:
• número do consumidor
• quantidade de kWh consumidos durante o mês
• tipo (código) do consumidor
1-residencial, preço em reais por kWh = 0,3
2-comercial, preço em reais por kWh = 0,5
3-industrial, preço em reais por kWh = 0,7
Os dados devem ser lidos até que seja encontrado o consumidor com número 0
(zero). O programa deve calcular e imprimir:
• O custo total para cada consumidor
• O total de consumo para os três tipos de consumidor
• A média de consumo dos tipos 1 e 2

fn main() {
    // Variáveis para armazenar o total de consumo e o custo total para cada tipo de consumidor
    let mut total_consumo_residencial = 0.0;
    let mut total_custo_residencial = 0.0;
    let mut total_consumo_comercial = 0.0;
    let mut total_custo_comercial = 0.0;
    let mut total_consumo_industrial = 0.0;
    let mut total_custo_industrial = 0.0;

    // Loop infinito
    loop {
        // Pedir o número do consumidor
        println!("Digite o número do consumidor (0 para sair):");
        let numero_consumidor: i32 = read!();

        // Se o número do consumidor for 0, sair do loop
        if numero_consumidor == 0 {
            break;
        }

        // Pedir a quantidade de kWh consumidos durante o mês
        println!("Digite a quantidade de kWh consumidos durante o mês:");
        let quantidade_kwh: f64 = read!();

        // Pedir o tipo de consumidor
        println!("Digite o tipo de consumidor (1 para residencial, 2 para comercial, 3 para industrial):");
        let tipo_consumidor: i32 = read!();

        // Calcular o custo total para o consumidor
        let mut custo_total = 0.0;
        match tipo_consumidor {
            1 => {
                // Residencial, preço em reais por kWh = 0,3
                custo_total = quantidade_kwh * 0.3;
                total_consumo_residencial += quantidade_kwh;
                total_custo_residencial += custo_total;
            },
            2 => {
                // Comercial, preço em reais por kWh = 0,5
                custo_total = quantidade_kwh * 0.5;
                total_consumo_comercial += quantidade_kwh;
                total_custo_comercial += custo_total;
            },
            3 => {
                // Industrial, preço em reais por kWh = 0,7
                custo_total = quantidade_kwh * 0.7;
                total_consumo_industrial += quantidade_kwh;
                total_custo_industrial += custo_total;
            },
            // Se o tipo de consumidor for inválido, imprimir uma mensagem de erro e continuar o loop
            _ => {
                println!("Tipo de consumidor inválido!");
                continue;
            }
        }

        // Imprimir o custo total para o consumidor
        println!("O custo total para o consumidor é R$ {}", custo_total);
    }

    // Imprimir o total de consumo para cada tipo de consumidor
println!("Total de consumo residencial: {} kWh", total_consumo_residencial);
println!("Total de consumo comercial: {} kWh", total_consumo_comercial);
println!("Total de consumo industrial: {} kWh", total_consumo_industrial);

// Imprimir o total de custo para cada tipo de consumidor
println!("Total de custo residencial: R$ {}", total_custo_residencial);
println!("Total de custo comercial: R$ {}", total_custo_comercial);
println!("Total de custo industrial: R$ {}", total_custo_industrial);

// Calcular e imprimir a média de consumo dos tipos 1 e 2
let media_consumo = (total_consumo_residencial + total_consumo_comercial) / 2.0;
println!("Média de consumo dos tipos 1 e 2: {} kWh", media_consumo);
}


=======================================================================
14. Faça um programa que leia vários números inteiros e apresente o fatorial de cada
número. O algoritmo encerra quando se digita um número menor do que 1.

fn main() {
    // Loop infinito
    loop {
        // Pede ao usuário para digitar um número
        println!("Digite um número inteiro: ");

        // Lê o número digitado pelo usuário e armazena em uma variável
        let mut numero = String::new();
        std::io::stdin().read_line(&mut numero).expect("Falha ao ler o número");

        // Tenta converter o número digitado pelo usuário para um inteiro
        let numero: i32 = match numero.trim().parse() {
            Ok(num) => num,
            Err(_) => continue, // Se a conversão falhar, volta para o início do loop
        };

        // Se o número for menor que 1, encerra o programa
        if numero < 1 {
            break;
        }

        // Inicializa uma variável para armazenar o fatorial
        let mut fatorial = 1;

        // Loop para calcular o fatorial do número
        for i in 2..=numero {
            fatorial *= i;
        }

        // Exibe o resultado
        println!("O fatorial de {} é {}", numero, fatorial);
    }
}

=================================================

15. Faça um programa em Rust que permita entrar com a idade de várias pessoas e
imprima:
• total de pessoas com menos de 21 anos
• total de pessoas com mais de 50 anos

fn main() {
    let mut menos_de_21 = 0;
    let mut mais_de_50 = 0;

    loop {
        println!("Entre com a idade de uma pessoa (digite um número negativo para encerrar o programa):");

        let mut idade = String::new();
        std::io::stdin().read_line(&mut idade).expect("Falha ao ler a entrada");

        let idade: i32 = match idade.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        if idade < 0 {
            break;
        } else if idade < 21 {
            menos_de_21 += 1;
        } else if idade > 50 {
            mais_de_50 += 1;
        }
    }

    println!("Total de pessoas com menos de 21 anos: {}", menos_de_21);
    println!("Total de pessoas com mais de 50 anos: {}", mais_de_50);
}


=================================================

16. Sabendo-se que a unidade lógica e aritmética calcula a divisão por meio de sub-
trações sucessivas, criar um algoritmo que calcule e imprima o resto da divisão de
números inteiros lidos. Para isso, basta subtrair o divisor ao dividendo, sucessiva-
mente, até que o resultado seja menor do que o divisor. O número de subtrações
realizadas corresponde ao quociente inteiro e o valor restante da subtração corres-
ponde ao resto. Suponha que os números lidos sejam positivos e que o dividendo
seja maior do que o divisor.

Aqui está um exemplo de como você poderia resolver este problema usando estruturas de iteração em Rust:


fn main() {
    // Lê o dividendo e o divisor do usuário
    let mut dividendo = String::new();
    println!("Insira o dividendo:");
    std::io::stdin().read_line(&mut dividendo).expect("Falha ao ler a entrada");

    let mut divisor = String::new();
    println!("Insira o divisor:");
    std::io::stdin().read_line(&mut divisor).expect("Falha ao ler a entrada");

    // Converte as entradas para inteiros
    let dividendo: i32 = dividendo.trim().parse().expect("Por favor, insira um número inteiro válido para o dividendo");
    let divisor: i32 = divisor.trim().parse().expect("Por favor, insira um número inteiro válido para o divisor");

    // Inicializa as variáveis de contagem de subtrações e resultado
    let mut contagem_subtracoes = 0;
    let mut resultado = dividendo;

    // Enquanto o resultado for maior ou igual ao divisor, realiza a subtração e incrementa a contagem de subtrações
    while resultado >= divisor {
        resultado -= divisor;
        contagem_subtracoes += 1;
    }

    // Imprime o quociente e o resto
    println!("Quociente: {}", contagem_subtracoes);
    println!("Resto: {}", resultado);
}

=================================================

17. Crie um programa em Rust que possa ler um conjunto de pedidos de compra e
calcule o valor total da compra. Cada pedido é composto pelos seguintes campos:
• número de pedido
• data do pedido (dia, mês, ano)
• preço unitário
• quantidade
O programa deverá processar novos pedidos até que o usuário digite 0 (zero)
como número do pedido.

use std::io;

fn main() {
    println!("Insira o número do pedido (digite 0 para sair):");

    let mut numero_pedido = String::new();

    io::stdin().read_line(&mut numero_pedido).expect("Falha ao ler a entrada");

    let numero_pedido: i32 = numero_pedido.trim().parse().expect("Por favor, insira um número válido");

    let mut valor_total = 0;

    while numero_pedido != 0 {
        println!("Insira a data do pedido (dia, mês, ano):");

        let mut data_pedido = String::new();

        io::stdin().read_line(&mut data_pedido).expect("Falha ao ler a entrada");

        let data_pedido: Vec<i32> = data_pedido
            .split_whitespace()
            .map(|s| s.parse().expect("Por favor, insira um número válido"))
            .collect();

        println!("Insira o preço unitário:");

        let mut preco_unitario = String::new();

        io::stdin().read_line(&mut preco_unitario).expect("Falha ao ler a entrada");

        let preco_unitario: i32 = preco_unitario
            .trim()
            .parse()
            .expect("Por favor, insira um número válido");

        println!("Insira a quantidade:");

        let mut quantidade = String::new();

        io::stdin().read_line(&mut quantidade).expect("Falha ao ler a entrada");

        let quantidade: i32 = quantidade
            .trim()
            .parse()
            .expect("Por favor, insira um número válido");

        valor_total += preco_unitario * quantidade;

        println!("Insira o número do próximo pedido (digite 0 para sair):");

        numero_pedido = String::new();

        io::stdin().read_line(&mut numero_pedido).expect("Falha ao ler a entrada");

        numero_pedido = numero_pedido.trim().parse().expect("Por favor, insira um número válido");
    }

    println!("Valor total da compra: {}", valor_total);
}


=================================================

18. Uma pousada estipulou o preço para a diária em R$30,00 e mais uma taxa de
serviços diários de:
• R$15,00, se o número de dias for menor que 10;
• R$8,00, se o número de dias for maior ou igual a 10;
Faça um programa que imprima o nome, a conta e o número da conta de cada
cliente e ao final o total faturado pela pousada.
O programa deverá ler novos clientes até que o usuário digite 0 (zero) como
número da conta.

fn main() {
    let mut total_faturado: f32 = 0.0; // variável para armazenar o total faturado pela pousada

    // loop para ler os dados dos clientes enquanto o usuário não digitar 0 (zero) como número da conta
    loop {
        println!("Insira o número da conta do cliente (digite 0 para sair):");
        let mut numero_conta = String::new();
        std::io::stdin().read_line(&mut numero_conta).expect("Falha ao ler a entrada");

        let numero_conta: u32 = match numero_conta.trim().parse() {
            Ok(numero) => numero,
            Err(_) => continue,
        };

        if numero_conta == 0 {
            break;
        }

        println!("Insira o nome do cliente:");
        let mut nome = String::new();
        std::io::stdin().read_line(&mut nome).expect("Falha ao ler a entrada");
        let nome = nome.trim();

        println!("Insira o número de dias que o cliente ficou hospedado:");
        let mut dias = String::new();
        std::io::stdin().read_line(&mut dias).expect("Falha ao ler a entrada");
        let dias: u32 = match dias.trim().parse() {
            Ok(dias) => dias,
            Err(_) => continue,
        };

        let taxa_servicos = if dias < 10 { 15.0 } else { 8.0 }; // calcula a taxa de serviços de acordo com o número de dias
        let conta = 30.0 + taxa_servicos; // calcula o valor da conta do cliente

        println!("Nome do cliente: {}", nome);
        println!("Conta do cliente: R$ {:.2}", conta);
        println!("Número da conta: {}", numero_conta);
        println!();

        total_faturado += conta; // adiciona o valor da conta do cliente ao total faturado
    }

    println!("Total faturado pela pousada: R$ {:.2}", total_faturado);
}




===============================================
19. Em uma Universidade, os alunos das turmas de informática fizeram uma prova
de algoritmos. Cada turma possui um número de alunos. Criar um programa que
imprima:
• quantidade de alunos aprovados;
• média de cada turma;
• percentual de reprovados.
Obs.: Considere aprovado com nota >= 7.0

fn main() {
    // Número de turmas
    let num_turmas = 2;

    // Variaveis para armazenar os resultados finais
    let mut qtd_aprovados = 0;
    let mut media_turmas = 0.0;
    let mut percentual_reprovados = 0.0;

    // Iterar pelas turmas
    for i in 0..num_turmas {
        // Número de alunos da turma
        let num_alunos = 3;

        // Variaveis para armazenar os resultados da turma atual
        let mut qtd_aprovados_turma = 0;
        let mut soma_notas = 0.0;

        // Iterar pelos alunos
        for j in 0..num_alunos {
            // Nota do aluno
            let nota = 6.5;

            // Verificar se o aluno foi aprovado
            if nota >= 7.0 {
                qtd_aprovados += 1;
                qtd_aprovados_turma += 1;
            }

            // Adicionar a nota à soma das notas
            soma_notas += nota;
        }

        // Calcular a média da turma
        let media_turma = soma_notas / num_alunos as f64;

        // Adicionar a média da turma à média geral
        media_turmas += media_turma;

        // Calcular o percentual de reprovados da turma
        let percentual_reprovados_turma = (num_alunos - qtd_aprovados_turma) as f64 / num_alunos as f64;

        // Adicionar o percentual de reprovados da turma ao percentual geral
        percentual_reprovados += percentual_reprovados_turma;
    }

    // Calcular a média geral
    media_turmas /= num_turmas as f64;

    // Calcular o percentual de reprovados geral
    percentual_reprovados /= num_turmas as f64;

    // Imprimir os resultados
    println!("Quantidade de aprovados: {}", qtd_aprovados);
    println!("Média das turmas: {}", media_turmas);
    println!("Percentual de reprovados: {}", percentual_reprovados);
}

===================================================================================






=======================================================================

20. Uma pesquisa de opinião realizada no Rio de Janeiro, teve as seguintes perguntas:
• Qual o seu time de coração?
1-Fluminense;
2-Botafogo;
3-Vasco;
4-Flamengo;
5-Outros
• Onde você mora?
1-RJ;
2-Niterói;
3-Outros
• Qual o seu salário?
Faça um programa que imprima:
• o número de torcedores por clube;
• a média salarial dos torcedores do Botafogo;
• o número de pessoas moradoras do Rio de Janeiro, torcedores de outros clubes;
• o número de pessoas de Niterói torcedoras do Fluminense
Obs.: O programa encerra quando se digita 0 para o time.

use std::io; //importa a biblioteca de entrada e saída de dados

fn main() {
let mut fluminense = 0; //declara e inicializa a variável fluminense com o valor 0
let mut botafogo = 0; //declara e inicializa a variável botafogo com o valor 0
let mut vasco = 0; //declara e inicializa a variável vasco com o valor 0
let mut flamengo = 0; //declara e inicializa a variável flamengo com o valor 0
let mut outros = 0; //declara e inicializa a variável outros com o valor 0
let mut rio = 0; //declara e inicializa a variável rio com o valor 0
let mut niteroi = 0; //declara e inicializa a variável niteroi com o valor 0
let mut outros_cidades = 0; //declara e inicializa a variável outros_cidades com o valor 0
let mut salarios_botafogo = 0; //declara e inicializa a variável salarios_botafogo com o valor 0
let mut contador_botafogo = 0; //declara e inicializa a variável contador_botafogo com o valor 0
let mut niteroi_fluminense = 0; //declara e inicializa a variável niteroi_fluminense com o valor 0
let mut continuar = true; //declara e inicializa a variável continuar com o valor true


while continuar { //enquanto continuar for verdadeiro, execute o bloco de código abaixo
    println!("Qual o seu time de coração? (digite 0 para sair)");
    println!("1-Fluminense");
    println!("2-Botafogo");
    println!("3-Vasco");
    println!("4-Flamengo");
    println!("5-Outros");

    let mut time = String::new(); //declara e inicializa a variável time como uma string vazia

    io::stdin().read_line(&mut time) //lê a linha digitada pelo usuário e armazena em time
        .expect("Falha ao ler a entrada"); //em Rustaso de falha, exibe a mensagem de erro

    let time: u32 = match time.trim().parse() { //tenta converter a string em um valor inteiro
        Ok(num) => num, //se a conversão for bem sucedida, armazena o valor em time
        Err(_) => continue, //se a conversão falhar, volta para o início do loop
    };

    if time == 0 { //se o valor de time for 0, finaliza o loop
        continuar = false;
        continue;
    }

    println!("Onde você mora?");
    println!("1-RJ");
    println!("2-Niterói");
    println!("3-Outros");

let mut cidade = String::new(); //declara e inicializa a variável cidade como uma string vazia

io::stdin().read_line(&mut cidade) //lê a linha digitada pelo usuário e armazena em Rustidade
.expect("Falha ao ler a entrada"); //em Rustaso de falha, exibe a mensagem de erro

let cidade: u32 = match cidade.trim().parse() { //tenta converter a string em um valor inteiro
Ok(num) => num, //se a conversão for bem sucedida, armazena o valor em Rustidade
Err(_) => continue, //se a conversão falhar, volta para o início do loop
};

println!("Qual o seu salário?");

let mut salario = String::new(); //declara e inicializa a variável salario como uma string vazia

io::stdin().read_line(&mut salario) //lê a linha digitada pelo usuário e armazena em salario
.expect("Falha ao ler a entrada"); //em Rustaso de falha, exibe a mensagem de erro

let salario: u32 = match salario.trim().parse() { //tenta converter a string em um valor inteiro
Ok(num) => num, //se a conversão for bem sucedida, armazena o valor em salario
Err(_) => continue, //se a conversão falhar, volta para o início do loop
};

match time { //compara o valor de time
1 => fluminense += 1, //se for 1, incrementa o valor de fluminense em 1
2 => {
botafogo += 1; //se for 2, incrementa o valor de botafogo em 1
salarios_botafogo += salario; //soma o valor de salario ao valor de salarios_botafogo
contador_botafogo += 1; //incrementa o valor de contador_botafogo em 1
},
3 => vasco += 1, //se for 3, incrementa o valor de vasco em 1
4 => flamengo += 1, //se for 4, incrementa o valor de flamengo em 1
5 => outros += 1, //se for 5, incrementa o valor de outros em 1
_ => continue, //se for um valor diferente dos anteriores, volta para o início do loop
}

match cidade { //compara o valor de cidade
1 => {
if time != 1 { //se o time for diferente de 1 (Fluminense)
rio += 1; //incrementa o valor de rio em 1
}
},
2 => {
if time == 1 { //se o time for igual a 1 (Fluminense)
niteroi_fluminense += 1; //incrementa o valor de niteroi_fluminense em 1
}
niteroi += 1; //incrementa o valor de niteroi em 1
},
3 => outros_cidades += 1, //se for 3, incrementa o valor de outros_cidades em 1
_ => continue, //se for um valor diferente dos anteriores, volta para o início do loop
}
}

//imprime o número de torcedores por clube
println!("Número de torcedores do Fluminense: {}", fluminense);
println!("Número de torcedores do Botafogo: {}", botafogo);
println!("Número de torcedores do Vasco: {}", vasco);
println!("Número de torcedores do Flamengo: {}", flamengo);
println!("Número de torcedores de outros clubes: {}", outros);

if contador_botafogo > 0 { //se o contador de torcedores do Botafogo for maior que 0
//imprime a média salarial dos torcedores do Botafogo
println!("Média salarial dos torcedores do Botafogo: {}", salarios_botafogo / contador_botafogo);
}

//imprime o número de pessoas moradoras do Rio de Janeiro, torcedores de outros clubes
println!("Número de pessoas moradoras do Rio de Janeiro, torcedoras de outros clubes: {}", rio);

//imprime o número de pessoas de Niterói torcedoras do Fluminense
println!("Número de pessoas de Niterói torcedoras do Fluminense: {}", niteroi_fluminense);
}

==============================================================================
21. Em uma universidade cada aluno possui os seguintes dados:
• Renda pessoal;
• Renda familiar;
• Total gasto com alimentação;
• Total gasto com outras despesas;
Faça um programa que imprima a porcentagem dos alunos que gasta acima de
R$200,00 com outras despesas. O número de alunos com renda pessoal maior
que a renda familiar e a porcentagem gasta com alimentação e outras despesas
em relação às rendas pessoal e familiar.
Obs.: O programa encerra quando se digita 0 para a renda pessoal.

fn main() {
    let mut renda_pessoal = -1; // inicializa a variável de renda pessoal com um valor inválido
    let mut renda_familiar = 0; // inicializa a variável de renda familiar com 0
    let mut total_gasto_alimentacao = 0; // inicializa a variável de gasto com alimentação com 0
    let mut total_gasto_outras_despesas = 0; // inicializa a variável de gasto com outras despesas com 0
    let mut contador_alunos_renda_pessoal_maior = 0; // inicializa o contador de alunos com renda pessoal maior que renda familiar com 0
    let mut contador_alunos_gasto_outras_despesas_acima_200 = 0; // inicializa o contador de alunos com gasto com outras despesas acima de 200 com 0

    // loop principal para ler os dados de todos os alunos
    while renda_pessoal != 0 {
        println!("Informe a renda pessoal do aluno (digite 0 para encerrar):");
        renda_pessoal = ler_numero(); // lê a renda pessoal do aluno

        if renda_pessoal == 0 {
            // se a renda pessoal for 0, encerra o loop
            break;
        }

        println!("Informe a renda familiar do aluno:");
        renda_familiar = ler_numero(); // lê a renda familiar do aluno

        println!("Informe o total gasto com alimentação do aluno:");
        total_gasto_alimentacao = ler_numero(); // lê o total gasto com alimentação do aluno

        println!("Informe o total gasto com outras despesas do aluno:");
        total_gasto_outras_despesas = ler_numero(); // lê o total gasto com outras despesas do aluno

        if total_gasto_outras_despesas > 200 {
            // se o total gasto com outras despesas for maior que 200, incrementa o contador de alunos com gasto com outras despesas acima de 200
            contador_alunos_gasto_outras_despesas_acima_200 += 1;
        }

        if renda_pessoal > renda_familiar {
            // se a renda pessoal for maior que a renda familiar, incrementa o contador de alunos com renda pessoal maior que renda familiar
            contador_alunos_renda_pessoal_maior += 1;
        }
    }

    // imprime os resultados
    println!("Porcentagem de alunos que gasta acima de R$200,00 com outras despeses: {}%", (contador_alunos_gasto_outras_despesas_acima_200 as f32 / (contador_alunos_renda_pessoal_maior + contador_alunos_gasto_outras_despesas_acima_200) as f32) * 100.0);
println!("Número de alunos com renda pessoal maior que a renda familiar: {}", contador_alunos_renda_pessoal_maior);
println!("Porcentagem gasta com alimentação e outras despesas em relação às rendas pessoal e familiar: {}%", ((total_gasto_alimentacao + total_gasto_outras_despesas) as f32 / (renda_pessoal + renda_familiar) as f32) * 100.0);
}

// função para ler um número inteiro do teclado
fn ler_numero() -> i32 {
let mut numero = String::new(); // cria uma nova string vazia
std::io::stdin().read_line(&mut numero).expect("Falha ao ler número"); // lê uma linha do teclado e armazena na string
numero.trim().parse().expect("Falha ao converter número") // remove os espaços em branco da string e tenta converter para um inteiro
}

=======================================================================

22. Crie um programa que ajude o DETRAN a saber o total de recursos que foram
arrecadados com a aplicação de multas de trânsito.
O algoritmo deve ler as seguintes informações para cada motorista:
• número da carteira de motorista (de 1 a 4327);
• número de multas;
• valor de cada uma das multas.
Deve ser impresso o valor da dívida para cada motorista e ao final da leitura o
total de recursos arrecadados (somatório de todas as multas). O programa deverá
imprimir também o número da carteira do motorista que obteve o maior número
de multas.
Obs.: O programa encerra ao ler a carteira de motorista de valor 0.


fn main() {
    // Inicializar variáveis
    let mut num_carteira = 1;
    let mut num_multas = 0;
    let mut valor_multa = 0.0;
    let mut valor_total = 0.0;
    let mut maior_num_multas = 0;
    let mut carteira_mais_multas = 0;

    // Lê as informações do motorista até que a carteira seja 0
    while num_carteira != 0 {
        // Lê as informações do motorista
        println!("Digite o número da carteira de motorista (0 para sair):");
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).expect("Falha ao ler entrada");
        num_carteira = input.trim().parse().expect("Por favor, digite um número inteiro válido");

        if num_carteira == 0 {
            // Se a carteira for 0, sai do loop
            break;
        }

        println!("Digite o número de multas:");
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).expect("Falha ao ler entrada");
        num_multas = input.trim().parse().expect("Por favor, digite um número inteiro válido");

        println!("Digite o valor de cada multa:");
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).expect("Falha ao ler entrada");
        valor_multa = input.trim().parse().expect("Por favor, digite um número válido");

        // Calcula o valor total de multas para o motorista
        let valor_divida = num_multas as f64 * valor_multa;
        println!("O valor da dívida do motorista {} é de R$ {:.2}", num_carteira, valor_divida);

        // Atualiza o valor total de multas arrecadadas
        valor_total += valor_divida;

        // Verifica se o motorista tem o maior número de multas
        if num_multas > maior_num_multas {
            maior_num_multas = num_multas;
            carteira_mais_multas = num_carteira;
        }
    }

    // Imprime o valor total de multas arrecadadas e a carteira do motorista com o maior número de multas
    println!("O valor total de multas arrecadadas é de R$ {:.2}", valor_total);
    println!("O motorista com a carteira {} obteve o maior número de multas ({})", carteira_mais_multas, maior_num_multas);
}



Agora, explicarei cada linha do código:

1. `fn main()`: define a função principal do programa, onde o código será executado.
2. `let mut num_carteira = 1;`: declara e inicializa a variável `num_carteira` com o valor 1. Esta variável irá armazenar o número da carteira de motorista lido pelo programa.
3. `let mut num_multas = 0;`: declara e inicializa a variável `num_multas` com o valor 0. Esta variável irá armazenar o número de multas de um motorista.
4. `let mut valor_multa = 0.0;`: declara e inicializa a variável `valor_multa` com o valor 0.0. Esta variável irá armazenar o valor de cada multa de um motorista.
5. `let mut valor_total = 0.0;`: declara e inicializa a variável `valor_total` com o valor 0.0. Esta variável irá armazenar o valor total de multas arrecadadas pelo DETRAN.
6. `let mut maior_num_multas = 0;`: declara e inicializa a variável `maior_num_multas` com o valor 0. Esta variável irá armazenar o maior número de multas de um motorista.
7. `let mut carteira_mais_multas = 0;`: declara e inicializa a variável `carteira_mais_multas` com o valor 0. Esta variável irá armazenar o número da carteira do motorista que obteve o maior número de multas.
8. `while num_carteira != 0 {`: inicia um loop que será executado enquanto o valor da variável `num_carteira` for diferente de 0.
9. `let mut input = String::new();`: declara e inicializa uma variável `input` do tipo `String` com o valor vazio. Esta variável será usada para armazenar a entrada do usuário.
10. `std::io::stdin().read_line(&mut input).expect("Falha ao ler entrada");`: lê a entrada do usuário até que o usuário pressione a tecla Enter. O método `read_line` é usado para ler a entrada do usuário em uma `String` e o método `expect` é usado para tratar possíveis erros na leitura da entrada.
11. `num_carteira = input.trim().parse().expect("Por favor, digite um número inteiro válido");`: remove os espaços em branco no in

=======================================================================



23. Crie um programa que leia um conjunto de informações (nome, sexo, idade, peso
e altura) dos atletas que participaram de uma olimpíada, e informar:
• a atleta do sexo feminino mais alta;
• o atleta do sexo masculino mais pesado;
• a média de idade dos atletas.
Obs.: Deverão se lidos dados dos atletas até que seja digitado o nome @ para um
atleta.
Para resolver este exercício, consulte a aula 7 que aborda o tratamento de strings,
como comparação e atribuição de textos.



fn main() {
    // Declaração das variáveis
    let mut nome: String;
    let mut sexo: String;
    let mut idade: i32;
    let mut peso: f32;
    let mut altura: f32;

    // Atleta do sexo feminino mais alta
    let mut atleta_feminina_mais_alta = String::new();
    let mut altura_atleta_feminina_mais_alta = 0.0;

    // Atleta do sexo masculino mais pesado
    let mut atleta_masculino_mais_pesado = String::new();
    let mut peso_atleta_masculino_mais_pesado = 0.0;

    // Variáveis para calcular a média de idade
    let mut total_idade = 0;
    let mut num_atletas = 0;

    // Lê os dados dos atletas até que seja digitado o nome @
    loop {
        println!("Digite o nome do atleta:");
        nome = read_string();

        if nome == "@" {
            break;
        }

        println!("Digite o sexo do atleta (M ou F):");
        sexo = read_string();

        println!("Digite a idade do atleta:");
        idade = read_integer();

        println!("Digite o peso do atleta:");
        peso = read_float();

        println!("Digite a altura do atleta:");
        altura = read_float();

        // Verifica se o atleta é do sexo feminino e é mais alto que a atleta feminina mais alta até o momento
        if sexo == "F" && altura > altura_atleta_feminina_mais_alta {
            atleta_feminina_mais_alta = nome;
            altura_atleta_feminina_mais_alta = altura;
        }

        // Verifica se o atleta é do sexo masculino e é mais pesado que o atleta masculino mais pesado até o momento
        if sexo == "M" && peso > peso_atleta_masculino_mais_pesado {
            atleta_masculino_mais_pesado = nome;
            peso_atleta_masculino_mais_pesado = peso;
        }

        // Atualiza o total de idade e o número de atletas
        total_idade += idade;
        num_atletas += 1;
    }

    // Calcula e imprime a média de idade
    let media_idade = total_idade as f32 / num_atletas as f32;
    println!("Média de idade dos atletas: {}", media_idade);

    // Imprime o nome da atleta feminina mais alta e a altura dela
println!("Atleta feminina mais alta: {} ({}m)", atleta_feminina_mais_alta, altura_atleta_feminina_mais_alta);


// Imprime o nome do atleta masculino mais pesado e o peso dele
println!("Atleta masculino mais pesado: {} ({}kg)", atleta_masculino_mais_pesado, peso_atleta_masculino_mais_pesado);
}

// Função para ler uma string do teclado
fn read_string() -> String {
let mut input = String::new();
std::io::stdin().read_line(&mut input).expect("Falha ao ler a entrada");
input.trim().to_string()
}

// Função para ler um número inteiro do teclado
fn read_integer() -> i32 {
let mut input = String::new();
std::io::stdin().read_line(&mut input).expect("Falha ao ler a entrada");
input.trim().parse().expect("Falha ao converter para inteiro")
}

// Função para ler um número float do teclado
fn read_float() -> f32 {
let mut input = String::new();
std::io::stdin().read_line(&mut input).expect("Falha ao ler a entrada");
input.trim().parse().expect("Falha ao converter para float")
}


=======================================================================




    
24. Faça um programa que calcule quantos litros de gasolina são usados em uma
viagem, sabendo que um carro faz 10 km/litro. O usuário fornecerá a velocidade
do carro e o período de tempo que viaja nesta velocidade para cada trecho do
percurso. Então, usando as fórmulas distância = tempo x velocidade e litros
consumidos = distância / 10, o programa computará, para todos os valores não-
negativos de velocidade, os litros de combustível consumidos. O programa deverá
imprimir a distância e o número de litros de combustível gastos naquele trecho.
Deverá imprimir também o total de litros gastos na viagem. O programa encerra
quando o usuário informar um valor negativo de velocidade.

fn main() {
    let mut total_litros_gastos = 0.0;

    loop {
        println!("Insira a velocidade em km/h:");
        let mut velocidade = String::new();
        std::io::stdin().read_line(&mut velocidade).expect("Falha ao ler a entrada");

        let velocidade: f32 = match velocidade.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        if velocidade < 0.0 {
            break;
        }

        println!("Insira o tempo em horas:");
        let mut tempo = String::new();
        std::io::stdin().read_line(&mut tempo).expect("Falha ao ler a entrada");

        let tempo: f32 = match tempo.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        let distancia = velocidade * tempo;
        let litros_gastos = distancia / 10.0;

        println!("Você percorreu {} km e gastou {} litros de gasolina neste trecho.", distancia, litros_gastos);
        total_litros_gastos += litros_gastos;
    }

    println!("Você gastou um total de {} litros de gasolina na viagem.", total_litros_gastos);
}


=======================================================================

25. Faça um programa que calcule o imposto de renda de um grupo de contribuintes,
considerando que:
a) os dados de cada contribuinte (CIC, número de dependentes e renda bruta
anual) serão fornecidos pelo usuário via teclado;
b) para cada contribuinte será feito um abatimento de R$600 por dependente;
c) a renda líquida é obtida diminuindo-se o abatimento com os dependentes
da renda bruta anual;
d) para saber quanto o contribuinte deve pagar de imposto, utiliza-se a tabela
a seguir:
Renda Líquida
até R$1000
de R$1001 a R$5000
acima de R$5000
Imposto
Isento
15%
25%
e) o valor de CIC igual a zero indica final de dados;
f) o programa deverá imprimir, para cada contribuinte, o número do CIC e o
imposto a ser pago;
g) ao final o programa deverá imprimir o total do imposto arrecadado pela
Receita Federal e o número de contribuintes isentos;
h) leve em Rustonsideração o fato de o primeiro CIC informado poder ser zero.

fn main() {
    // Declaração das variáveis
    let mut cic: i32; // número do CIC
    let mut num_dependentes: i32; // número de dependentes
    let mut renda_bruta: f32; // renda bruta anual
    let mut renda_liquida: f32; // renda líquida
    let mut imposto: f32; // imposto a ser pago
    let mut total_imposto: f32 = 0.0; // total de imposto arrecadado
    let mut contribuintes_isentos: i32 = 0; // número de contribuintes isentos

    println!("Calculo de imposto de renda");
    println!("Para encerrar a entrada de dados, digite 0 no CIC");

    // Pede os dados de entrada enquanto o CIC não for zero
    loop {
        println!("Digite o numero do CIC: ");
        cic = read!(); // lê o número do CIC

        if cic == 0 { // se o CIC for zero, encerra o laço
            break;
        }

        println!("Digite o numero de dependentes: ");
        num_dependentes = read!(); // lê o número de dependentes

        println!("Digite a renda bruta anual: ");
        renda_bruta = read!(); // lê a renda bruta anual

        // Calcula a renda líquida
        renda_liquida = renda_bruta - num_dependentes as f32 * 600.0;

        // Calcula o imposto a ser pago
        if renda_liquida <= 1000.0 {
            imposto = 0.0; // isento
            contribuintes_isentos += 1; // aumenta o número de contribuintes isentos
        } else if renda_liquida <= 5000.0 {
            imposto = renda_liquida * 0.15; // 15%
        } else {
            imposto = renda_liquida * 0.25; // 25%
        }

        // Adiciona o imposto ao total de imposto arrecadado
        total_imposto += imposto;

        // Imprime o número do CIC e o imposto a ser pago
        println!("Numero do CIC: {}", cic);
        println!("Imposto a ser pago: {:.2}", imposto);
    }

    // Imprime o total de imposto arrecadado e o número de contribuintes isentos
    println!("Total de imposto arrecadado: {:.2}", total_imposto);
    println!("Numero de contribuintes isentos: {}", contribuintes_isentos);
}


====================================================================================

26. Foi feita uma pesquisa de audiência de canal de TV em várias casas de uma
certa cidade, em um determinado dia. Para cada casa visitada foram fornecidos o
número do canal (4, 5, 7, 12) e o número de pessoas que estavam assistindo a ele
naquela casa. Se a televisão estivesse desligada, nada seria anotado, ou seja, esta
casa não entraria na pesquisa. Criar um programa que:
• Leia um número indeterminado de dados, isto é, o número do canal e o
número de pessoas que estavam assistindo;
• Calcule e imprima a porcentagem de audiência em Rustada canal.
Obs.: Para encerrar a entrada de dados, digite o número do canal zero.

fn main() {
    // Declara as variáveis de contagem para cada canal
    let mut canal_4 = 0;
    let mut canal_5 = 0;
    let mut canal_7 = 0;
    let mut canal_12 = 0;
    let mut total_pessoas = 0;

    // Declara as variáveis para ler o número do canal e o número de pessoas assistindo
    let mut canal: i32;
    let mut pessoas: i32;

    // Lê os dados do canal e das pessoas até que o número do canal seja zero
    loop {
        println!("Digite o número do canal:");
        canal = read!();

        if canal == 0 {
            break;
        }

        println!("Digite o número de pessoas assistindo:");
        pessoas = read!();

        // Incrementa o contador de pessoas para o canal correspondente
        match canal {
            4 => canal_4 += pessoas,
            5 => canal_5 += pessoas,
            7 => canal_7 += pessoas,
            12 => canal_12 += pessoas,
            _ => println!("Canal inválido"),
        }

        // Incrementa o total de pessoas
        total_pessoas += pessoas;
    }

    // Calcula e imprime a porcentagem de audiência de cada canal
    println!("Canal 4: {}%", (canal_4 as f64 / total_pessoas as f64) * 100.0);
    println!("Canal 5: {}%", (canal_5 as f64 / total_pessoas as f64) * 100.0);
    println!("Canal 7: {}%", (canal_7 as f64 / total_pessoas as f64) * 100.0);
    println!("Canal 12: {}%", (canal_12 as f64 / total_pessoas as f64) * 100.0);
}
=============================================================================
27. Crie um programa que calcule e imprima o CR do período para os alunos de
computação. Para cada aluno, o algoritmo deverá ler:
• número da matrícula;
• quantidade de disciplinas cursadas;
• notas em Rustada disciplina;
Além do CR de cada aluno, o programa deve imprimir o melhor CR dos
alunos que cursaram 5 ou mais disciplinas.
• fim da entrada de dados é marcada por uma matrícula inválida (matrículas
válidas de 1 a 5000);
• CR do aluno é igual à média aritmética de suas notas.

fn main() {
    // Declaração de variáveis
    let mut melhor_cr = 0.0; // Melhor CR dos alunos que cursaram 5 ou mais disciplinas
    let mut matricula; // Matrícula do aluno
    let mut qtd_disciplinas; // Quantidade de disciplinas cursadas pelo aluno
    let mut nota; // Nota do aluno em uma disciplina
    let mut cr; // CR do aluno
    
    loop {
        println!("Digite o número da matrícula do aluno ou qualquer número inválido para sair:");
        // Lê a matrícula do aluno
        matricula = read!();

        // Se a matrícula for inválida, encerra o loop
        if matricula < 1 || matricula > 5000 {
            break;
        }

        println!("Digite a quantidade de disciplinas cursadas pelo aluno:");
        // Lê a quantidade de disciplinas cursadas pelo aluno
        qtd_disciplinas = read!();

        // Inicializa o CR do aluno como 0
        cr = 0.0;

        // Lê as notas do aluno em Rustada disciplina
        for _i in 0..qtd_disciplinas {
            println!("Digite a nota do aluno na disciplina {}:", _i + 1);
            nota = read!();
            cr += nota; // Adiciona a nota do aluno ao CR
        }

        cr /= qtd_disciplinas as f64; // Calcula o CR do aluno como a média aritmética de suas notas
        println!("O CR do aluno de matrícula {} é: {}", matricula, cr); // Imprime o CR do aluno

        // Se o aluno cursou 5 ou mais disciplinas e seu CR é maior que o melhor CR atual, atualiza o melhor CR
        if qtd_disciplinas >= 5 && cr > melhor_cr {
            melhor_cr = cr;
        }
    }

    // Imprime o melhor CR dos alunos que cursaram 5 ou mais disciplinas
    println!("O melhor CR entre os alunos que cursaram 5 ou mais disciplinas é: {}", melhor_cr);
}


==================================================================================================
28. Construa um programa que receba a idade, a altura e o peso de várias pessoas,
Calcule e imprima:
• a quantidade de pessoas com idade superior a 50 anos;
• a média das alturas das pessoas com idade entre 10 e 20 anos;
• a porcentagem de pessoas com peso inferior a 40 quilos entre todas as
pessoas analisadas.


fn main() {
    // Declarando variáveis
    let mut idade: i32;
    let mut altura: f32;
    let mut peso: f32;
    let mut qtde_pessoas_50_anos: i32 = 0;
    let mut soma_alturas_10_20_anos: f32 = 0.0;
    let mut qtde_pessoas_10_20_anos: i32 = 0;
    let mut qtde_pessoas_peso_inferior_40: i32 = 0;
    let mut pessoas_analisadas: i32 = 0;

    // Repetindo o processamento enquanto o usuário não informar a idade como -1
    loop {
        println!("Informe a idade:");
        stdin().read_line(&mut idade).expect("Falha ao ler a idade");

        if idade == -1 {
            break;
        }

        println!("Informe a altura:");
        stdin().read_line(&mut altura).expect("Falha ao ler a altura");

        println!("Informe o peso:");
        stdin().read_line(&mut peso).expect("Falha ao ler o peso");

        // Incrementando a quantidade de pessoas analisadas
        pessoas_analisadas += 1;

        // Verificando se a idade é superior a 50 anos
        if idade > 50 {
            qtde_pessoas_50_anos += 1;
        }

        // Verificando se a idade está entre 10 e 20 anos
        if idade >= 10 && idade <= 20 {
            qtde_pessoas_10_20_anos += 1;
            soma_alturas_10_20_anos += altura;
        }

        // Verificando se o peso é inferior a 40 quilos
        if peso < 40.0 {
            qtde_pessoas_peso_inferior_40 += 1;
        }
    }

    // Calculando e imprimindo os resultados
    println!("Quantidade de pessoas com idade superior a 50 anos: {}", qtde_pessoas_50_anos);
    println!("Média das alturas das pessoas com idade entre 10 e 20 anos: {}", soma_alturas_10_20_anos / qtde_pessoas_10_20_anos as f32);
    println!("Porcentagem de pessoas com peso inferior a 40 quilos entre todas as pessoas analisadas: {}%", (qtde_pessoas_peso_inferior_40 as f32 / pessoas_analisadas as f32) * 100.0);
}







================================================================================================
29. Construa um programa que receba o valor e o código de várias mercadorias
vendidas em um determinado dia. Os códigos obedecem a lista a seguir:
L-limpeza
A-Alimentação
H-Higiene
Calcule e imprima:
• o total vendido naquele dia, com todos os códigos juntos;
• o total vendido naquele dia em Rustada um dos códigos.
Obs.: Para encerrar a entrada de dados, digite o valor da mercadoria zero.



fn main() {
    let mut total_vendido = 0;
    let mut total_limpeza = 0;
    let mut total_alimentacao = 0;
    let mut total_higiene = 0;

    loop {
        println!("Insira o valor da mercadoria e o código (L, A, H):");

        let mut input = String::new();
        std::io::stdin().read_line(&mut input).expect("Falha ao ler entrada");

        let mut valor_input = input.split_whitespace();

        let valor: i32 = match valor_input.next() {
            Some(x) => x.parse().expect("Falha ao converter valor para inteiro"),
            None => break,
        };

        if valor == 0 {
            break;
        }

        let codigo: char = match valor_input.next() {
            Some(x) => x.chars().next().expect("Falha ao ler código"),
            None => break,
        };

        total_vendido += valor;

        match codigo {
            'L' => total_limpeza += valor,
            'A' => total_alimentacao += valor,
            'H' => total_higiene += valor,
            _ => println!("Código inválido"),
        }
    }

    println!("Total vendido: {}", total_vendido);
    println!("Total vendido em limpeza: {}", total_limpeza);
    println!("Total vendido em alimentação: {}", total_alimentacao);
    println!("Total vendido em higiene: {}", total_higiene);
}








================================================================================================
30. Faça um programa que receba a idade e o estado civil (C-casado, S-solteiro, V-
    viúvo e D-desquitado ou separado) de várias pessoas. Calcule e imprima:
    • a quantidade de pessoas casadas;
    • a quantidade de pessoas solteiras;
    • a média das idades das pessoas viúvas;
    • a porcentagem de pessoas desquitadas ou separadas dentre todas as pessoas
    analisadas.
    Obs.: Para encerrar a entrada de dados, digite um número menor que zero para a
    idade.

    fn main() {
        let mut idade: i32;
        let mut estado_civil: char;
        let mut casados = 0;
        let mut solteiros = 0;
        let mut viuvos = 0;
        let mut viuvos_idade = 0;
        let mut desquitados_separados = 0;
        let mut total_pessoas = 0;
        
        
        println!("Insira a idade e o estado civil (C-casado, S-solteiro, V-viúvo e D-desquitado ou separado) de cada pessoa: ");
        
        loop {
            println!("Idade: ");
            idade = read!();
            if idade < 0 {
                break;
            }
            println!("Estado civil: ");
            estado_civil = read!();
        
            total_pessoas += 1;
        
            match estado_civil {
                'C' => casados += 1,
                'S' => solteiros += 1,
                'V' => {
                    viuvos += 1;
                    viuvos_idade += idade;
                },
                'D' => desquitados_separados += 1,
                _ => println!("Estado civil inválido"),
            }
        }
        
        println!("Quantidade de pessoas casadas: {}", casados);
        println!("Quantidade de pessoas solteiras: {}", solteiros);
        println!("Média das idades das pessoas viúvas: {}", viuvos_idade / viuvos);
        println!("Porcentagem de pessoas desquitadas ou separadas dentre todas as pessoas analisadas: {}%", (desquitados_separados as f64 / total_pessoas as f64) * 100.0);
        }



============================================================================================================
Vetores

Até o momento, foram utilizadas variáveis em que é possível armazenar 1 (um) dado considerando o seu tipo, como pode ser visto na tabela 10, assim, se for declarada uma variável do tipo int, por exemplo, o programa irá reservar 16 bits na memória do computador para essa variável e com este espaço, pode-se armazenar um dado apenas, na memória, isso ocorre porque a variável está associada à apenas aquela área da memória que foi reservada para ela. Assim, se for necessário armazenar, por exemplo, a idade de 2 pessoas, duas variáveis devem ser declaradas, se for necessário armazenar a idade de 3 pessoas, então 3 variáveis devem ser declaradas, mas e se for necessário armazenar a idade de 10 ou 100 pessoas? Não seria nada prático declarar 10 variáveis, muito menos, declarar 100 variáveis, até mesmo porque o maior esforço seria no controle dessas diversas variáveis. Neste caso é muito útil o uso de vetores.

Os tamanhos dos tipos básicos na linguagem Rust são os seguintes:

i8: 8 bits, -128 a 127
i16: 16 bits, -32.768 a 32.767
i32: 32 bits, -2.147.483.648 a 2.147.483.647
i64: 64 bits, -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807
i128: 128 bits, -170.141.183.460.469.231.731.687.303.715.884.105.728 a 170.141.183.460.469.231.731.687.303.715.884.105.727
isize: depende do tamanho da arquitetura da máquina, -2^63 a 2^63-1 no sistema de 64 bits, -2^31 a 2^31-1 no sistema de 32 bits
u8: 8 bits, 0 a 255
u16: 16 bits, 0 a 65.535
u32: 32 bits, 0 a 4.294.967.295
u64: 64 bits, 0 a 18.446.744.073.709.551.615
u128: 128 bits, 0 a 340.282.366.920.938.463.463.374.607.431.768.211.455
usize: depende do tamanho da arquitetura da máquina, 0 a 2^64-1 no sistema de 64 bits, 0 a 2^32-1 no sistema de 32 bits
Observe que os tipos i são para números inteiros com sinal e os tipos u são para números inteiros sem sinal. O tipo isize e usize são do mesmo tamanho que o tamanho da arquitetura da máquina, o que os torna úteis para trabalhar com índices de vetores e outras estruturas de dados.

Exemplo de uso:


let x: i32 = 42;
let y: u32 = 123;
let z: isize = -500;
let w: usize = 1000;

Os vetores, também denominados de arrays, são um conjunto de variáveis do mesmo tipo que facilitam a manipulação dos dados, pois permitem o acesso por meio de índices (ALBANO; ALBANO, 2010; BACKES, 2013; ANICHE, 2015). Ao declarar um vetor, é preciso informar o seu tamanho e o seu tipo, por exemplo, um vetor do tipo int com tamanho 10, indica que este vetor terá uma capacidade de armazenar até 10 valores do tipo inteiro, pois ele faz referência para 10 posições de área reservada na memória com 16 bits, conforme pode ser visto na tabela 10.

Em Rust, os vetores são representados pelo tipo Vec<T>. Para declarar um vetor, é preciso informar o tipo de dado que ele vai armazenar, por exemplo:


let v: Vec<i32> = Vec::new(); // cria um vetor vazio de inteiros
Também é possível inicializar um vetor com alguns valores, usando o método vec!:


let v = vec![1, 2, 3, 4, 5]; // cria um vetor com os valores 1, 2, 3, 4, 5
Para adicionar um elemento ao final de um vetor, você pode usar o método push:


v.push(6); // adiciona o valor 6 ao final do vetor v
Para acessar um elemento de um vetor, basta usar o índice desejado entre colchetes:


let x = v[0]; // obtém o primeiro elemento do vetor (índice 0)
O tamanho de um vetor pode ser obtido usando o método len:


let size = v.len(); // obtém o tamanho do vetor v
Observe que em Rust, os índices dos vetores começam em 0, ou seja, o primeiro elemento de um vetor tem índice 0, o segundo elemento tem índice 1, e assim por diante. Além disso, é importante lembrar que acessar um elemento de um vetor fora dos limites do vetor pode causar um erro de tempo de execução.

Atribuição e obtenção de valores em vetor

Para fazer atribuição e obtenção de valores em um vetor em Rust, basta usar o índice desejado entre colchetes. Veja os exemplos a seguir:


let mut v: Vec<i32> = Vec::new(); // cria um vetor vazio de inteiros

// atribuição de valores ao vetor
v.push(10); // adiciona o valor 10 ao final do vetor
v.push(20); // adiciona o valor 20 ao final do vetor

// obtenção de valores do vetor
let x = v[0]; // obtém o primeiro elemento do vetor (índice 0)
let y = v[1]; // obtém o segundo elemento do vetor (índice 1)

// alteração de valores no vetor
v[1] = 30; // altera o valor do segundo elemento para 30
Observe que é preciso usar o operador mut para tornar o vetor mutável e permitir a atribuição de valores. Além disso, é importante lembrar que tentar acessar um elemento de um vetor fora dos limites do vetor pode causar um erro de tempo de execução.

Para vetores do tipo [T; size], o processo é semelhante, basta usar o índice desejado entre colchetes:


let mut v: [i32; 3] = [1, 2, 3]; // cria um vetor com os valores 1, 2, 3

// obtenção de valores do vetor
let x = v[0]; // obtém o primeiro elemento do vetor (índice 0)
let y = v[1]; // obtém o segundo elemento do vetor (índice 1)

// alteração de valores no vetor
v[1] = 30; // altera o valor do segundo elemento para 30
Observe que não é preciso usar o operador mut para vetores do tipo [T; size], pois eles são mutáveis por padrão.



Em Rust, você pode fazer isso da seguinte forma:


use std::io;

fn main() {
    let mut vet_idades: [i32; 10] = [0; 10];

    vet_idades[0] = 10;
    vet_idades[1] = 20;

    let mut input = String::new();

    println!("Informe uma idade:");

    io::stdin().read_line(&mut input).expect("Falha ao ler entrada");

    let idade: i32 = input.trim().parse().expect("Por favor, informe um número inteiro válido");

    vet_idades[2] = idade;
    vet_idades[3] = vet_idades[2] + vet_idades[1];
}
A primeira parte é semelhante ao código C, onde declaramos um vetor de inteiros com tamanho 10 e atribuímos valores às duas primeiras posições.

Em seguida, usamos a função read_line da biblioteca std::io para ler uma linha de texto do usuário e a função parse do método str para converter a string lida para um inteiro. Em seguida, atribuímos o valor lido à terceira posição do vetor.

Finalmente, atribuímos à quarta posição a soma das duas primeiras posições do vetor, assim como no código C.

Em Rust, você pode fazer isso da seguinte forma:


use std::io;

fn main() {
    let mut vet_idades: [i32; 3] = [0; 3];
    let mut soma = 0;

    for i in 0..3 {
        let mut input = String::new();
        println!("Informe a {}ª idade:", i + 1);
        io::stdin().read_line(&mut input).expect("Falha ao ler entrada");
        vet_idades[i] = input.trim().parse().expect("Por favor, informe um número inteiro válido");
    }

    for i in 0..3 {
        soma += vet_idades[i];
    }

    println!("Idades: {} \t {} \t {}", vet_idades[0], vet_idades[1], vet_idades[2]);
    println!("A soma das idades é: {}", soma);
}
A primeira parte do código declara um vetor de inteiros com tamanho 3 e uma variável de soma, ambas inicializadas com 0. Em seguida, usamos um laço for para ler três valores do usuário e atribuí-los às três posições do vetor.

Na segunda parte do código, usamos outro laço for para percorrer o vetor e somar os valores de cada posição à variável de soma.

Por fim, usamos println! para imprimir os valores do vetor e a soma das idades.

Atribuição e acesso a valores com estrutura de iteração

Como pode ver, para atribuir ou acessar valores em vetores é preciso uma instrução para cada posição do vetor. Assim, em vetores com poucas posições pode até ser prático fazer o acesso, contudo imagine fazer a atribuição em um vetor com 100 posições? Terá que escrever 100 instruções no código-fonte? Certamente, isso não é nada prático, nestes casos é possível fazer uso das estruturas de iteração e a que se adapta melhor com os vetores é o for. Isso ocorre porque o for já traz um índice que pode facilmente ser utilizado para indicar as posições do vetor. A seguir, um exercício para exemplificar.

Em Rust, você pode usar um laço for para iterar sobre os elementos de um vetor e fazer atribuições ou acessos aos valores de cada posição de forma mais eficiente. Por exemplo:


fn main() {
    let mut vet_idades: [i32; 100] = [0; 100];

    // Atribui valores ao vetor usando o índice do laço for
    for i in 0..100 {
        vet_idades[i] = i + 1;
    }

    // Imprime os valores do vetor usando o índice do laço for
    for i in 0..100 {
        println!("{}", vet_idades[i]);
    }
}
O primeiro laço for itera sobre os índices do vetor e atribui um valor à cada posição, enquanto o segundo laço for itera sobre os índices do vetor e imprime os valores de cada posição.

Você também pode usar a função enumerate para iterar sobre os elementos de um vetor e obter o índice de cada elemento. Por exemplo:


fn main() {
    let mut vet_idades: [i32; 100] = [0; 100];

    // Atribui valores ao vetor usando o índice e o valor da iteração
    for (i, valor) in vet_idades.iter_mut().enumerate() {
        *valor = i + 1;
    }

    // Imprime os valores do vetor usando o índice e o valor da iteração
    for (i, valor) in vet_idades.iter().enumerate() {
        println!("{}: {}", i, valor);
    }
}
O primeiro laço for itera sobre os elementos do vetor e atribui um valor à cada posição, enquanto o segundo laço for itera sobre os elementos do vetor e imprime os valores de cada posição junto com o índice correspondente.

Aqui está o código em Rust:


fn main() {
    let mut numeros = [0; 15]; // cria um array de 15 elementos inicializados com 0

    // lendo os valores
    for i in 0..15 {
        println!("Informe um número:");
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).expect("Falha ao ler entrada");
        let numero: i32 = input.trim().parse().expect("Falha ao converter para número inteiro");
        numeros[i] = numero;
    }

    // imprimindo os valores
    for numero in numeros.iter() {
        println!("Número: {}", numero);
    }
}
Explicação das linhas de código:

fn main() é a função principal do programa. Todo código Rust precisa ter uma função principal.

let mut numeros = [0; 15] cria um array (vetor) de 15 elementos inicializados com 0.

A primeira estrutura de iteração for i in 0..15 percorre os índices de 0 a 14 (inclusive) e armazena o índice atual em i.

println!("Informe um número:") imprime a mensagem na tela.

let mut input = String::new() cria uma nova string vazia chamada input.

std::io::stdin().read_line(&mut input) lê a linha digitada pelo usuário e armazena em input.

expect("Falha ao ler entrada") é uma forma de lidar com erros. Se houver algum erro ao ler a entrada, a mensagem "Falha ao ler entrada" será exibida.

let numero: i32 = input.trim().parse().expect("Falha ao converter para número inteiro") converte a string lida em um número inteiro e armazena em numero. Se houver algum erro na conversão, a mensagem "Falha ao converter para número inteiro" será exibida.

numeros[i] = numero armazena o número lido no array numeros na posição i.

A segunda estrutura de iteração for numero in numeros.iter() percorre todos os elementos do array numeros e armazena o elemento atual em numero.

println!("Número: {}", numero) imprime o elemento atual.

Aqui está o código em Rust:


fn main() {
    let mut lista = [0; 5]; // cria um array de 5 elementos inicializados com 0

    // lendo os valores
    for i in 0..5 {
        println!("Informe um número:");
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).expect("Falha ao ler entrada");
        let numero: i32 = input.trim().parse().expect("Falha ao converter para número inteiro");
        lista[i] = numero;
    }

    // inicializando o maior valor
    let mut maior = lista[0];

    // encontrando o maior valor
    for numero in lista[1..].iter() {
        if maior < *numero {
            maior = *numero;
        }
    }

    println!("Maior = {}", maior);
}
Explicação das linhas de código:

let mut lista = [0; 5] cria um array (vetor) de 5 elementos inicializados com 0.

A primeira estrutura de iteração for i in 0..5 percorre os índices de 0 a 4 (inclusive) e armazena o índice atual em i.

println!("Informe um número:") imprime a mensagem na tela.

`let mut

Exercício de Exemplo

Os exercícios desta lista foram Adaptados de Lopes e Garcia (2002, p. 277-303).
1. Faça um programa em Rust que armazene 15 números inteiros em um vetor e depois
permita que o usuário digite um número inteiro para ser buscado no vetor, se
for encontrado o programa deve imprimir a posição desse número no vetor, caso
contrário, deve imprimir a mensagem: "Nao encontrado!".

fn main() {
    let mut vet: [i32; 15] = [0; 15];

    // Atribui valores ao vetor
    for i in 0..15 {
        vet[i] = i + 1;
    }

    println!("Vetor: {:?}", vet);

    // Lê um valor do usuário
    let mut input = String::new();
    println!("Informe um número para buscar no vetor:");
    io::stdin().read_line(&mut input).expect("Falha ao ler entrada");
    let num: i32 = input.trim().parse().expect("Por favor, informe um número inteiro válido");

    // Procura o valor no vetor
    let mut encontrado = false;
    for (i, valor) in vet.iter().enumerate() {
        if *valor == num {
            println!("O número {} foi encontrado na posição {} do vetor", num, i);
            encontrado = true;
            break;
        }
    }

    if !encontrado {
        println!("O número {} não foi encontrado no vetor", num);
    }
}
=====================================================================================================================

Faça um programa que armazene 10 letras em um vetor e imprima uma listagem
numerada.

fn main() {
    let mut vet: [char; 10] = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];

    for (i, valor) in vet.iter().enumerate() {
        println!("{}: {}", i + 1, valor);
    }
}
Explicação:

O código declara um vetor de caracteres com tamanho 10 e atribui valores às suas posições.

Em seguida, usamos a função enumerate para iterar sobre os elementos do vetor e obter o índice de cada elemento. em Rustada iteração, imprimimos o índice (incrementado em 1 para ficar de acordo com a numeração da listagem) e o valor do elemento.

Dessa forma, o programa imprime uma listagem numerada com as letras armazenadas no vetor.


========================================================================================================
3. Construa uma programa em Rust que armazene 15 números em um vetor e imprima uma listagem numerada contendo o número e uma das mensagens: par ou ímpar.


Em Rust, o código para resolver o exercício pode ser escrito da seguinte forma:


fn main() {
    let mut vet: [i32; 15] = [0; 15];

    // Atribui valores ao vetor
    for i in 0..15 {
        vet[i] = i + 1;
    }

    for (i, valor) in vet.iter().enumerate() {
        if valor % 2 == 0 {
            println!("{}: {} (par)", i + 1, valor);
        } else {
            println!("{}: {} (ímpar)", i + 1, valor);
        }
    }
}
Explicação:

A primeira parte do código declara um vetor de inteiros com tamanho 15 e inicializa todas as posições com o valor 0. Em seguida, usamos um laço for para atribuir valores a cada posição do vetor, de 1 a 15.

Na segunda parte do código, usamos a função enumerate para iterar sobre os elementos do vetor e obter o índice de cada elemento. em Rustada iteração, verificamos se o elemento é par ou ímpar usando o operador módulo (%) e imprimimos o índice (incrementado em 1 para ficar de acordo com a numeração da listagem), o valor do elemento e a mensagem Rustorrespondente ("par" ou "ímpar").

Dessa forma, o programa imprime uma listagem numerada com os números armazenados no vetor e uma indicação de se são pares ou ímpares.

========================================================================================================

4. Faça um programa que armazene 8 números em um vetor e imprima todos os
números. Ao final, imprima o total de números múltiplos de seis.

Aqui está uma solução em Rust para o problema proposto:


fn main() {
    // Declara o vetor com 8 elementos
    let mut numeros = [0; 8];

    // Pede para o usuário digitar os 8 números
    println!("Digite 8 números:");
    for i in 0..8 {
        numeros[i] = read!();
    }

    // Imprime todos os números do vetor
    println!("Os números digitados foram:");
    for i in 0..8 {
        println!("{}", numeros[i]);
    }

    // Conta e imprime a quantidade de números múltiplos de 6
    let mut contador = 0;
    for i in 0..8 {
        if numeros[i] % 6 == 0 {
            contador += 1;
        }
    }
    println!("A quantidade de números múltiplos de 6 é: {}", contador);
}
Vou explicar cada linha da solução:

A primeira linha fn main() { define o início da função principal do programa.
Em seguida, declaramos o vetor numeros com 8 elementos inicializados com o valor 0. O tamanho do vetor é especificado entre colchetes e o valor inicial é especificado entre parênteses.
A seguir, usamos o comando println! para imprimir uma mensagem solicitando ao usuário que digite 8 números. Em seguida, usamos um loop for para percorrer todos os elementos do vetor e armazenar os números digitados pelo usuário. Para ler os valores digitados, usamos a macro read!.
Depois disso, usamos outro loop for para percorrer todos os elementos do vetor e imprimir os números armazenados.
Por fim, usamos mais um loop for para percorrer todos os elementos do vetor e verificar se são múltiplos de 6. Para fazer essa verificação, usamos o operador de módulo %. Se o resto da divisão do número pelo 6 for zero, significa que ele é múltiplo de 6. Armazenamos a quantidade de números múltiplos de 6 em uma variável contador e, ao final do loop, imprimimos o valor dessa variável com o comando println!.

========================================================================================================

5. Faça um programa que armazene as notas das provas 1 e 2 de 15 alunos. Calcule e armazene a média arredondada. Armazene também a situação do aluno: 1- Aprovado ou 2-Reprovado. Ao final o programa deve imprimir uma listagem Rustontendo as notas, a média e a situação de cada aluno em formato tabulado. Utilize quantos vetores forem necessários para armazenar os dados.

fn main() {
    // Declara os vetores para armazenar as notas e as situações dos alunos
    let mut notas1 = [0.0; 15];
    let mut notas2 = [0.0; 15];
    let mut medias = [0.0; 15];
    let mut situacoes = [0; 15];

    // Pede para o usuário digitar as notas e calcula as médias
    println!("Digite as notas dos 15 alunos:");
    for i in 0..15 {
        println!("Nota 1 do aluno {}:", i + 1);
        notas1[i] = read!();
        println!("Nota 2 do aluno {}:", i + 1);
        notas2[i] = read!();

        // Calcula a média e arredonda para o inteiro mais próximo
        medias[i] = (notas1[i] + notas2[i]) / 2.0;
        medias[i] = medias[i].round();

        // Verifica a situação do aluno
        if medias[i] >= 6.0 {
            situacoes[i] = 1;
        } else {
            situacoes[i] = 2;
        }
    }

    // Imprime a listagem dos alunos
    println!("Listagem dos alunos:");
    println!("Aluno | Nota 1 | Nota 2 | Média | Situação");
    for i in 0..15 {
        println!("{}     | {:.1}   | {:.1}   | {:.1}   | {}", i + 1, notas1[i], notas2[i], medias[i], situacoes[i]);
    }
}

===========================================================================================
6. Construa um programa que permita armazenar o salário de 20 pessoas. Calcular e armazenar o novo salário sabendo-se que o reajuste foi de 8%. Imprimir uma listagem numerada com o salário e o novo salário. Declare quantos vetores forem necessários.


Aqui está uma solução em Rust para o problema proposto:


fn main() {
    // Declara o vetor para armazenar os salários
    let mut salarios = [0.0; 20];
    let mut novos_salarios = [0.0; 20];

    // Pede para o usuário digitar os salários
    println!("Digite os salários de 20 pessoas:");
    for i in 0..20 {
        println!("Salário da pessoa {}:", i + 1);
        salarios[i] = read!();
    }

    // Calcula e armazena os novos salários
    for i in 0..20 {
        novos_salarios[i] = salarios[i] * 1.08;
    }

    // Imprime a listagem dos salários
    println!("Listagem dos salários:");
    println!("Pessoa | Salário | Novo Salário");
    for i in 0..20 {
        println!("{}      | {:.2}    | {:.2}", i + 1, salarios[i], novos_salarios[i]);
    }
}
Vou explicar cada linha da solução:

A primeira linha fn main() { define o início da função principal do programa.
Em seguida, declaramos os vetores salarios e novos_salarios para armazenar os salários e os novos salários, respectivamente. Inicializamos todos os elementos dos vetores com o valor zero. O tamanho dos vetores é especificado entre colchetes e o valor inicial é especificado entre parênteses.
A seguir, usamos o comando println! para imprimir uma mensagem solicitando ao usuário que digite os salários de 20 pessoas. Em seguida, usamos um loop for para percorrer todos os elementos do vetor salarios e armazenar os salários digitados pelo usuário. Para ler os valores digitados, usamos a macro read!.
Depois disso, usamos outro loop for para percorrer todos os elementos do vetor salarios e calcular os novos salários com o reajuste de 8%. Para fazer isso, basta multiplicar o salário atual por 1,08. Armazenamos o resultado no vetor novos_salarios.
Por fim, usamos mais um loop for para percorrer todos os elementos dos vetores e imprimir a listagem dos salários e dos novos salários. Usamos o comando println! para formatar a saída e exibir os valores com duas casas decimais.



===========================================================================================
7. Crie um programa que leia o preço de compra e o preço de venda de 100 mercado-
rias (utilize vetores). Ao final, o programa deverá imprimir quantas mercadorias
proporcionam:
• lucro < 10%
• 10% <= lucro <= 20%
• lucro > 20%

fn main() {
    let mut compras = [0; 100]; // cria um vetor de compras com 100 elementos, todos inicializados com 0
    let mut vendas = [0; 100]; // cria um vetor de vendas com 100 elementos, todos inicializados com 0
    let mut lucro_baixo = 0; // variável para contar quantas mercadorias têm lucro < 10%
    let mut lucro_medio = 0; // variável para contar quantas mercadorias têm 10% <= lucro <= 20%
    let mut lucro_alto = 0; // variável para contar quantas mercadorias têm lucro > 20%

    for i in 0..100 { // laço de repetição para ler os preços de compra e venda
        println!("Insira o preço de compra da mercadoria {}:", i + 1);
        let mut compra = String::new();
        std::io::stdin().read_line(&mut compra).expect("Falha ao ler o preço de compra");
        let compra: f64 = compra.trim().parse().expect("Por favor, insira um número válido");
        compras[i] = compra;

        println!("Insira o preço de venda da mercadoria {}:", i + 1);
        let mut venda = String::new();
        std::io::stdin().read_line(&mut venda).expect("Falha ao ler o preço de venda");
        let venda: f64 = venda.trim().parse().expect("Por favor, insira um número válido");
        vendas[i] = venda;
    }

    for i in 0..100 { // laço de repetição para calcular o lucro de cada mercadoria
        let lucro = vendas[i] - compras[i];
        let percentual_lucro = lucro / compras[i] * 100.0;
        if percentual_lucro < 10.0 {
            lucro_baixo += 1;
        } else if percentual_lucro <= 20.0 {
            lucro_medio += 1;
        } else {
            lucro_alto += 1;
        }
    }

    println!("Quantidade de mercadorias com lucro < 10%: {}", lucro_baixo);
    println!("Quantidade de mercadorias com 10% <= lucro <= 20%: {}", lucro_medio);
    println!("Quantidade de mercadorias com lucro > 20%: {}", lucro_alto);
}





===========================================================================================
8. Construa um programa que armazene o código, a quantidade, o valor de compra
e o valor de venda de 30 produtos. A listagem pode ser de todos os produtos ou
somente de um ao se digitar o código.


fn main() {
    // Declara uma array de tuplas para armazenar os produtos
    let mut produtos: [(i32, i32, f32, f32); 30] = [
        (1, 5, 10.0, 15.0),
        (2, 2, 20.0, 25.0),
        (3, 10, 5.0, 7.5),
        // Adicione os outros 27 produtos aqui
    ];

    // Solicita o código do produto ao usuário
    println!("Informe o código do produto:");
    let mut codigo = String::new();
    std::io::stdin().read_line(&mut codigo).unwrap();
    let codigo: i32 = codigo.trim().parse().unwrap();

    // Percorre a array de produtos procurando pelo produto com o código fornecido
    for produto in produtos.iter() {
        if produto.0 == codigo {
            // Se o produto for encontrado, exibe as informações
            println!("Código: {}", produto.0);
            println!("Quantidade: {}", produto.1);
            println!("Valor de compra: {}", produto.2);
            println!("Valor de venda: {}", produto.3);
        }
    }
}

===========================================================================================

9. Faça um programa em Rust que leia dois conjuntos de números inteiros, tendo
cada um 10 elementos. Ao final o programa deve listar os elementos comuns aos
conjuntos.

fn main() {
    // Declarando as variáveis para armazenar os conjuntos de números inteiros
    let mut conjunto_a: [i32; 10] = [0; 10];
    let mut conjunto_b: [i32; 10] = [0; 10];

    // Lendo os elementos do primeiro conjunto
    println!("Insira os elementos do primeiro conjunto (10 elementos):");
    for i in 0..10 {
        println!("Elemento {}:", i+1);
        let mut elemento = String::new();
        std::io::stdin().read_line(&mut elemento).expect("Falha ao ler o número");
        let elemento: i32 = elemento.trim().parse().expect("Por favor, insira um número inteiro válido");
        conjunto_a[i] = elemento;
    }

    // Lendo os elementos do segundo conjunto
    println!("Insira os elementos do segundo conjunto (10 elementos):");
    for i in 0..10 {
        println!("Elemento {}:", i+1);
        let mut elemento = String::new();
        std::io::stdin().read_line(&mut elemento).expect("Falha ao ler o número");
        let elemento: i32 = elemento.trim().parse().expect("Por favor, insira um número inteiro válido");
        conjunto_b[i] = elemento;
    }

    // Verificando os elementos comuns entre os conjuntos
    println!("Elementos comuns entre os conjuntos:");
    for i in 0..10 {
        for j in 0..10 {
            if conjunto_a[i] == conjunto_b[j] {
                println!("{}", conjunto_a[i]);
            }
        }
    }
}


===========================================================================================

10. Faça um programa que leia um vetor vet de 10 elementos e obtenha um vetor w
cujos componentes são os fatoriais dos respectivos componentes de vet.

fn main() {
    // Declara o vetor "vet" e inicializa com os valores desejados
    let vet = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    // Declara o vetor "w" como um vetor vazio
    let mut w = [];

    // Usa um loop "for" para iterar através dos elementos do vetor "vet"
    for i in vet.iter() {
        // Calcula o fatorial do elemento atual e adiciona ao vetor "w"
        w.push(fatorial(*i));
    }

    // Imprime o vetor "w"
    println!("{:?}", w);
}

// Define uma função para calcular o fatorial de um número
fn fatorial(x: i32) -> i32 {
    // Se x for zero, retorna 1
    if x == 0 {
        return 1;
    }

    // Inicializa uma variável "resultado" com o valor de x
    let mut resultado = x;

    // Usa um loop "for" para multiplicar resultado pelos números menores que ele até 1
    for i in 2..x {
        resultado *= i;
    }

    // Retorna o resultado final
    resultado
}

Explicação:

A primeira linha define a função principal do programa, que é onde o código será executado.
Em seguida, declaramos o vetor "vet" com os valores iniciais desejados.
Declaramos o vetor "w" como um vetor vazio, que será preenchido com os resultados do cálculo do fatorial de cada elemento de "vet".
Usamos um loop "for" para iterar através dos elementos do vetor "vet". Em cada iteração, chamamos a função "fatorial" passando o elemento atual como argumento e adicionamos o resultado ao vetor "w".
Define-se a função "fatorial" para calcular o fatorial de um número. Se o número for zero, retornamos 1 imediatamente. Caso contrário, inicializamos uma variável "resultado" com o valor do número e usamos um loop "for" para multiplicar "resultado" pelos números menores que ele até 1. Por fim, retornamos o resultado final.
Na última linha, imprimimos o vetor "w" usando a macro "println!". O símbolo ":?" é usado para imprimir os elementos do vetor de forma legível para o usuário.


===========================================================================================
11. Construa um programa que leia dados para um vetor de 100 elementos inteiros.
Imprimir o maior e o menor, sem ordenar, o percentual de números pares e a
média dos elementos do vetor.

fn main() {
    // Declara o vetor de 100 elementos inteiros
    let mut vetor: [i32; 100] = [0; 100];

    // Lê os elementos do vetor
    for i in 0..100 {
        println!("Digite o elemento {}:", i + 1);
        let mut elemento = String::new();
        std::io::stdin().read_line(&mut elemento).expect("Erro ao ler entrada");
        vetor[i] = elemento.trim().parse().expect("Erro ao converter para inteiro");
    }

    // Inicializa as variáveis para armazenar o maior, menor, quantidade de pares e a soma dos elementos
    let mut maior = vetor[0];
    let mut menor = vetor[0];
    let mut qtd_pares = 0;
    let mut soma = 0;

    // Percorre o vetor para encontrar o maior, menor, quantidade de pares e a soma dos elementos
    for i in 0..100 {
        if vetor[i] > maior {
            maior = vetor[i];
        }
        if vetor[i] < menor {
            menor = vetor[i];
        }
        if vetor[i] % 2 == 0 {
            qtd_pares += 1;
        }
        soma += vetor[i];
    }

    // Calcula a média dos elementos do vetor
    let media = soma as f64 / 100.0;

    // Calcula o percentual de números pares
    let percentual_pares = (qtd_pares as f64 / 100.0) * 100.0;

    // Imprime o maior, menor, percentual de números pares e a média
    println!("Maior: {}", maior);
    println!("Menor: {}", menor);
    println!("Percentual de números pares: {}%", percentual_pares);
    println!("Média: {}", media);
}



===========================================================================================

12. Crie um programa para gerenciar um sistema de reservas de mesas em uma casa
de espetáculo. A casa possui 30 mesas de 5 lugares cada. O programa deverá
permitir que o usuário escolha o código de uma mesa (100 a 129) e forneça a
quantidade de lugares desejados. O programa deverá informar se foi possível
realizar a reserva e atualizar a reserva. Se não for possível, o programa deverá
emitir uma mensagem. O programa deve terminar quando o usuário digitar
o código 0 (zero) para uma mesa ou quando todos os 150 lugares estiverem
ocupados.

fn main() {
    let mut mesas = [false; 150]; // vetor para armazenar o estado das mesas (ocupado ou livre)
    let mut lugares_ocupados = 0; // contador de lugares ocupados

    loop {
        println!("Digite o código da mesa (100 a 129) ou 0 para sair:");
        let mut codigo_mesa = String::new();
        std::io::stdin().read_line(&mut codigo_mesa).unwrap();
        let codigo_mesa: u32 = match codigo_mesa.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
        if codigo_mesa == 0 {
            break; // sair do loop
        }
        if codigo_mesa < 100 || codigo_mesa > 129 {
            println!("Código inválido");
            continue;
        }

        println!("Digite a quantidade de lugares desejados:");
        let mut qtd_lugares = String::new();
        std::io::stdin().read_line(&mut qtd_lugares).unwrap();
        let qtd_lugares: u32 = match qtd_lugares.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
        if qtd_lugares > 5 {
            println!("Quantidade inválida");
            continue;
        }

        let indice_inicial = (codigo_mesa - 100) * 5; // calcular o índice inicial da mesa no vetor
        let indice_final = indice_inicial + qtd_lugares; // calcular o índice final da mesa no vetor

        let mut todos_lugares_disponiveis = true; // flag para verificar se todos os lugares estão disponíveis
        for i in indice_inicial..indice_final {
            if mesas[i as usize] { // se o lugar estiver ocupado
                todos_lugares_disponiveis = false;
                break;
            }
        }

        if todos_lugares_disponiveis { // se todos os lugares estiverem disponíveis
            for i in indice_inicial..indice_final {
                mesas[i as usize] = true; // marcar os lugares como ocupados
            }
            lugares_ocupados += qtd_lugares; // atualizar o contador de lugares ocupados
            println!("Reserva realizada com sucesso!");
        } else {
            println!("Não foi possível realizar a reserva");
        }

        if lugares_ocupados == 150 { // se todos os lugares estiverem ocupados
            break; // sair do loop
        }
    }
}


===========================================================================================

13. Construa um programa que realize as reservas de passagens áreas de uma com-
panhia. O programa deve permitir cadastrar o número de 10 voos e definir a
quantidade de lugares disponíveis para cada um. Após o cadastro, leia vários
pedidos de reserva, constituídos do número da carteira de identidade do cliente e
do número do voo desejado. Para cada cliente, verificar se há possibilidade no
voo desejado. Em caso afirmativo, imprimir o número da identidade do cliente e
o número do voo, atualizando o número de lugares disponíveis. Caso contrário,
avisar ao cliente a inexistência de lugares. A leitura do número 0 (zero) para o voo
desejado indica o término da leitura de reservas.

fn main() {
    // Vetor para armazenar os voos
    let mut voos: Vec<i32> = Vec::new();

    // Lê os 10 voos e os adiciona no vetor
    for _ in 0..10 {
        println!("Insira o número de lugares disponíveis para o voo:");
        let mut lugares = String::new();
        std::io::stdin().read_line(&mut lugares).expect("Falha ao ler a entrada");
        let lugares: i32 = lugares.trim().parse().expect("Por favor, digite um número inteiro");
        voos.push(lugares);
    }

    // Lê os pedidos de reserva até que o voo desejado seja 0
    loop {
        println!("Insira o número da carteira de identidade do cliente:");
        let mut id = String::new();
        std::io::stdin().read_line(&mut id).expect("Falha ao ler a entrada");
        let id: i32 = id.trim().parse().expect("Por favor, digite um número inteiro");

        println!("Insira o número do voo desejado:");
        let mut voo = String::new();
        std::io::stdin().read_line(&mut voo).expect("Falha ao ler a entrada");
        let voo: i32 = voo.trim().parse().expect("Por favor, digite um número inteiro");

        // Se o voo desejado for 0, encerra o loop
        if voo == 0 {
            break;
        }

        // Verifica se há lugares disponíveis no voo desejado
        if voos[voo as usize - 1] > 0 {
            println!("Reserva realizada para o cliente de ID {} no voo {}", id, voo);
            // Atualiza o número de lugares disponíveis
            voos[voo as usize - 1] -= 1;
        } else {
            println!("Desculpe, não há lugares disponíveis no voo {}", voo);
        }
    }
}


===========================================================================================

14. Faça um programa que armazene 50 números inteiros em um vetor. O programa
deve gerar e imprimir um segundo vetor em que cada elemento é o quadrado do
elemento do primeiro vetor.

fn main() {
    // Cria um vetor com 50 elementos, todos inicializados com 0
    let mut vetor_1 = [0; 50];

    // Preenche o vetor com valores inteiros
    for i in 0..50 {
        vetor_1[i] = i as i32;
    }

    // Cria um vetor com 50 elementos, todos inicializados com 0
    let mut vetor_2 = [0; 50];

    // Calcula o quadrado de cada elemento do primeiro vetor e armazena o resultado no segundo vetor
    for i in 0..50 {
        vetor_2[i] = vetor_1[i] * vetor_1[i];
    }

    // Imprime os elementos do segundo vetor
    for i in 0..50 {
        println!("{}", vetor_2[i]);
    }
}
===========================================================================================

15. Faça um programa que leia e armazene vários números, até digitar o número
0. Imprimir quantos números iguais ao último número foram lidos. O limite de
números é 100.

fn main() {
    // Declara a variável que armazenará os números
    let mut numeros = Vec::new();

    // Lê os números até o usuário digitar 0
    loop {
        println!("Digite um número (0 para encerrar):");

        // Lê o número do usuário
        let mut numero = String::new();
        std::io::stdin().read_line(&mut numero).unwrap();
        let numero: i32 = match numero.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        // Adiciona o número lido à lista
        numeros.push(numero);

        // Verifica se o usuário digitou 0 para encerrar
        if numero == 0 {
            break;
        }
    }

    // Verifica se há pelo menos um número na lista
    if !numeros.is_empty() {
        // Pega o último número da lista
        let ultimo_numero = numeros[numeros.len() - 1];

        // Conta quantos números na lista são iguais ao último número
        let mut contador = 0;
        for numero in numeros {
            if numero == ultimo_numero {
                contador += 1;
            }
        }

        println!("Foram lidos {} números iguais ao último número.", contador);
    } else {
        println!("Nenhum número foi lido.");
    }
}

===========================================================================================

16. Crie um programa para ler um conjunto de 100 números reais e informe:
• quantos números lidos são iguais a 30
• quantos são maior que a média
• quantos são iguais a média


fn main() {
    let mut contador_30 = 0;
    let mut contador_maior_media = 0;
    let mut contador_igual_media = 0;
    let mut soma = 0;

    for i in 0..100 {
        println!("Insira um número real: ");

        let mut input = String::new();
        std::io::stdin().read_line(&mut input).unwrap();
        let numero: f64 = input.trim().parse().unwrap();

        soma += numero;

        if numero == 30.0 {
            contador_30 += 1;
        }

        if numero > (soma / (i + 1) as f64) {
            contador_maior_media += 1;
        }

        if numero == (soma / (i + 1) as f64) {
            contador_igual_media += 1;
        }
    }

    println!("Números iguais a 30: {}", contador_30);
    println!("Números maior que a média: {}", contador_maior_media);
    println!("Números iguais a média: {}", contador_igual_media);
}

===========================================================================================
17. Faça um programa que leia um conjunto de 30 valores inteiros, armazene-os em
um vetor e os imprima ao contrário da ordem de leitura.


fn main() {
    // Declara um vetor de 30 elementos inteiros
    let mut vetor: [i32; 30] = [0; 30];

    // Lê os 30 valores e armazena no vetor
    for i in 0..30 {
        println!("Digite o {}º valor:", i + 1);
        let valor: i32 = read!();
        vetor[i] = valor;
    }

    // Imprime os elementos do vetor em ordem inversa
    for i in (0..30).rev() {
        println!("{}", vetor[i]);
    }
}



===========================================================================================

18. Faça um programa que permita entrar com dados para um vetor VET do tipo
inteiro com 20 posições, em que podem existir vários elementos repetidos. Gere
um vetor VET2 ordenado a partir do vetor VET e que terá apenas os elementos
não repetidos.

fn main() {
    // Declaração do vetor VET com 20 posições
    let mut vet: [i32; 20] = [0; 20];

    // Laço para ler os elementos do vetor VET
    for i in 0..20 {
        println!("Informe o elemento {} do vetor VET:", i+1);
        let elemento: i32 = read!();
        vet[i] = elemento;
    }

    // Declaração do vetor VET2
    let mut vet2: Vec<i32> = Vec::new();

    // Laço para percorrer o vetor VET
    for i in 0..20 {
        // Verifica se o elemento atual já está no vetor VET2
        let mut elemento_ja_existe = false;
        for j in 0..vet2.len() {
            if vet2[j] == vet[i] {
                elemento_ja_existe = true;
                break;
            }
        }

        // Se o elemento atual não estiver no vetor VET2, adiciona-o
        if !elemento_ja_existe {
            vet2.push(vet[i]);
        }
    }

    // Ordena o vetor VET2
    vet2.sort();

    // Imprime o vetor VET2
    println!("Vetor VET2: {:?}", vet2);
}





===========================================================================================

19. Suponha dois vetores de 30 elementos cada, contendo: código e telefone. Faça
um programa que permita buscar pelo código e imprimir o telefone.

fn main() {
    let codigos = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30];
    let telefones = ["123-4567", "234-5678", "345-6789", "456-7890", "567-8901", "678-9012", "789-0123", "890-1234", "901-2345", "012-3456", "123-4567", "234-5678", "345-6789", "456-7890", "567-8901", "678-9012", "789-0123", "890-1234", "901-2345", "012-3456", "123-4567", "234-5678", "345-6789", "456-7890", "567-8901", "678-9012", "789-0123", "890-1234", "901-2345", "012-3456"];
    let mut encontrado = false;

    println!("Insira o código a ser buscado:");
    let mut codigo_busca = String::new();
    std::io::stdin().read_line(&mut codigo_busca).expect("Falha ao ler a entrada");
    let codigo_busca: i32 = codigo_busca.trim().parse().expect("Por favor, insira um número válido");

    for i in 0..codigos.len() {
        if codigos[i] == codigo_busca {
            println!("O telefone correspondente ao código {} é {}", codigo_busca, telefones[i]);
            encontrado = true;
            break;
        }
    }

    if !encontrado {
        println!("O código {} não foi encontrado", codigo_busca);
    }
}



===========================================================================================

20. Faça um programa que leia a matrícula e a média de 100 alunos. Ordene da maior
para a menor nota e imprima uma relação contendo todas as matrículas e médias.

fn main() {
    let mut alunos = Vec::new();

    // Lê as informações dos alunos
    for _ in 0..100 {
        println!("Insira a matrícula e a média do aluno:");

        let mut input = String::new();
        std::io::stdin().read_line(&mut input).unwrap();

        let mut matricula = String::new();
        let mut media = String::new();
        scan!(input.bytes() => "{} {}", matricula, media);

        let media: f32 = media.trim().parse().unwrap();
        alunos.push((matricula, media));
    }

    // Ordena a lista de alunos pelo campo de média
    alunos.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());

    // Imprime a relação de matrículas e médias
    println!("Relação de matrículas e médias:");
    for (matricula, media) in alunos {
        println!("{}: {}", matricula, media);
    }
}


Matrizes


Em Rust, as matrizes são um tipo de dado composto que armazena um conjunto de elementos do mesmo tipo, todos em uma única estrutura. Elas são indexadas por um número inteiro e podem ser declaradas usando o símbolo [ e ]. Por exemplo:


let mut A: [[i32; 2]; 2] = [[0; 2]; 2];
Essa declaração cria uma matriz chamada A com 2 linhas e 2 colunas, do tipo inteiro. O tipo da matriz é especificado como [[i32; 2]; 2], o que significa que é uma matriz de 2 linhas, cada uma contendo um vetor de 2 elementos do tipo inteiro.

Você também pode usar a sintaxe [[0; 2]; 2] para inicializar a matriz com todos os elementos iguais a 0.

Para acessar os elementos de uma matriz, basta usar a mesma sintaxe de acesso aos elementos de um vetor. Por exemplo:


let x = A[0][1];
Esse código atribui o valor do elemento da primeira linha e segunda coluna da matriz A à variável x.

Você também pode usar laços para percorrer os elementos de uma matriz. Por exemplo:


for i in 0..2 {
    for j in 0..2 {
        println!("{}", A[i][j]);
    }
}
Esse código imprime todos os elementos da matriz A, linha por linha.

Ao passar uma matriz como parâmetro para uma função em Rust, é preciso especificar o tamanho de cada dimensão da matriz. Por exemplo:


fn print_matrix(A: [[i32; 2]; 2]) {
    for i in 0..2 {
        for j in 0..2 {
            println!("{}", A[i][j]);
        }
    }
}
Esse código cria uma função que imprime uma matriz de 2 linhas e 2 colunas do tipo inteiro.


Para declarar uma matriz em Rust, basta usar o tipo Vec<Vec<T>>, onde T é o tipo de dado que a matriz armazenará. Por exemplo:


let matriz: Vec<Vec<i32>> = vec![vec![1, 2, 3], vec![4, 5, 6]];
Essa matriz possui duas linhas e três colunas, e armazena valores do tipo i32. É possível também inicializar a matriz com valores específicos usando a função vec!.

É importante lembrar que, como a matriz é alocada dinamicamente na memória, é necessário fazer a verificação de índices antes de acessá-los, para evitar erros de segmentação. Por exemplo:


if matriz.len() > 0 && matriz[0].len() > 0 {
    println!("O elemento na primeira linha e primeira coluna é {}", matriz[0][0]);
}


Em Rust, você pode declarar arrays de duas dimensões da seguinte maneira:


// 20 refere-se ao número de linhas e 5 o número de colunas
let notas: [[f32; 5]; 20] = [[0.0; 5]; 20];

// 50 refere-se ao número de linhas e 3 o número de colunas
let dados: [[i32; 3]; 50] = [[0; 3]; 50];

// 30 refere-se ao número de linhas e 30 ao número de caracteres
let nomes: [[char; 30]; 30] = [[' '; 30]; 30];
Cada elemento de um array multidimensional é acessado através de índices. Por exemplo, para acessar o elemento na linha 3 e coluna 4 da matriz notas, você pode usar notas[3][4].

Observe que, em Rust, arrays são fixos em tamanho e não podem ser redimensionados. Se você precisar de uma estrutura de dados que possa ser facilmente redimensionada, pode usar uma Vec.


Atribuição e obtenção de valores em matriz

A atribuição e obtenção de valores em matriz segue os mesmos procedimentos rea-
lizados para um vetor, a única diferença será que, neste caso, é preciso informar as
dimensões no qual se deseja armazenar ou obter um valor. 
Em Rust, você pode criar uma matriz usando o tipo [T; n], onde T é o tipo de elemento da matriz e n é o tamanho da matriz. Por exemplo:


let mut matriz: [[i32; 3]; 3] = [[0; 3]; 3];
Isso cria uma matriz de 3 linhas e 3 colunas, onde todos os elementos são inicializados com o valor 0.

Para atribuir ou obter o valor de um elemento em uma matriz, você pode usar os colchetes [ ] e informar o índice da linha e da coluna desejada. Por exemplo:


// Atribuir o valor 10 ao elemento na linha 0, coluna 0
matriz[0][0] = 10;

// Obter o valor do elemento na linha 1, coluna 2
let valor = matriz[1][2];
Observe que os índices começam em 0. Portanto, para acessar o primeiro elemento da primeira linha, você deve usar matriz[0][0].

Você também pode usar a notação "ponto-e-vírgula" para acessar vários elementos de uma só vez. Por exemplo:


// Atribuir o valor 20 a todos os elementos da primeira linha
matriz[0; 3] = [20, 20, 20];

// Obter todos os elementos da segunda coluna
let coluna: [i32; 3] = matriz[0; 3];
Espero que isso tenha ajudado! Se tiver mais dúvidas, não hesite em perguntar.

Para acessar o valor que seria a segunda nota do segundo aluno na matriz, basta informar 1 para a linha e 1 para a coluna. Isso se deve à indexação das matrizes começando em 0, assim como acontece com vetores. 


/ Declarando a matriz matNotas como uma matriz de f32
let mut matNotas: [[f32; 4]; 3] = [[0.0; 4]; 3];

// Atribuindo valores a matriz matNotas
matNotas[1][2] = 2.5;
matNotas[2][2] = 3.0;

// Atribuindo valor com o scanf
println!("Informe a segunda nota do aluno");
let mut nota = String::new();
scanf("%f", &mut nota);
let nota: f32 = nota.trim().parse().unwrap();
matNotas[1][1] = nota;

// Atribuindo valor com cálculo de soma
matNotas[1][3] = matNotas[1][0] + matNotas[1][1] + matNotas[1][2];

// Imprimindo a partir de uma posição de matNotas
println!("Nota Final: {}", matNotas[1][3]);



Atribuição e acesso a valores com estrutura de iteração

É possível usar loops com matrizes também, mas geralmente precisamos de um loop para cada dimensão da matriz. Por exemplo, considerando a figura 19, precisaríamos de dois loops, pois a matriz tem duas dimensões: 4 linhas e 4 colunas



Exercício de Exemplo
Faça um programa em Rust que armazene as 3 notas de 4 alunos. Após a leitura o programa
deve calcular a nota final com o somatório das três notas. Ao final deve imprimir as
notas e a nota final para cada aluno.

fn main() {
    let mut alunos: Vec<Vec<i32>> = Vec::new();
    let mut nota_final: Vec<i32> = Vec::new();

    // lê as notas dos alunos
    for i in 0..4 {
        println!("Insira as 3 notas do aluno {}:", i+1);

        let mut notas: Vec<i32> = Vec::new();
        for _ in 0..3 {
            let mut nota = String::new();
            std::io::stdin().read_line(&mut nota).expect("Falha ao ler a nota");

            let nota: i32 = nota.trim().parse().expect("Por favor, digite um número inteiro");
            notas.push(nota);
        }

        alunos.push(notas);
    }

    // calcula a nota final para cada aluno
    for notas in alunos {
        let nota_final = notas.iter().sum();
        nota_final.push(nota_final);
    }

    // imprime as notas e a nota final para cada aluno
    for (i, notas) in alunos.iter().enumerate() {
        println!("Aluno {}: {:?} - Nota Final: {}", i+1, notas, nota_final[i]);
    }
}

Exercicios da aula:

Os exercícios desta lista foram Adaptados de Lopes e Garcia (2002, p. 340-367).

1. Faça um programa em Rust que leia os elementos de uma matriz do tipo inteiro com
tamanho 10 X 10. Ao final, imprima todos os elementos.

fn main() {
    // Declara a matriz com o tamanho de 10 x 10
    let mut matriz: [[i32; 10]; 10] = [[0; 10]; 10];

    // Lê os elementos da matriz
    for i in 0..10 {
        for j in 0..10 {
            println!("Insira o elemento da linha {} e coluna {}:", i+1, j+1);
            let mut elemento = String::new();
            std::io::stdin().read_line(&mut elemento).expect("Falha ao ler entrada");
            matriz[i][j] = elemento.trim().parse().expect("Falha ao converter para inteiro");
        }
    }

    // Imprime todos os elementos da matriz
    for i in 0..10 {
        for j in 0..10 {
            print!("{} ", matriz[i][j]);
        }
        println!();
    }
}

===============================================================================

2. Faça um programa que leia os elementos de uma matriz do tipo inteiro com
tamanho 3 X 3 e imprima os elementos multiplicando por 2.

fn main() {
    // Declara uma matriz de inteiros 3 x 3
    let mut matriz: [[i32; 3]; 3] = [[0; 3]; 3];

    // Lê os elementos da matriz
    for i in 0..3 {
        for j in 0..3 {
            println!("Digite o elemento da linha {} e da coluna {}:", i+1, j+1);
            let mut elemento = String::new();
            std::io::stdin().read_line(&mut elemento).expect("Falha ao ler o elemento");
            let elemento: i32 = elemento.trim().parse().expect("Falha ao converter o elemento para inteiro");
            matriz[i][j] = elemento;
        }
    }

    // Imprime os elementos da matriz multiplicados por 2
    println!("Elementos da matriz multiplicados por 2:");
    for i in 0..3 {
        for j in 0..3 {
            println!("{}", matriz[i][j] * 2);
        }
    }
}


===============================================================================
3. Crie um programa que armazene dados inteiros em uma matriz de ordem 5 e
imprima: Todos os elementos que se encontram em posições cuja linha mais
coluna formam um número par.

fn main() {
    // Declara a matriz de inteiros de ordem 5
    let mut matriz: [[i32; 5]; 5] = [[0; 5]; 5];

    // Preenche a matriz com valores aleatórios
    for i in 0..5 {
        for j in 0..5 {
            matriz[i][j] = (i + j) as i32;
        }
    }

    // Imprime todos os elementos da matriz cuja linha mais coluna formam um número par
    for i in 0..5 {
        for j in 0..5 {
            if (i + j) % 2 == 0 {
                println!("matriz[{}][{}] = {}", i, j, matriz[i][j]);
            }
        }
    }
}


===============================================================================
4. Construa um programa que armazene dados em uma matriz de ordem 4 e im-
prima: Todos os elementos com números ímpares.

fn main() {
    // Cria uma matriz de 4x4 com números aleatórios
    let mut matriz: [[i32; 4]; 4] = [[0; 4]; 4];
    for i in 0..4 {
        for j in 0..4 {
            matriz[i][j] = rand::random::<i32>();
        }
    }

    // Imprime todos os elementos ímpares da matriz
    println!("Elementos ímpares da matriz:");
    for i in 0..4 {
        for j in 0..4 {
            if matriz[i][j] % 2 != 0 {
                println!("{}", matriz[i][j]);
            }
        }
    }
}


===============================================================================
5. Faça um programa que permita entrar com valores em uma matriz A de tamanho
3 X 4. Gerar e imprimir uma matriz B que é o triplo da matriz A.

fn main() {
    // Declara a matriz A com 3 linhas e 4 colunas
    let mut matriz_a: [[i32; 4]; 3] = [[0; 4]; 3];

    // Preenche a matriz A com valores digitados pelo usuário
    for i in 0..3 {
        for j in 0..4 {
            println!("Insira o valor para a posição [{}, {}] da matriz A:", i, j);
            let mut valor = String::new();
            std::io::stdin().read_line(&mut valor).expect("Falha ao ler entrada");
            matriz_a[i][j] = valor.trim().parse().expect("Falha ao converter para inteiro");
        }
    }

    // Declara a matriz B com 3 linhas e 4 colunas
    let mut matriz_b: [[i32; 4]; 3] = [[0; 4]; 3];

    // Preenche a matriz B com o triplo dos valores da matriz A
    for i in 0..3 {
        for j in 0..4 {
            matriz_b[i][j] = matriz_a[i][j] * 3;
        }
    }

    // Imprime a matriz B
    println!("Matriz B:");
    for i in 0..3 {
        for j in 0..4 {
            print!("{} ", matriz_b[i][j]);
        }
        println!();
    }
}

===============================================================================
6. Crie um programa que leia valores inteiros em uma matriz A[2][2] e em uma
matriz B[2][2]. Gerar e imprimir a matriz SOMA[2][2].


fn main() {
    // Declara as matrizes A e B como arrays de duas dimensões de inteiros
    let mut A: [[i32; 2]; 2] = [[0; 2]; 2];
    let mut B: [[i32; 2]; 2] = [[0; 2]; 2];

    // Lê os valores das matrizes A e B
    println!("Insira os valores da matriz A:");
    for i in 0..2 {
        for j in 0..2 {
            println!("Insira o elemento A[{}][{}]:", i, j);
            let mut elemento = String::new();
            std::io::stdin().read_line(&mut elemento).expect("Falha ao ler entrada");
            A[i][j] = elemento.trim().parse().expect("Por favor, insira um número inteiro válido");
        }
    }

    println!("Insira os valores da matriz B:");
    for i in 0..2 {
        for j in 0..2 {
            println!("Insira o elemento B[{}][{}]:", i, j);
            let mut elemento = String::new();
            std::io::stdin().read_line(&mut elemento).expect("Falha ao ler entrada");
            B[i][j] = elemento.trim().parse().expect("Por favor, insira um número inteiro válido");
        }
    }

    // Declara a matriz SOMA como array de duas dimensões de inteiros
    let mut SOMA: [[i32; 2]; 2] = [[0; 2]; 2];

    // Calcula a matriz SOMA como a soma das matrizes A e B
    for i in 0..2 {
        for j in 0..2 {
            SOMA[i][j] = A[i][j] + B[i][j];
        }
    }

    // Imprime a matriz SOMA
    println!("Matriz SOMA:");
    for i in 0..2 {
        for j in 0..2 {
            print!("{} ", SOMA[i][j]);
        }
        println!();
    }
}


===============================================================================
7. Construa um programa para ler valores para duas matrizes do tipo inteiro de
ordem 3. Gerar e imprimir a matriz diferença.

fn main() {
    let mut matriz1: [[i32; 3]; 3] = [[0; 3]; 3];
    let mut matriz2: [[i32; 3]; 3] = [[0; 3]; 3];
    let mut matriz_diferenca: [[i32; 3]; 3] = [[0; 3]; 3];

    // Leitura dos valores para as matrizes 1 e 2
    for i in 0..3 {
        for j in 0..3 {
            println!("Digite o valor para a posição ({}, {}) da matriz 1:", i, j);
            std::io::stdin().read_line(&mut matriz1[i][j].to_string())
                .expect("Falha ao ler o valor da matriz 1");

            println!("Digite o valor para a posição ({}, {}) da matriz 2:", i, j);
            std::io::stdin().read_line(&mut matriz2[i][j].to_string())
                .expect("Falha ao ler o valor da matriz 2");
        }
    }

    // Calculo da matriz diferença
    for i in 0..3 {
        for j in 0..3 {
            matriz_diferenca[i][j] = matriz1[i][j] - matriz2[i][j];
        }
    }

    // Impressão da matriz diferença
    println!("Matriz diferença:");
    for i in 0..3 {
        for j in 0..3 {
            print!("{} ", matriz_diferenca[i][j]);
        }
        println!();
    }
}
===============================================================================
8. Faça um programa que leia uma matriz 4 X 5 de inteiros, calcule e imprima a
soma de todos os seus elementos.

fn main() {
    // Declara a matriz como uma array de arrays de inteiros
    let matriz: [[i32; 5]; 4] = [
        [1, 2, 3, 4, 5],
        [6, 7, 8, 9, 10],
        [11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20],
    ];

    // Declara a variável "soma" para armazenar a soma dos elementos da matriz
    let mut soma = 0;

    // Usa um loop "for" para percorrer cada linha da matriz
    for linha in matriz.iter() {
        // Usa outro loop "for" para percorrer cada elemento da linha atual
        for elemento in linha.iter() {
            // Adiciona o elemento atual à variável "soma"
            soma += elemento;
        }
    }

    // Imprime o resultado final da soma
    println!("A soma de todos os elementos da matriz é: {}", soma);
}



===============================================================================
9. Construa um programa que leia valores inteiros para a matriz A3 x 5 . Gerar e
imprimir a matriz SOMALINHA, em que cada elemento é a soma dos elementos
de uma linha da matriz A. Faça o trecho que gera a matriz separado da entrada e
da saída.


fn main() {
    let mut matriz_a: [[i32; 5]; 3] = [[0; 5]; 3]; // declaração da matriz A como uma matriz 3x5 de inteiros

    // preenche a matriz A
    for i in 0..3 {
        for j in 0..5 {
            println!("Insira o elemento A[{}][{}]:", i, j);
            let elemento: i32 = ler_entrada(); // lê o elemento da matriz
            matriz_a[i][j] = elemento; // atribui o elemento lido à posição i, j da matriz A
        }
    }

    let mut matriz_somalinha: [i32; 3] = [0; 3]; // declaração da matriz SOMALINHA como um vetor de 3 elementos

    // preenche a matriz SOMALINHA
    for i in 0..3 {
        for j in 0..5 {
            matriz_somalinha[i] += matriz_a[i][j]; // soma os elementos da linha i da matriz A e armazena o resultado na posição i da matriz SOMALINHA
        }
    }

    // imprime a matriz SOMALINHA
    for i in 0..3 {
        println!("SOMALINHA[{}] = {}", i, matriz_somalinha[i]);
    }
}

// função para ler um inteiro da entrada padrão
fn ler_entrada() -> i32 {
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).expect("Falha ao ler entrada");
    input.trim().parse().expect("Falha ao converter entrada para inteiro")
}




===============================================================================

10. Construa um programa que leia valores inteiros para a matriz A3 x 5 . Gerar e
imprimir a matriz SOMACOLUNA, em que cada elemento é a soma dos elementos
de uma coluna da matriz A. Faça o trecho que gera a matriz separado da entrada
e da saída.


fn main() {
    // Declara a matriz A como uma matriz 3x5 de inteiros
    let mut A: [[i32; 5]; 3] = [[0; 5]; 3];

    // Lê os valores para a matriz A
    for i in 0..3 {
        for j in 0..5 {
            println!("Insira o elemento A[{}][{}]:", i, j);
            let mut elemento = String::new();
            stdin().read_line(&mut elemento).unwrap();
            A[i][j] = elemento.trim().parse().unwrap();
        }
    }

    // Declara a matriz SOMACOLUNA como uma matriz 1x5 de inteiros
    let mut SOMACOLUNA: [i32; 5] = [0; 5];

    // Calcula a soma dos elementos de cada coluna da matriz A e armazena o resultado em SOMACOLUNA
    for j in 0..5 {
        for i in 0..3 {
            SOMACOLUNA[j] += A[i][j];
        }
    }

    // Imprime a matriz SOMACOLUNA
    println!("Matriz SOMACOLUNA:");
    for i in 0..1 {
        for j in 0..5 {
            print!("{} ", SOMACOLUNA[j]);
        }
        println!();
    }
}





===============================================================================
11. Entrar com valores para uma matriz C 2 x 3 . Gerar e imprimir a Ct .
A matriz transposta é gerada trocando linha por coluna. Veja o exemplo a seguir:

fn main() {
    // Declara a matriz C como uma matriz 2x3 de números inteiros
    let mut c: [[i32; 3]; 2] = [[0; 3]; 2];

    // Lê valores para a matriz C
    println!("Digite os valores para a matriz C 2x3:");
    for i in 0..2 {
        for j in 0..3 {
            println!("C[{}][{}] = ", i, j);
            let mut valor = String::new();
            std::io::stdin().read_line(&mut valor).expect("Falha ao ler a entrada");
            c[i][j] = valor.trim().parse().expect("Falha ao converter para inteiro");
        }
    }

    // Declara a matriz transposta como uma matriz 3x2 de números inteiros
    let mut ct: [[i32; 2]; 3] = [[0; 2]; 3];

    // Gera a matriz transposta
    for i in 0..3 {
        for j in 0..2 {
            ct[i][j] = c[j][i];
        }
    }

    // Imprime os valores da matriz transposta
    println!("Matriz transposta:");
    for i in 0..3 {
        for j in 0..2 {
            print!("{} ", ct[i][j]);
        }
        println!();
    }
}




===============================================================================

12. Uma floricultura conhecedora de sua clientela gostaria de fazer um programa que
pudesse controlar sempre um estoque mínimo de determinadas plantas, pois
todo dia, pela manhã, o dono faz novas aquisições. Criar um algoritmo que deixe
cadastrar 50 plantas, nome, estoque mínimo, estoque atual. Imprimir ao final do
programa uma lista das plantas que devem ser adquiridas.

fn main() {
    let mut plantas = Vec::new();

    for i in 0..50 {
        println!("Insira o nome da planta {}:", i + 1);
        let mut nome = String::new();
        std::io::stdin().read_line(&mut nome).expect("Falha ao ler a entrada");

        println!("Insira o estoque mínimo da planta {}:", i + 1);
        let mut estoque_minimo = String::new();
        std::io::stdin().read_line(&mut estoque_minimo).expect("Falha ao ler a entrada");
        let estoque_minimo: u32 = estoque_minimo.trim().parse().expect("Por favor, insira um número válido");

        println!("Insira o estoque atual da planta {}:", i + 1);
        let mut estoque_atual = String::new();
        std::io::stdin().read_line(&mut estoque_atual).expect("Falha ao ler a entrada");
        let estoque_atual: u32 = estoque_atual.trim().parse().expect("Por favor, insira um número válido");

        plantas.push((nome, estoque_minimo, estoque_atual));
    }

    println!("As seguintes plantas devem ser adquiridas:");
    for (nome, estoque_minimo, estoque_atual) in plantas {
        if estoque_atual < estoque_minimo {
            println!("{}", nome);
        }
    }
}

===============================================================================


13. A gerente do cabeleireiro Sempre Bela tem uma tabela em que registra as quan-
tidades de serviços executados nos "pes", nas "mãos"e o serviço de podologia
das cinco manicures. Sabendo-se que cada uma ganha 50% do que faturou ao
mês, criar um programa que possa calcular e imprimir quanto cada uma vai
receber, uma vez que não têm carteiras assinadas, os valores, respectivamente,
são: R$10,00, R$15,00 e R$30,00.


fn main() {
    let valores = [10, 15, 30]; // valores dos serviços
    let mut faturamento_total = [0, 0, 0, 0, 0]; // faturamento total de cada manicure
    let mut valor_recebido = [0, 0, 0, 0, 0]; // valor a ser recebido por cada manicure

    // Solicita os dados de faturamento para cada manicure
    for i in 0..5 {
        println!("Insira o faturamento da manicure {} nos pes: ", i + 1);
        let mut faturamento = String::new();
        std::io::stdin().read_line(&mut faturamento).unwrap();
        let faturamento: u32 = faturamento.trim().parse().unwrap();
        faturamento_total[i] += faturamento;

        println!("Insira o faturamento da manicure {} nas mãos: ", i + 1);
        let mut faturamento = String::new();
        std::io::stdin().read_line(&mut faturamento).unwrap();
        let faturamento: u32 = faturamento.trim().parse().unwrap();
        faturamento_total[i] += faturamento;

        println!("Insira o faturamento da manicure {} na podologia: ", i + 1);
        let mut faturamento = String::new();
        std::io::stdin().read_line(&mut faturamento).unwrap();
        let faturamento: u32 = faturamento.trim().parse().unwrap();
        faturamento_total[i] += faturamento;
    }

    // Calcula o valor a ser recebido por cada manicure
    for i in 0..5 {
        valor_recebido[i] = (faturamento_total[i] * 50) / 100;
    }

    // Imprime o valor a ser recebido por cada manicure
    for i in 0..5 {
        println!("A manicure {} vai receber R$ {}", i + 1, valor_recebido[i]);
    }
}


===============================================================================
14. Crie um programa que leia e armazene os elementos de uma matriz inteira com
tamanho 5 X 5 e imprimi-la. Troque, a seguir:
• a segunda linha pela quinta;
• a terceira coluna pela quinta;
• a diagonal principal pela diagonal secundária.

fn main() {
    // Declara a matriz com tamanho 5x5 e inicializa todos os elementos com 0
    let mut matriz: [[i32; 5]; 5] = [[0; 5]; 5];

    // Lê os elementos da matriz
    println!("Insira os elementos da matriz:");
    for i in 0..5 {
        for j in 0..5 {
            println!("Insira o elemento da linha {} e coluna {}:", i+1, j+1);
            let elemento: i32 = read!();
            matriz[i][j] = elemento;
        }
    }

    // Imprime a matriz inicial
    println!("Matriz inicial:");
    for i in 0..5 {
        for j in 0..5 {
            print!("{} ", matriz[i][j]);
        }
        println!();
    }

    // Troca a segunda linha pela quinta
    let linha_2 = matriz[1];
    matriz[1] = matriz[4];
    matriz[4] = linha_2;

    // Troca a terceira coluna pela quinta
    for i in 0..5 {
        let temp = matriz[i][2];
        matriz[i][2] = matriz[i][4];
        matriz[i][4] = temp;
    }

    // Troca a diagonal principal pela diagonal secundária
    for i in 0..5 {
        let temp = matriz[i][i];
        matriz[i][i] = matriz[i][4-i];
        matriz[i][4-i] = temp;
    }

    // Imprime a matriz final
    println!("Matriz final:");
    for i in 0..5 {
        for j in 0..5 {
            print!("{} ", matriz[i][j]);
        }
        println!();
    }
}


===============================================================================
15. A matriz dados contém na 1ª coluna a matrícula do aluno; na 2ª, o sexo (0 para
    feminino e 1 para masculino); na 3ª, o código do curso, e na 4ª, o CR (coeficiente
    de rendimento).
    Faça um programa que armazene esses dados sabendo-se que o código do curso
    é uma parte da matrícula: aascccnnn (aa ano, s semestre, ccc código do curso e
    nnn matrícula no curso).
    Além disso, um grupo empresarial resolveu premiar a aluna com CR mais alto de
    um curso cujo código deverá ser digitado. Suponha 10 alunos e que o CR é um nº
    inteiro.
    
    fn main() {
        let mut dados = [[0; 4] ; 10]; // matriz com 10 linhas e 4 colunas, todos os elementos inicializados com 0
        let mut maior_cr = 0; // variável para armazenar o maior CR
        let mut codigo_curso: i32; // variável para armazenar o código do curso
        let mut aluno_premiado = 0; // variável para armazenar o índice da linha da aluna premiada
    
        // preencher a matriz "dados"
        for i in 0..10 {
            println!("Digite a matricula do aluno {}:", i+1);
            let matricula: i32 = read!();
            println!("Digite o sexo do aluno {} (0 para feminino, 1 para masculino):", i+1);
            let sexo: i32 = read!();
            println!("Digite o CR do aluno {}:", i+1);
            let cr: i32 = read!();
            dados[i][0] = matricula;
            dados[i][1] = sexo;
            dados[i][2] = matricula / 100000 % 1000; // código do curso é a 3ª, 4ª e 5ª dígitos da matrícula
            dados[i][3] = cr;
        }
    
        println!("Digite o código do curso para premiar a aluna com o maior CR:");
        codigo_curso = read!();
    
        // procurar a aluna com o maior CR no curso especificado
        for i in 0..10 {
            if dados[i][2] == codigo_curso {
                if dados[i][3] > maior_cr {
                    maior_cr = dados[i][3];
                    aluno_premiado = i;
                }
            }
        }
    
        // imprimir os dados da aluna premiada
        println!("A aluna premiada é a de matrícula {}", dados[aluno_premiado][0]);
        println!("Sexo: {}", if dados[aluno_premiado][1] == 0 { "feminino" } else { "masculino" });
        println!("CR: {}", dados[aluno_premiado][3]);
    }

    
===============================================================================
16. Faça um programa que possa armazenar as alturas de dez atletas de cinco
delegações que participarão dos jogos de verão. Imprimir a maior altura de cada
delegação.


fn main() {
    let mut alturas: [f64; 50] = [0.0; 50]; // Declara um array de 50 elementos, todos inicializados com 0.0

    // Lê as alturas dos atletas
    for i in 0..50 {
        println!("Insira a altura do atleta {}:", i + 1);
        alturas[i] = read!();
    }

    // Encontra a maior altura de cada delegação
    for i in 0..5 {
        let mut maior_altura = 0.0;
        for j in (i * 10)..((i + 1) * 10) {
            if alturas[j] > maior_altura {
                maior_altura = alturas[j];
            }
        }
        println!("A maior altura da delegação {} é {}", i + 1, maior_altura);
    }
}


===============================================================================
17. A Viação José Maria Rodrigues tem na Rodoviária de Rio Novo uma tabela con-
tendo os horários de partidas dos ônibus para Juiz de Fora nos sete dias da
semana. Faça um programa que possa armazenar esses horários e os horários do
dia quando forem solicitados pelo funcionário, sabendo-se que, no máximo, são
dez horários. Ao final, o programa deve imprimir a lista de horários para todos os
dias.



fn main() {
    // Cria um vetor de strings para armazenar os dias da semana
    let dias_semana = ["Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sábado", "Domingo"];

    // Cria um vetor de vetores de strings para armazenar os horários
    let mut horarios = Vec::new();

    // Itera pelos dias da semana
    for dia in dias_semana.iter() {
        // Exibe a mensagem pedindo os horários para o dia atual
        println!("Insira os horários para {}:", dia);

        // Cria um vetor de strings para armazenar os horários do dia atual
        let mut horarios_dia = Vec::new();

        // Itera até que o usuário insira todos os horários para o dia atual
        loop {
            // Lê o horário inserido pelo usuário
            let mut horario = String::new();
            std::io::stdin().read_line(&mut horario).expect("Falha ao ler entrada");

            // Remove o caractere de nova linha do final da string
            horario.pop();

            // Se o usuário inseriu o valor "fim", sai do loop
            if horario == "fim" {
                break;
            }

            // Adiciona o horário lido ao vetor de horários do dia atual
            horarios_dia.push(horario);
        }

        // Adiciona o vetor de horários do dia atual ao vetor de horários
        horarios.push(horarios_dia);
    }

    // Itera pelos dias da semana
    for (i, dia) in dias_semana.iter().enumerate() {
        // Exibe os horários para o dia atual
        println!("Horários para {}:", dia);
        for horario in &horarios[i] {
            println!("- {}", horario);
        }
    }
}

===============================================================================
18. Faça um programa que leia uma matriz 5 X 5 inteira e apresente uma determinada
linha da matriz, solicitada via teclado.


fn main() {
    // Declara a matriz 5 x 5
    let mut matriz: [[i32; 5]; 5] = [[0; 5]; 5];

    // Lê os valores da matriz
    for i in 0..5 {
        for j in 0..5 {
            println!("Digite o valor da posição ({}, {}) da matriz:", i, j);
            let mut valor = String::new();
            std::io::stdin().read_line(&mut valor).expect("Erro ao ler a entrada");
            matriz[i][j] = valor.trim().parse().expect("Erro ao converter para inteiro");
        }
    }

    // Lê o índice da linha a ser apresentada
    println!("Digite o índice da linha da matriz que deseja apresentar:");
    let mut indice_linha = String::new();
    std::io::stdin().read_line(&mut indice_linha).expect("Erro ao ler a entrada");
    let indice_linha: usize = indice_linha.trim().parse().expect("Erro ao converter para inteiro");

    // Verifica se o índice da linha é válido
    if indice_linha < 0 || indice_linha >= 5 {
        println!("O índice da linha é inválido. Por favor, digite um índice entre 0 e 4.");
        return;
    }

    // Apresenta a linha da matriz
    println!("Linha {} da matriz:", indice_linha);
    for j in 0..5 {
        println!("{}", matriz[indice_linha][j]);
    }
}






===============================================================================
19. Construa um programa que carregue uma matriz 12 X 4 com os valores das vendas
de uma loja, em cada linha represente um mês do ano, e cada coluna, uma semana
do mês. Calcule e imprima:
• total vendido em cada mês do ano;
• total vendido em cada semana durante todo o ano;
• total vendido no ano.

use std::io;

fn main() {
// Declara a matriz de vendas
let mut vendas: [[i32; 4]; 12] = [[0; 4]; 12];

// Lê os valores de cada mês e semana da matriz
for i in 0..12 {
    println!("Mês {}:", i + 1);
    for j in 0..4 {
        println!("Semana {}:", j + 1);
        let mut valor = String::new();
        io::stdin().read_line(&mut valor).expect("Erro ao ler a entrada");
        vendas[i][j] = valor.trim().parse().expect("Erro ao converter para número");
    }
}

// Calcula o total vendido em cada mês do ano
for i in 0..12 {
    let mut total_mes = 0;
    for j in 0..4 {
        total_mes += vendas[i][j];
    }
    println!("Total vendido no mês {}: {}", i + 1, total_mes);
}

// Calcula o total vendido em cada semana durante todo o ano
for j in 0..4 {
    let mut total_semana = 0;
    for i in 0..12 {
        total_semana += vendas[i][j];
    }
    println!("Total vendido na semana {}: {}", j + 1, total_semana);
}

// Calcula o total vendido no ano
let mut total_ano = 0;
for i in 0..12 {
    for j in 0..4 {
        total_ano += vendas[i][j];
    }
}
println!("Total vendido no ano: {}", total_ano);







===============================================================================
20. Supondo que uma matriz apresente em cada linha o total de produtos vendidos ao
mês por uma loja que trabalha com cinco tipos diferentes de produtos, construir
um programa que leia esse total e, ao final, apresente o total de produtos vendidos
em cada mês e o total de vendas por ano por produto.


fn main() {
    // Matriz com os totais de produtos vendidos por mês e por produto
    let vendas = [        [10, 20, 30, 40, 50],  // mês 1
        [20, 30, 40, 50, 60],  // mês 2
        [30, 40, 50, 60, 70],  // mês 3
        [40, 50, 60, 70, 80],  // mês 4
        [50, 60, 70, 80, 90],  // mês 5
        [60, 70, 80, 90, 100], // mês 6
        [70, 80, 90, 100, 110], // mês 7
        [80, 90, 100, 110, 120], // mês 8
        [90, 100, 110, 120, 130], // mês 9
        [100, 110, 120, 130, 140], // mês 10
        [110, 120, 130, 140, 150], // mês 11
        [120, 130, 140, 150, 160], // mês 12
    ];

    // Variáveis para armazenar os totais
    let mut total_produtos = [0; 5]; // total por produto
    let mut total_vendas = 0; // total de vendas por ano

    // Iterar pelos meses
    for mês in 0..12 {
        // Iterar pelos produtos
        for produto in 0..5 {
            // Adicionar ao total de produtos vendidos por produto
            total_produtos[produto] += vendas[mês][produto];
        }

        // Adicionar ao total de vendas por ano
        total_vendas += vendas[mês].iter().sum::<i32>();
    }

    // Exibir os totais
    println!("Total de produtos vendidos por produto:");
    for (i, total) in total_produtos.iter().enumerate() {
        println!("Produto {}: {}", i + 1, total);
    }
    println!("Total de vendas por ano: {}", total_vendas);
}






===============================================================================




Tipos de Dados definidos pelo Programador


Tipo de dado


Em Rust, os tipos de dados primitivos incluem inteiros, reais, caracteres e booleanos. Além disso, é possível criar tipos de dados personalizados através de estruturas de dados, também conhecidas como "structs". Estas permitem armazenar dados de tipos diferentes em uma única estrutura, tornando mais fácil trabalhar com dados heterogêneos. Por exemplo, para armazenar os dados de um cliente mencionados no texto acima, poderíamos criar uma struct chamada "Cliente" que contenha campos para o nome, CPF, data de nascimento e endereço.


struct Cliente {
    nome: String,
    cpf: String,
    data_nascimento: String,
    endereco: String,
}
Com esta estrutura, podemos criar um objeto do tipo "Cliente" e atribuir valores aos seus campos.


let c = Cliente {
    nome: "João da Silva".to_string(),
    cpf: "123.456.789-00".to_string(),
    data_nascimento: "01/01/1970".to_string(),
    endereco: "Rua das Flores, 123".to_string(),
};
Além disso, é possível criar tipos de dados personalizados utilizando enums, que permitem armazenar um conjunto de valores pré-definidos. Por exemplo, para armazenar o estado civil de um cliente, poderíamos criar um enum chamado "EstadoCivil" com os valores "Solteiro", "Casado" e "Divorciado".


enum EstadoCivil {
    Solteiro,
    Casado,
    Divorciado,
}
Em seguida, poderíamos adicionar um campo do tipo "EstadoCivil" à nossa struct "Cliente".


struct Cliente {
    nome: String,
    cpf: String,
    data_nascimento: String,
    endereco: String,
    estado_civil: EstadoCivil,
}
Com isso, podemos atribuir um dos valores do enum "EstadoCivil" ao campo "estado_civil" de um objeto do tipo "Cliente".


let c = Cliente {
    nome: "João da Silva".to_string(),
    cpf: "123.456.789-00".to_string(),
    data_nascimento: "01/01/1970".to_string(),
    endereco: "Rua das Flores, 123".to_string(),
    estado_civil: EstadoCivil::Solteiro,
};



Estruturas de dados
Quando o programador precisa definir um tipo de dado heterogêneo, é necessário declarar uma estrutura de dados, que é uma coleção de dados de qualquer tipo, incluindo tipos já previamente definidos pelo programador. Dessa forma, é possível definir uma estrutura de dados heterogênea. Os dados que fazem parte da estrutura são chamados campos.
Por exemplo, na figura 20, o nome da estrutura é funcionário e os campos pertencentes à esta estrutura são: cod, nome, salário, depto e cargo. Cada campo tem um tipo específico, como o campo nome armazena texto e o campo cod armazena números. Dessa forma, esta estrutura funcionário é heterogênea.
Para entender bem o que são esses elementos, basta fazer uma analogia: a estrutura é o equivalente à planta de uma casa, o tipo de dado é uma planta padrão que é usada para construir várias casas e a variável definida a partir de uma estrutura ou um tipo de dado é a casa em si. Ou seja, a estrutura de dados é a definição ou característica que terá o tipo de dado ou a variável, o tipo de dado é um padrão de estrutura e a variável é a referência para a memória alocada com as características do tipo definido pelo programador.

Estruturas de dados em Rust
Assim como na linguagem Rust, Rust permite a criação de estruturas para definir o tipo de dado que o programador pretende construir. A sintaxe para definir uma estrutura em Rust é semelhante à sintaxe em C.

Exemplo de sintaxe para definir uma estrutura em Rust:


struct NomeDaEstrutura {
    campo1: tipo1,
    campo2: tipo2,
    ...
    campoN: tipoN,
}
Assim como na linguagem Rust, cada campo da estrutura é definido como se fosse uma variável, informando o tipo e o nome do campo. O nome da estrutura e dos campos devem seguir o mesmo padrão de nomenclatura de variáveis em Rust.

Veja a seguir um exemplo de estrutura em Rust:


struct Funcionario {
    cod: i32,
    nome: String,
    salario: f32,
    depto: i32,
    cargo: i32,
}
Neste exemplo, a estrutura foi denominada "Funcionario" e os campos são "cod" do tipo i32 (inteiro de 32 bits), "nome" do tipo String (sequência de caracteres), "salario" do tipo f32 (ponto flutuante de 32 bits), "depto" e "cargo" do tipo i32. Como em Rust é possível definir campos de qualquer tipo, incluindo tipos customizados criados pelo programador, a escolha dos tipos e tamanhos dos campos dependerá da necessidade do problema.



Variáveis e tipos de dados de estruturas


Para utilizar uma estrutura, primeiro é preciso definir sua estrutura. Depois, é possível criar uma variável ou um tipo de dado com base na estrutura. Se criarmos uma variável com base em uma estrutura, estamos alocando espaço na memória com as características definidas na estrutura. Por outro lado, ao criarmos um tipo de dado baseado em uma estrutura, estamos criando um padrão para ser utilizado com base naquela estrutura. Isso significa que poderemos utilizar a estrutura várias vezes. Se a estrutura só será utilizada poucas vezes, não há necessidade de criar um tipo de dado para ela, mas isso não é uma regra. Criar uma variável com base em uma estrutura é simples: basta substituir o tipo da variável pelo "struct" seguido do nome da estrutura, como no exemplo a seguir: "struct nomeEstrutura nomeVariável;".

struct Funcionario {
    cod: i32,
    nome: String,
    salario: f32,
    depto: i32,
    cargo: i32,
}

fn main() {
    let func1 = Funcionario { cod: 0, nome: String::new(), salario: 0.0, depto: 0, cargo: 0 };
    let func2 = Funcionario { cod: 0, nome: String::new(), salario: 0.0, depto: 0, cargo: 0 };
}


A estrutura foi propositadamente repetida no exemplo para tornar mais claro o entendimento. Note que o nome da estrutura na linha 4, funcionario, é idêntico ao nome da estrutura na definição da variável, na linha 14. Isso permitirá à linguagem Rust determinar qual estrutura é desejada na definição da variável. Note também que foram declaradas duas variáveis para a mesma estrutura, no caso, func1 e func2. O formato de declaração é o mesmo que a declaração de variáveis apresentada na aula 1, bastando separar por "," quando desejar declarar mais de uma variável para o mesmo tipo.

Após a declaração da variável, a forma de uso é similar à de uma variável tradicional, a única diferença é que deve-se indicar o nome da variável e o campo no qual deseja-se armazenar o dado. É importante notar que não é necessário que todos os campos da variável sejam preenchidos. O exemplo foi complementado para mostrar como atribuir dados às variáveis de estrutura.


struct funcionario {
    char nome[50];
    int idade;
    float salario;
}

fn main() {
    let func1: funcionario;
    let func2: funcionario;

    func1.nome = "João";
    func1.idade = 30;
    func1.salario = 1500.50;

    func2.nome = "Maria";
    func2.idade = 25;
    func2.salario = 2000.00;
}

Aqui está o mesmo código em Rust:


struct Funcionario {
    cod: i32,
    nome: String,
    salario: f32,
    depto: i32,
    cargo: i32,
}

fn main() {
    let mut func1 = Funcionario {
        cod: 1,
        nome: "Joao".to_string(),
        salario: 1200.0,
        depto: 0,
        cargo: 0,
    };

    println!("Codigo: {}", func1.cod);
    println!("Nome: {}", func1.nome);
    println!("Salario: {}", func1.salario);

    println!("Informe o codigo:");
    let mut cod = String::new();
    std::io::stdin().read_line(&mut cod).unwrap();
    func1.cod = cod.trim().parse().unwrap();

    println!("Informe o nome:");
    let mut nome = String::new();
    std::io::stdin().read_line(&mut nome).unwrap();
    func1.nome = nome.trim().to_string();

    println!("Informe o salario:");
    let mut salario = String::new();
    std::io::stdin().read_line(&mut salario).unwrap();
    func1.salario = salario.trim().parse().unwrap();

    println!("Codigo: {}", func1.cod);
    println!("Nome: {}", func1.nome);
    println!("Salario: {}", func1.salario);
}
Observe que há algumas diferenças importantes entre o código C e o código Rust:

Em Rust, os nomes de tipos (como struct) e de funções (como main) são escritos com a primeira letra maiúscula.
Em vez de usar a macro printf, Rust usa a função println! para imprimir na tela.
Em vez de usar a função scanf, Rust usa a função std::io::stdin().read_line para ler uma linha de texto do teclado.
Rust não permite a atribuição direta de valores para campos de um struct, como é feito com func1.cod = 1. Em vez disso, é preciso criar um novo struct com os valores desejados usando o sintaxe de inicialização Funcionario { cod: 1, nome: "Joao".to_string(), ... }.
Em Rust, é preciso fazer a conversão de tipos explicitamente quando lendo valores do teclado, usando as funções trim().parse().unwrap().

Para definir um tipo de dado em Rust com base em outro tipo, você pode usar a palavra-chave type. Aqui está como fazer isso:


struct Funcionario {
    cod: i32,
    nome: String,
    salario: f32,
    depto: i32,
    cargo: i32,
}

type NovoNome = Funcionario;

fn main() {
    let func1 = NovoNome {
        cod: 1,
        nome: "Joao".to_string(),
        salario: 1200.0,
        depto: 0,
        cargo: 0,
    };

    println!("Codigo: {}", func1.cod);
    println!("Nome: {}", func1.nome);
    println!("Salario: {}", func1.salario);
}
Neste exemplo, o tipo NovoNome é definido como sendo equivalente ao tipo Funcionario. Depois disso, você pode usar o tipo NovoNome da mesma forma que usaria o tipo Funcionario.


Em Rust, você pode usar a palavra-chave type para definir um novo nome para um tipo existente, assim como é feito com typedef em C. No entanto, ao contrário de C, é preciso especificar o tipo de uma variável explicitamente usando a sintaxe let x: Inteiro = 10, em vez de simplesmente atribuir um valor como é feito em C.
type Inteiro = i32;
type Real = f32;
type Caractere = char;

fn main() {
    let x: Inteiro = 10;
    let y: Real = 3.14;
    let z: Caractere = 'A';

    println!("x = {}", x);
    println!("y = {}", y);
    println!("z = {}", z);
}


struct Funcionario {
    cod: i32,
    nome: String,
    salario: f32,
    depto: i32,
    cargo: i32,
}

type NovoTipo = Funcionario;

fn main() {
    let func1 = NovoTipo {
        cod: 1,
        nome: "Joao".to_string(),
        salario: 1200.0,
        depto: 0,
        cargo: 0,
    };

    println!("Codigo: {}", func1.cod);
    println!("Nome: {}", func1.nome);
    println!("Salario: {}", func1.salario);
}
Como no exemplo anterior, o tipo NovoTipo é definido como sendo equivalente ao tipo Funcionario. Isso permite que você use o tipo NovoTipo da mesma forma que usaria o tipo Funcionario. A vantagem de usar um novo tipo é que ele pode ter um nome mais descritivo e fácil de entender no contexto do seu programa. Além disso, ao usar um novo tipo, você pode mudar a implementação do tipo original sem afetar o resto do seu código, pois todas as referências ao tipo serão feitas através do novo nome.



Aqui está como reescrever este código em Rust:


struct Funcionario {
    cod: i32,
    nome: String,
    salario: f32,
    depto: i32,
    cargo: i32,
}

type NovoTipo = Funcionario;

fn main() {
    let mut func1 = NovoTipo {
        cod: 1,
        nome: "Joao".to_string(),
        salario: 1200.0,
        depto: 0,
        cargo: 0,
    };

    println!("Codigo: {}", func1.cod);
    println!("Nome: {}", func1.nome);
    println!("Salario: {}", func1.salario);

    println!("Informe o codigo:");
    let mut cod = String::new();
    std::io::stdin().read_line(&mut cod).unwrap();
    func1.cod = cod.trim().parse().unwrap();

    println!("Informe o nome:");
    let mut nome = String::new();
    std::io::stdin().read_line(&mut nome).unwrap();
    func1.nome = nome.trim().to_string();

    println!("Informe o salario:");
    let mut salario = String::new();
    std::io::stdin().read_line(&mut salario).unwrap();
    func1.salario = salario.trim().parse().unwrap();

    println!("Codigo: {}", func1.cod);
    println!("Nome: {}", func1.nome);
    println!("Salario: {}", func1.salario);
}
O código acima é semelhante ao código C original, com algumas diferenças menores na sintaxe. O tipo NovoTipo é definido como sendo equivalente ao tipo Funcionario, e depois é usado para criar as variáveis func1 e func2. Depois disso, os campos das variáveis são atribuídos e impressos da mesma forma que no código C.



Vetores de estruturas e tipos de dados


Quando precisamos armazenar mais de um elemento do mesmo tipo de estrutura, podemos utilizar vetores de estruturas. Os vetores combinados com estruturas de dados heterogêneas trazem muitos benefícios, pois ao definir um vetor de uma estrutura ou um tipo de dado, a limitação de ser uma estrutura homogênea é removida e o vetor assume as características de uma matriz heterogênea.

struct funcionario {
    char nome[50];
    int idade;
    float salario;
}

fn main() {
    let funcionarios: [funcionario; 3];

    funcionarios[0].nome = "João";
    funcionarios[0].idade = 30;
    funcionarios[0].salario = 1500.50;

    funcionarios[1].nome = "Maria";
    funcionarios[1].idade = 25;
    funcionarios[1].salario = 2000.00;

    funcionarios[2].nome = "Carlos";
    funcionarios[2].idade = 35;
    funcionarios[2].salario = 2500.00;
}

No exemplo apresentado, primeiro é definida a estrutura funcionario e depois é definido o vetor vetFunc do tipo funcionario. O resultado do vetor é apresentado na parte inferior da figura, com cada célula do vetor possuindo uma estrutura do tipo funcionario, que por sua vez comporta áreas distintas de armazenamento com tipos distintos, tornando o vetor uma matriz heterogênea.

Para declarar um vetor do tipo de uma estrutura, basta seguir a mesma regra de declaração de vetores, considerando que, ao invés de indicar um tipo nativo do Rust, deve-se indicar o tipo definido pelo programador ou a estrutura.


struct funcionario {
    char nome[50];
    int idade;
    float salario;
}

fn main() {
    let vetFunc: [funcionario; 3];
}

Em Rust, a estrutura de funcionário e o vetor de funcionários poderiam ser reescritos da seguinte forma:


struct Funcionario {
    cod: i32,
    nome: String,
    salario: f32,
    depto: i32,
    cargo: i32,
}

fn main() {
    let func1: Vec<Funcionario> = Vec::new();
    let func2: Vec<Funcionario> = Vec::new();
}
Aqui, criamos a estrutura Funcionario com os mesmos campos que a estrutura original em C. Em seguida, criamos dois vetores de Funcionario, func1 e func2, usando o método Vec::new() para criar um vetor vazio.

Note que, ao contrário do C, não precisamos usar o typedef para criar um alias para o tipo struct funcionario. Em Rust, podemos usar o nome da estrutura diretamente como um tipo.

Além disso, em Rust, a função main precisa ser marcada com a palavra-chave fn, e as chaves de abertura e fechamento da função precisam estar na mesma linha. Também é necessário incluir um ponto e vírgula após cada declaração de variável e cada instrução na função, exceto quando elas estiverem em uma bloco (que é indicado pelas chaves).

struct funcionario {
    int cod;
    char nome[30];
    float salario;
    int depto;
    int cargo;
}

fn main() {
    let func: [funcionario; 10];

    for i in 0..10 {
        println!("Informe o código:");
        stdin().read_line(&mut func[i].cod).expect("Falha ao ler código");
        println!("Informe o nome:");
        stdin().read_line(&mut func[i].nome).expect("Falha ao ler nome");
    }

    for i in 0..10 {
        println!("Código: {}", func[i].cod);
        println!("Nome: {}", func[i].nome);
    }
}

Estruturas aninhadas

Estruturas aninhadas são estruturas que possuem campos que são tipos de outras estruturas. Isso permite que a estrutura armazene informações mais complexas e hierárquicas. Por exemplo, podemos ter uma estrutura chamada "Pessoa" que possui campos como "nome", "idade" e "endereço". O campo "endereço" pode ser uma estrutura "Endereço" que possui campos como "rua", "cidade" e "estado". Dessa forma, podemos armazenar informações detalhadas sobre o endereço de uma pessoa usando uma estrutura aninhada.



struct Departamento {
    cod: i32,
    descricao: String,
}

struct Cargo {
    cod: i32,
    descricao: String,
}

struct Funcionario {
    cod: i32,
    nome: String,
    salario: f32,
    depto: Departamento,
    cargo: Cargo,
}

fn main() {
    // código aqui
}




. Pode-se utilizar
também o tipo (type) ao invés de struct. A seguir o mesmo exemplo adaptado para
typedef.





struct Departamento {
    cod: i32,
    descricao: String,
}

struct Cargo {
    cod: i32,
    descricao: String,
}

struct Funcionario {
    cod: i32,
    nome: String,
    salario: f32,
    depto: Departamento,
    cargo: Cargo,
}

type Funcionario = Funcionario;

fn main() {
    // código aqui
}

Neste exemplo, é apresentada uma estrutura de funcionário que possui dois campos do tipo definido por outras estruturas: departamento e cargo. O uso do type para definir os tipos Departamento e Cargo, junto com a declaração das estruturas, é uma forma de simplificar a codificação, mas não afeta o desempenho da aplicação. Além disso, é possível aninhar vários níveis de declarações de estruturas e tipos definidos, mas é importante lembrar que isso pode tornar o código mais difícil de entender e manter.


Parte dos exercícios desta lista foram Adaptados de Backes (2013, p. 161-162).

Exercícios

1. Implemente um programa em Rust que leia o nome, a idade e o endereço de uma
pessoa e armazene esses dados em uma estrutura. Em seguida, imprima na tela
os dados da estrutura lida.

#[derive(Debug)]
struct Pessoa {
    nome: String,
    idade: u8,
    endereco: String,
}

fn main() {
    let mut nome = String::new();
    let mut idade = String::new();
    let mut endereco = String::new();

    println!("Insira o nome da pessoa:");
    std::io::stdin().read_line(&mut nome).expect("Falha ao ler o nome");

    println!("Insira a idade da pessoa:");
    std::io::stdin().read_line(&mut idade).expect("Falha ao ler a idade");

    println!("Insira o endereco da pessoa:");
    std::io::stdin().read_line(&mut endereco).expect("Falha ao ler o endereco");

    let pessoa = Pessoa {
        nome: nome.trim().to_string(),
        idade: idade.trim().parse().expect("Falha ao converter a idade para um número"),
        endereco: endereco.trim().to_string(),
    };

    println!("Dados da pessoa: {:?}", pessoa);
}


=============================================================================
2.Crie uma estrutura para representar as coordenadas de um ponto no plano (posi-
    ções X e Y). Em seguida, declare e leia do teclado um ponto e exiba a distância
    dele até a origem das coordenadas, isto é, posição (0, 0). Para realizar o cálculo,
    utilize a fórmula a seguir 1 :
    d=
    p
    (X B − X A )2 + (YB − Y A )2
    (6.1)
    Em que:
    • d = distância entre os pontos A e B
    • X = coordenada X em um ponto
    • Y = coordenada Y em um ponto

fn main() {
    // Declara as variáveis x e y como inteiros
    let mut x: i32 = 0;
    let mut y: i32 = 0;

    // Lê as coordenadas x e y do teclado
    println!("Insira a coordenada x: ");
    std::io::stdin().read_line(&mut x).expect("Falha ao ler a entrada");
    println!("Insira a coordenada y: ");
    std::io::stdin().read_line(&mut y).expect("Falha ao ler a entrada");

    // Calcula a distância usando a fórmula dada
    let distancia = ((x * x) + (y * y)).sqrt();

    // Exibe a distância
    println!("A distância do ponto à origem é {}", distancia);
}


=============================================================================

3. Crie uma estrutura para representar as coordenadas de um ponto no plano (posi-
ções X e Y). Em seguida, declare e leia do teclado dois pontos e exiba a distância
entre eles, considere a mesma fórmula do exercício anterior.


struct Coordenadas {
    x: f64,
    y: f64,
}

fn main() {
    println!("Digite as coordenadas do primeiro ponto (x y):");
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();
    let mut coordenadas = input
        .split_whitespace()
        .map(|s| s.parse().unwrap());
    let ponto1 = Coordenadas {
        x: coordenadas.next().unwrap(),
        y: coordenadas.next().unwrap(),
    };

    println!("Digite as coordenadas do segundo ponto (x y):");
    input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();
    coordenadas = input
        .split_whitespace()
        .map(|s| s.parse().unwrap());
    let ponto2 = Coordenadas {
        x: coordenadas.next().unwrap(),
        y: coordenadas.next().unwrap(),
    };

    let distancia = ((ponto2.x - ponto1.x).powi(2) + (ponto2.y - ponto1.y).powi(2)).sqrt();
    println!("A distância entre os pontos é: {}", distancia);
}


=============================================================================
4. Crie uma estrutura chamada retângulo. Essa estrutura deverá conter o ponto
superior esquerdo e o ponto inferior direito do retângulo. Cada ponto é definido
por uma estrutura Ponto, a qual contém as posições X e Y. Faça um programa
que declare e leia uma estrutura retângulo e exiba a área e o comprimento da
diagonal e o perímetro desse retângulo.

struct Ponto {
    x: i32,
    y: i32,
}

struct Retangulo {
    superior_esquerdo: Ponto,
    inferior_direito: Ponto,
}

fn main() {
    let mut retangulo = Retangulo {
        superior_esquerdo: Ponto { x: 0, y: 0 },
        inferior_direito: Ponto { x: 0, y: 0 },
    };

    println!("Insira as coordenadas do ponto superior esquerdo (x y): ");
    scan!("{} {}", &mut retangulo.superior_esquerdo.x, &mut retangulo.superior_esquerdo.y);

    println!("Insira as coordenadas do ponto inferior direito (x y): ");
    scan!("{} {}", &mut retangulo.inferior_direito.x, &mut retangulo.inferior_direito.y);

    let largura = (retangulo.inferior_direito.x - retangulo.superior_esquerdo.x).abs();
    let altura = (retangulo.inferior_direito.y - retangulo.superior_esquerdo.y).abs();

    let area = largura * altura;
    let diagonal = ((largura.pow(2) + altura.pow(2)) as f64).sqrt();
    let perimetro = 2 * (largura + altura);

    println!("Área do retângulo: {}", area);
    println!("Comprimento da diagonal: {}", diagonal);
    println!("Perímetro do retângulo: {}", perimetro);
}

=============================================================================
5. Usando a estrutura retângulo do exercício anterior, faça um programa que declare
e leia uma estrutura retângulo e um ponto, e informe se esse ponto está ou não
dentro do retângulo.

fn main() {
    let mut retangulo = Retangulo {
        superior_esquerdo: Ponto { x: 0, y: 0 },
        inferior_direito: Ponto { x: 0, y: 0 },
    };

    println!("Insira as coordenadas do ponto superior esquerdo (x y): ");
    scan!("{} {}", &mut retangulo.superior_esquerdo.x, &mut retangulo.superior_esquerdo.y);

    println!("Insira as coordenadas do ponto inferior direito (x y): ");
    scan!("{} {}", &mut retangulo.inferior_direito.x, &mut retangulo.inferior_direito.y);

    let mut ponto = Ponto { x: 0, y: 0 };
    println!("Insira as coordenadas do ponto (x y): ");
    scan!("{} {}", &mut ponto.x, &mut ponto.y);

    if ponto.x >= retangulo.superior_esquerdo.x && ponto.x <= retangulo.inferior_direito.x &&
       ponto.y >= retangulo.superior_esquerdo.y && ponto.y <= retangulo.inferior_direito.y {
        println!("O ponto está dentro do retângulo");
    } else {
        println!("O ponto não está dentro do retângulo");
    }
}


=============================================================================

6. Crie uma estrutura representando um aluno de uma disciplina. Essa estrutura
deve conter o número de matrícula do aluno, seu nome e as notas de três provas.
Defina também um tipo para esta estrutura. Agora, escreva um programa que
leia os dados de cinco alunos e os armazena nessa estrutura. Em seguida, exiba o
nome e as notas do aluno que possui a maior média geral dentre os cinco.

struct Aluno {
    matricula: i32,
    nome: String,
    notas: [i32; 3],
    }
    
    fn main() {
    let mut alunos = Vec::new();
    
    
    for _ in 0..5 {
        let mut aluno = Aluno {
            matricula: 0,
            nome: String::new(),
            notas: [0; 3],
        };
    
        println!("Informe os dados do aluno:");
        println!("Matrícula: ");
        std::io::stdin().read_line(&mut aluno.matricula).expect("Falha ao ler a matrícula");
        println!("Nome: ");
        std::io::stdin().read_line(&mut aluno.nome).expect("Falha ao ler o nome");
        println!("Notas das provas (separadas por espaço): ");
        std::io::stdin().read_line(&mut aluno.notas).expect("Falha ao ler as notas");
    
        alunos.push(aluno);
    }
    
    let mut aluno_maior_media = &alunos[0];
    let mut maior_media = (aluno_maior_media.notas[0] + aluno_maior_media.notas[1] + aluno_maior_media.notas[2]) / 3;
    for aluno in &alunos {
        let media = (aluno.notas[0] + aluno.notas[1] + aluno.notas[2]) / 3;
        if media > maior_media {
            aluno_maior_media = aluno;
            maior_media = media;
        }
    }
    
    println!("O aluno com a maior média é {} com as notas {:?}", aluno_maior_media.nome, aluno_maior_media.notas);
    }


=============================================================================
7. Crie uma estrutura representando uma hora. Essa estrutura deve conter os cam-
pos hora, minuto e segundo. Agora, escreva um programa que leia um vetor de
cinco posições dessa estrutura e imprima a maior hora.


struct Hora {
    hora: i32,
    minuto: i32,
    segundo: i32,
}

fn main() {
    let mut horas = Vec::new();

    for _ in 0..5 {
        println!("Insira a hora (formato HH:MM:SS):");

        let mut input = String::new();
        std::io::stdin().read_line(&mut input).unwrap();

        let hora = input.trim().split(':').map(|s| s.parse().unwrap()).collect::<Vec<i32>>();
        horas.push(Hora { hora: hora[0], minuto: hora[1], segundo: hora[2] });
    }

    let mut maior_hora = horas[0];
    for hora in horas {
        if hora.hora > maior_hora.hora || (hora.hora == maior_hora.hora && hora.minuto > maior_hora.minuto) || (hora.hora == maior_hora.hora && hora.minuto == maior_hora.minuto && hora.segundo > maior_hora.segundo) {
            maior_hora = hora;
        }
    }

    println!("A maior hora é: {:02}:{:02}:{:02}", maior_hora.hora, maior_hora.minuto, maior_hora.segundo);
}








=============================================================================
8. Crie uma estrutura capaz de armazenar o nome e a data de nascimento de uma
pessoa. Faça uso de estruturas aninhadas e definição de novo tipo de dado. Agora,
escreva um programa que leia os dados de seis pessoas. Calcule e exiba os nomes
da pessoa mais nova e da mais velha.


2 / 2

#[derive(Debug)]
struct Pessoa {
nome: String,
data_nascimento: Data,
}

#[derive(Debug)]
struct Data {
dia: u8,
mes: u8,
ano: u16,
}

fn main() {
let mut pessoas = Vec::new();


for i in 0..6 {
    println!("Insira os dados da {}ª pessoa:", i + 1);
    let nome = read_line("Nome: ");
    let data_nascimento = read_data("Data de nascimento: ");

    pessoas.push(Pessoa {
        nome,
        data_nascimento,
    });
}

let mut pessoa_mais_nova = &pessoas[0];
let mut pessoa_mais_velha = &pessoas[0];

for pessoa in &pessoas {
    if pessoa.data_nascimento < pessoa_mais_nova.data_nascimento {
        pessoa_mais_nova = pessoa;
    }
    if pessoa.data_nascimento > pessoa_mais_velha.data_nascimento {
        pessoa_mais_velha = pessoa;
    }
}

println!("A pessoa mais nova é {}.", pessoa_mais_nova.nome);
println!("A pessoa mais velha é {}.", pessoa_mais_velha.nome);
}

fn read_line(prompt: &str) -> String {
print!("{}", prompt);
let mut input = String::new();
std::io::stdin().read_line(&mut input).expect("Erro ao ler entrada");
input.trim().to_owned()
}

fn read_data(prompt: &str) -> Data {
print!("{}", prompt);
let mut input = String::new();
std::io::stdin().read_line(&mut input).expect("Erro ao ler entrada");


let data: Vec<&str> = input.trim().split("/").collect();
let dia = data[0].parse().expect("Erro ao converter dia para número");
let mes = data[1].parse().expect("Erro ao converter mês para número");
let ano = data[2].parse().expect("Erro ao converter ano para número");

Data { dia, mes, ano }
}


=============================================================================
9. Crie uma estrutura representando um atleta. Essa estrutura deve conter o nome
do atleta, seu esporte, idade e altura. Agora, escreva um programa que leia os
dados de cinco atletas. Calcule e exiba os nomes do atleta mais alto e do mais
velho.



use std::io;

fn main() {
    // Definir as variáveis que armazenarão os dados dos atletas
    let mut atletas = Vec::new();
    let mut maior_altura = 0.0;
    let mut nome_mais_alto = String::new();
    let mut mais_velho = 0;
    let mut nome_mais_velho = String::new();

    // Lê os dados dos atletas
    for i in 0..5 {
        println!("Informações do atleta {}:", i + 1);

        println!("Nome:");
        let mut nome = String::new();
        io::stdin().read_line(&mut nome).expect("Falha ao ler o nome");

        println!("Esporte:");
        let mut esporte = String::new();
        io::stdin().read_line(&mut esporte).expect("Falha ao ler o esporte");

        println!("Idade:");
        let mut idade = String::new();
        io::stdin().read_line(&mut idade).expect("Falha ao ler a idade");
        let idade: u32 = idade.trim().parse().expect("Falha ao converter a idade para um número inteiro");

        println!("Altura:");
        let mut altura = String::new();
        io::stdin().read_line(&mut altura).expect("Falha ao ler a altura");
        let altura: f32 = altura.trim().parse().expect("Falha ao converter a altura para um número decimal");

        // Armazena os dados do atleta em uma estrutura
        let atleta = Atleta {
            nome: nome.trim().to_string(),
            esporte: esporte.trim().to_string(),
            idade,
            altura,
        };
        atletas.push(atleta);
    }

    // Percorre os atletas e encontra o mais alto e o mais velho
    for atleta in atletas {
        if atleta.altura > maior_altura {
            maior_altura = atleta.altura;
            nome_mais_alto = atleta.nome;
        }
        if atleta.idade > mais_velho {
            mais_velho = atleta.idade;
            nome_mais_velho = atleta.nome;
        }
    }

    // Exibe os resultados
    println!("O atleta mais alto é {} com {} de altura.", nome_mais_alto, maior_altura);
    println!("O atleta mais velho é {} com {} anos.", nome_mais_velho, mais_velho);
}

// Define a estrutura

struct Atleta {
nome: String,
esporte: String,
idade: u32,
altura: f32,
}



=============================================================================
10. Usando a estrutura "atleta"do exercício anterior, escreva um programa que leia
os dados de cinco atletas e os exiba por ordem de idade, do mais velho para o
mais novo.

fn main() {
    // Declara a estrutura "atleta" com os campos "nome" e "idade"
    struct Atleta {
        nome: String,
        idade: u32,
    }

    // Cria uma lista vazia de atletas
    let mut atletas: Vec<Atleta> = Vec::new();

    // Lê os dados de cinco atletas e os adiciona à lista
    for _ in 0..5 {
        println!("Insira o nome do atleta:");
        let nome = String::new();
        std::io::stdin().read_line(&mut nome).expect("Falha ao ler o nome do atleta");

        println!("Insira a idade do atleta:");
        let mut idade = String::new();
        std::io::stdin().read_line(&mut idade).expect("Falha ao ler a idade do atleta");
        let idade: u32 = idade.trim().parse().expect("Por favor, insira um número válido para a idade");

        // Adiciona um novo atleta à lista com os dados lidos
        atletas.push(Atleta { nome, idade });
    }

    // Ordena a lista de atletas por idade, do mais velho para o mais novo
    atletas.sort_by(|a, b| b.idade.cmp(&a.idade));

    // Exibe os atletas ordenados por idade
    for atleta in atletas {
        println!("{} ({})", atleta.nome, atleta.idade);
    }
}


=============================================================================
11. Escreva um programa que contenha uma estrutura representando uma data
válida. Essa estrutura deve conter os campos dia, mês e ano. Em seguida, leia
duas datas e armazene nessa estrutura. Calcule e exiba o número de dias que
decorrem entre as duas datas.

use std::io;

fn main() {
    // Declarar a estrutura Data
    struct Data {
        dia: u8,
        mes: u8,
        ano: u16,
    }

    // Lê a primeira data
    println!("Insira a primeira data (dd mm yyyy):");
    let mut data_string = String::new();
    io::stdin().read_line(&mut data_string).unwrap();
    let mut data_iter = data_string.split_whitespace();

    let mut data1 = Data {
        dia: data_iter.next().unwrap().parse().unwrap(),
        mes: data_iter.next().unwrap().parse().unwrap(),
        ano: data_iter.next().unwrap().parse().unwrap(),
    };

    // Lê a segunda data
    println!("Insira a segunda data (dd mm yyyy):");
    let mut data_string = String::new();
    io::stdin().read_line(&mut data_string).unwrap();
    let mut data_iter = data_string.split_whitespace();

    let mut data2 = Data {
        dia: data_iter.next().unwrap().parse().unwrap(),
        mes: data_iter.next().unwrap().parse().unwrap(),
        ano: data_iter.next().unwrap().parse().unwrap(),
    };

    // Verifica qual das duas datas é a mais antiga
    if data1.ano > data2.ano || (data1.ano == data2.ano && data1.mes > data2.mes) || (data1.ano == data2.ano && data1.mes == data2.mes && data1.dia > data2.dia) {
        std::mem::swap(&mut data1, &mut data2);
    }

    // Calcula o número de dias entre as duas datas
    let mut dias = 0;
    while data1.ano < data2.ano || (data1.ano == data2.ano && (data1.mes < data2.mes || (data1.mes == data2.mes && data1.dia < data2.dia))) {
        data1.dia += 1;
        dias += 1;

        if data1.dia > 31 {
            data1.dia = 1;
            data1.mes += 1;
        }

        if data1.mes > 12 {
            data1.mes = 1;
            data1.ano += 1;
        }
    }

    println!("O número de dias entre as duas datas é: {}", dias);
}




=============================================================================
12. Astolfolov Oliveirescu é técnico de um time da série C do poderoso campeonato
de futebol profissional da Albânia. Ele deseja manter os dados dos seus jogadores
guardados de forma minuciosa. Ajude-o fazendo um programa para armazenar
os seguintes dados de cada jogador: nº da camisa, peso (kg), altura (m) e a posição
em que joga (atacante, defensor ou meio campista). Lembre-se que o time tem 22
jogadores, entre reservas e titulares. Leia os dados e depois gere um relatório no
vídeo, devidamente tabulado/formatado.

fn main() {
    let mut jogadores = Vec::new();

    for i in 1..23 {
        println!("Digite os dados do jogador {}:", i);
        println!("Número da camisa:");

        let mut numero_camisa = String::new();
        io::stdin().read_line(&mut numero_camisa).expect("Falha ao ler a entrada");
        let numero_camisa: u32 = numero_camisa.trim().parse().expect("Por favor, digite um número válido");

        println!("Peso (kg):");
        let mut peso = String::new();
        io::stdin().read_line(&mut peso).expect("Falha ao ler a entrada");
        let peso: f32 = peso.trim().parse().expect("Por favor, digite um número válido");

        println!("Altura (m):");
        let mut altura = String::new();
        io::stdin().read_line(&mut altura).expect("Falha ao ler a entrada");
        let altura: f32 = altura.trim().parse().expect("Por favor, digite um número válido");

        println!("Posição (atacante, defensor ou meio campista):");
        let mut posicao = String::new();
        io::stdin().read_line(&mut posicao).expect("Falha ao ler a entrada");
        let posicao = posicao.trim();

        let jogador = Jogador {
            numero_camisa,
            peso,
            altura,
            posicao,
        };
        jogadores.push(jogador);
    }

    println!("\nRelatório dos jogadores:");
    println!("| Número da camisa | Peso (kg) | Altura (m) | Posição |");
    println!("|-------------------|------------|-------------|----------|");
    for jogador in &jogadores {
        println!("| {:19} | {:11.1} | {:11.2} | {:9} |", jogador.numero_camisa, jogador.peso, jogador.altura, jogador.posicao);
    }
}

struct Jogador {
    numero_camisa: u32,
    peso: f32,
    altura: f32,
    posicao: String,
}


================================================================================
13. Um clube social com 37 associados deseja que você faça um programa para
armazenar os dados cadastrais desses associados. Os dados são: nome, dia, mês
e ano de nascimento, valor da mensalidade e quantidade de dependentes. O
programa deverá ler os dados e imprimir depois na tela. Deverá também informar
o associado (ou os associados) com o maior número de dependentes.


fn main() {
    // Armazena os dados dos associados em um vetor de tuplas
    let mut associados = vec![
        ("João", 15, 7, 2000, 100.0, 2),
        ("Maria", 25, 3, 1998, 120.0, 1),
        ("José", 3, 12, 2003, 110.0, 3),
        ("Ana", 5, 5, 1999, 130.0, 0),
        ("Carlos", 28, 2, 2001, 90.0, 4),
    ];

    // Encontra o associado com o maior número de dependentes
    let mut associado_mais_dependentes = ("", 0, 0, 0, 0.0, 0);
    for associado in &associados {
        if associado.5 > associado_mais_dependentes.5 {
            associado_mais_dependentes = *associado;
        }
    }

    // Imprime os dados de todos os associados
    for associado in &associados {
        println!(
            "Nome: {}\nData de nascimento: {}/{}/{}\nValor da mensalidade: {}\nQuantidade de dependentes: {}",
            associado.0, associado.1, associado.2, associado.3, associado.4, associado.5
        );
        println!();
    }

    // Imprime o nome do associado com o maior número de dependentes
    println!(
        "O associado com o maior número de dependentes é: {}",
        associado_mais_dependentes.0
    );
}

Examinemos cada linha deste código:

fn main(): esta é a função principal do programa, onde o código será executado.
let mut associados = vec![...]: cria um vetor mutável (que pode ser modificado) de tuplas, onde cada tupla armazena os dados de um associado: nome, dia, mês e ano de nascimento, valor da mensalidade e quantidade de dependentes.
let mut associado_mais_dependentes = ("", 0, 0, 0, 0.0, 0): cria uma tupla mutável para armazenar os dados do associado com o maior número de dependentes. Inicialmente, esta tupla é preenchida com valores padrão.
for associado in &associados: itera sobre cada elemento do vetor de associados. O símbolo & indica que estamos iterando sobre uma referência (um ponteiro) para cada elemento, em vez de uma cópia do elemento.
`if associado.5 > associado_mais_dependentes.






================================================================================
14. Crie um programa que tenha uma estrutura para armazenar o nome, a idade e
número da carteira de sócio de 50 associados de um clube. Crie também uma es-
trutura, dentro desta anterior, chamada dados que contenha o endereço, telefone
e data de nascimento.



struct Dados {
    endereco: String,
    telefone: String,
    data_nascimento: String,
}

struct Associado {
    nome: String,
    idade: u8,
    numero_carteira: u32,
    dados: Dados,
}

fn main() {
    let mut associados: Vec<Associado> = Vec::new();

    // Adicionar associados à lista
    for i in 0..50 {
        let novo_associado = Associado {
            nome: String::from("Associado"),
            idade: 30,
            numero_carteira: i as u32,
            dados: Dados {
                endereco: String::from("Endereço"),
                telefone: String::from("Telefone"),
                data_nascimento: String::from("Data de Nascimento"),
            },
        };
        associados.push(novo_associado);
    }

    // Imprimir informações de cada associado
    for associado in associados {
        println!("Nome: {}", associado.nome);
        println!("Idade: {}", associado.idade);
        println!("Número da carteira: {}", associado.numero_carteira);
        println!("Endereço: {}", associado.dados.endereco);
        println!("Telefone: {}", associado.dados.telefone);
        println!("Data de nascimento: {}", associado.dados.data_nascimento);
        println!("\n");
    }
}

Explicação da solução:

Primeiramente, criamos duas estruturas: Dados e Associado. A estrutura Dados armazena informações adicionais sobre cada associado, como endereço, telefone e data de nascimento. A estrutura Associado armazena o nome, idade e número da carteira de sócio de cada associado, bem como uma instância da estrutura Dados.

Na função main, criamos um vetor dinâmico de Associados chamado associados.

Em seguida, usamos um loop for para adicionar 50 associados à lista. Para cada iteração, criamos uma nova instância da estrutura Associado com os valores padrão e adicionamos ao vetor associados.

Finalmente, usamos outro loop for para iterar sobre cada associado na lista e imprimir suas informações. Cada iteração do loop imprime o nome, idade


================================================================================
15. Crie um programa com uma estrutura para simular uma agenda de telefone
celular, com até 100 registros. Nessa agenda deve constar o nome, sobrenome,
número de telefone móvel, número de telefone fixo e e-mail. O programa deverá
fazer a leitura e, após isso, mostrar os dados na tela.

fn main() {
    // Cria uma lista vazia de entradas de agenda
    let mut agenda: Vec<Agenda> = Vec::new();

    // Lê os dados de entrada até o usuário digitar "sair"
    loop {
        println!("Digite o nome (ou 'sair' para sair):");
        let mut nome = String::new();
        std::io::stdin().read_line(&mut nome).expect("Falha ao ler a entrada");
        nome = nome.trim().to_string();

        if nome == "sair" {
            break;
        }

        println!("Digite o sobrenome:");
        let mut sobrenome = String::new();
        std::io::stdin().read_line(&mut sobrenome).expect("Falha ao ler a entrada");
        sobrenome = sobrenome.trim().to_string();

        println!("Digite o número de telefone móvel:");
        let mut telefone_movel = String::new();
        std::io::stdin().read_line(&mut telefone_movel).expect("Falha ao ler a entrada");
        telefone_movel = telefone_movel.trim().to_string();

        println!("Digite o número de telefone fixo:");
        let mut telefone_fixo = String::new();
        std::io::stdin().read_line(&mut telefone_fixo).expect("Falha ao ler a entrada");
        telefone_fixo = telefone_fixo.trim().to_string();

        println!("Digite o e-mail:");
        let mut email = String::new();
        std::io::stdin().read_line(&mut email).expect("Falha ao ler a entrada");
        email = email.trim().to_string();

        // Adiciona uma nova entrada de agenda com os dados lidos
        agenda.push(Agenda {
            nome,
            sobrenome,
            telefone_movel,
            telefone_fixo,
            email,
        });
    }

    // Exibe os dados da agenda
    for entrada in &agenda {
        println!("Nome: {} {}", entrada.nome, entrada.sobrenome);
        println!("Telefone móvel: {}", entrada.telefone_movel);
        println!("Telefone fixo: {}", entrada.telefone_fixo);
        println!("E-mail: {}", entrada.email);
        println!("---");
    }
}

// Estrutura para armazenar uma entrada de agenda
struct Agenda {
    nome: String,
    sobrenome: String,
    telefone_movel: String,
    telefone_fixo: String,
    email: String,
}


Funões






As funções são uma parte importante de qualquer programa em Rust. Elas nos permitem encapsular blocos de código e reutilizá-los ao longo do programa. Alguns exemplos de funções comuns em Rust são print(), println(), e main(). Por exemplo, a função print() é usada para imprimir uma saída para o usuário do programa. Como é frequentemente necessário apresentar informações ao usuário em diferentes pontos do programa, é conveniente encapsular essas instruções em uma função para que possam ser facilmente invocadas quando necessário.


Funções são úteis em Rust quando identificamos trechos de código que serão frequentemente reutilizados no programa. O programador pode criar suas próprias funções para reutilizar o código-fonte necessário, ou pode utilizar funções prontas fornecidas por bibliotecas externas. Por exemplo, a linguagem Rust não fornece um operador nativo para calcular raízes quadradas ou potências, então o programador pode utilizar uma função pronta da biblioteca math para realizar esses cálculos. Além disso, a utilização de funções pode ajudar a organizar e estruturar o código, tornando-o mais fácil de ler e manter.






Em programação, um procedimento é um conjunto de instruções que realiza uma tarefa específica e pode ser chamado pelo nome a qualquer momento durante a execução do programa. Ele não retorna um valor quando é chamado, ou seja, ele é utilizado apenas para realizar uma tarefa e não para produzir um resultado.


Já uma função é um conjunto de instruções que também realiza uma tarefa específica, mas diferentemente de um procedimento, ela retorna um valor quando é chamada. Isso significa que ela pode ser utilizada para produzir um resultado, que pode ser armazenado em uma variável ou utilizado em uma expressão.


Em Rust, procedimentos são chamados de "procedimentos" e funções são chamadas de "funções". Ambos são definidos usando a palavra-chave "fn" seguida pelo nome da função ou procedimento e os parâmetros entre parênteses. 

Além da diferença básica entre procedimentos e funções, que é o fato de um procedimento não retornar um valor e uma função sim, existem algumas outras diferenças e particularidades importantes a serem consideradas ao trabalhar com esses dois tipos de subrotinas em Rust ou em outras linguagens de programação.


Uma diferença importante é que funções podem ser "aninhadas" dentro de outras funções, enquanto procedimentos não podem. Isso significa que você pode definir uma função dentro do corpo de outra função, mas não pode fazer o mesmo com um procedimento.


Outra diferença é que funções podem ser "recursivas", ou seja, elas podem chamar a si mesmas de maneira iterativa para resolver um problema. Isso é útil em muitos casos, como quando você precisa percorrer uma estrutura de dados de forma recursiva ou quando precisa implementar algoritmos que dependem de recursão. Já procedimentos não podem ser recursivos, pois eles não retornam valores.


Além disso, funções podem ser "generic", ou seja, podem ser definidas de maneira genérica e depois instanciadas com tipos específicos. Isso é útil quando você quer criar uma função que pode ser utilizada com vários tipos diferentes de dados, sem precisar escrever uma versão diferente da função para cada tipo. Já procedimentos não podem ser genéricos, pois eles não retornam valores.


Em resumo, procedimentos e funções são duas formas de escrever subrotinas em Rust ou em outras linguagens de programação. Procedimentos são úteis para realizar tarefas específicas, mas não produzem um resultado, enquanto funções são úteis tanto para realizar tarefas quanto para produzir um resultado. Cada um tem suas próprias particularidades e usos específicos, e você deve escolher o tipo mais adequado para cada situação.
Funções presentes na linguagem Rust


Rust é uma linguagem de programação moderna e poderosa, que fornece uma ampla variedade de funções nativas para realizar uma ampla gama de tarefas. Algumas das funções mais importantes presentes na linguagem Rust incluem:


println!: esta função é usada para imprimir mensagens na saída padrão. Ela é útil para exibir informações para o usuário ou depurar o código.


vec!: esta função é usada para criar vetores (arrays) em Rust. Ela é útil para armazenar coleções de dados que precisam ser acessados ​​sequencialmente.


String::new: esta função é usada para criar uma nova string vazia em Rust. Ela é útil para armazenar e manipular cadeias de caracteres.


collect: esta função é usada para coletar os elementos de um iterador em um container, como um vetor ou uma lista ligada. Ela é útil para transformar dados iteráveis ​​em estruturas de dados mais estáticas.


Essas são apenas algumas das muitas funções disponíveis em Rust. Existem muitas outras funções nativas e bibliotecas externas que fornecem ainda mais funcionalidades para os programadores Rust.

Funções matemáticas

Rust possui uma biblioteca chamada std::math, que fornece uma ampla variedade de funções matemáticas para os programadores Rust. Algumas das funções matemáticas mais importantes incluem:

abs: esta função retorna o valor absoluto de um número. Por exemplo, abs(-5) retornaria 5.
ceil: esta função arredonda um número para cima para o inteiro mais próximo. Por exemplo, ceil(4.3) retornaria 5.
cos: esta função retorna o cosseno de um ângulo em radianos.
exp: esta função retorna o expoente de e, onde e é a base dos logaritmos naturais.
floor: esta função arredonda um número para baixo para o inteiro mais próximo. Por exemplo, floor(4.3) retornaria 4.
log: esta função retorna o logaritmo de um número em uma determinada base. Por exemplo, log(8, 2) retornaria 3, pois 2^3 = 8.
pow: esta função retorna o resultado de um número elevado a uma determinada potência. Por exemplo, pow(2, 3) retornaria 8, pois 2^3 = 8.
sin: esta função retorna o seno de um ângulo em radianos.
sqrt: esta função retorna a raiz quadrada de um número. Por exemplo, sqrt(9) retornaria 3, pois 3^2 = 9.
Função para cálculo da raiz quadrada
Em Rust, podemos usar a função sqrt da biblioteca std::math para calcular a raiz quadrada de um número. A sintaxe da função sqrt em Rust é a seguinte:




use std::math;


fn main() {
   let num = 9.0;
   let result = math::sqrt(num);
   println!("A raiz quadrada de {} é {}", num, result);
}
Isso imprimiria "A raiz quadrada de 9.0 é 3.0" na saída padrão.


É importante lembrar que a função sqrt trabalha com números de ponto flutuante, então o argumento deve ser um número de ponto flutuante também. Além disso, é importante tomar cuidado com os casos de erro, como tentar calcular a raiz quadrada de um número negativo.




Exercício de Exemplo
Faça um programa em Rust que leia um número e após a leitura, calcule e imprima a raiz
quadrada deste número.

use std::io;
use std::math;


fn main() {
   println!("Informe um número:");


   let mut numero = String::new();
   io::stdin().read_line(&mut numero).expect("Falha ao ler entrada");


   let numero: f32 = numero.trim().parse().expect("Por favor, digite um número válido");
   let raiz = math::sqrt(numero);


   println!("A raiz quadrada do número é: {}", raiz);
}


Aqui, estamos usando a biblioteca std::io para ler a entrada do usuário e a biblioteca std::math para calcular a raiz quadrada do número. É importante lembrar que, como a função sqrt trabalha com números de ponto flutuante, é necessário converter a entrada do usuário para um número de ponto flutuante também. Além disso, é importante tratar os casos de erro, como quando o usuário digita um valor inválido ou tenta calcular a raiz quadrada de um número negativo.

Função para cálculo da potência

A função para cálculo da potência, pow(), requer dois argumentos conforme pode
ser visto na sintaxe a seguir. O primeiro argumento é a base, ou seja, o número que
deseja-se que seja calculado a sua potência, e o segundo argumento é o expoente, que
é o valor no qual, o número da base será elevado (SCHILDT, 1996). Em Rust, podemos usar a função pow da biblioteca std::math para calcular a potência de um número. A sintaxe da função pow em Rust é a seguinte:




use std::math;


fn main() {
   let base = 2.0;
   let expoente = 3.0;
   let resultado = math::pow(base, expoente);
   println!("O resultado da potência é {}", resultado);
}
Isso imprimiria "O resultado da potência é 8.0" na saída padrão.


Como a função pow trabalha com números de ponto flutuante, é importante que os argumentos sejam números de ponto flutuante também. Além disso, é importante tomar cuidado com os casos de erro, como tentar calcular a potência de uma base inválida ou um expoente inválido.

Exercício de Exemplo

Faça um programa em Rust que leia um número e um expoente, após a leitura, calcule e
imprima a potência do número lido em relação ao expoente também lido.
use std::io;
use std::math;


fn main() {
   println!("Informe a base:");


   let mut base = String::new();
   io::stdin().read_line(&mut base).expect("Falha ao ler entrada");


   let base: f32 = base.trim().parse().expect("Por favor, digite um número válido");


   println!("Informe o expoente:");


   let mut expoente = String::new();
   io::stdin().read_line(&mut expoente).expect("Falha ao ler entrada");


   let expoente: f32 = expoente.trim().parse().expect("Por favor, digite um número válido");


   let potencia = math::pow(base, expoente);


   println!("A potência do número é: {}", potencia);
}


Aqui, estamos usando a biblioteca std::io para ler a entrada do usuário e a biblioteca std::math para calcular a potência do número. É importante lembrar que, como a função pow trabalha com números de ponto flutuante, é necessário converter a entrada do usuário para um número de ponto flutuante também. Além disso, é importante tratar os casos de erro, como quando o usuário digita um valor inválido ou tenta calcular a potência de uma base inválida ou um expoente inválido.

Funções de tratamento de texto

Em Rust, o tipo String é nativo e pode ser usado para armazenar texto de forma mais conveniente do que com o tipo char em C. Algumas operações, como atribuição e comparação, são mais fáceis de realizar com o String do que com o vetor char. Além disso, a biblioteca padrão de Rust fornece métodos e funções úteis para trabalhar com String, como push_str e replace.


fn main() {
   // Atribuição de string
   let s1 = String::from("hello");
   let s2 = s1;


   println!("s1 = {}, s2 = {}", s1, s2);


   // Comparação de strings
   let s3 = String::from("hello");
   let s4 = String::from("world");


   println!("s3 == s4: {}", s3 == s4);
}


O o tipo String é uma estrutura de dados dinâmica que permite armazenar e manipular strings de texto de forma conveniente. A biblioteca padrão de Rust fornece vários métodos e funções úteis para trabalhar com String. Alguns exemplos incluem:
push_str: Adiciona uma string ao final de um String.
replace: Substitui todas as ocorrências de uma string por outra em um String.
trim: Remove os espaços em branco no início e no final de um String.
to_uppercase: Transforma todos os caracteres de um String em letras maiúsculas.
to_lowercase: Transforma todos os caracteres de um String em letras minúsculas.
split: Divide um String em uma sequência de substrings, usando um determinado separador.
concat: Concatena duas strings em uma única string.
Esses são apenas alguns exemplos de métodos e funções úteis para trabalhar com String em Rust. Há muitas outras opções disponíveis na biblioteca padrão, e também é possível criar suas próprias funções personalizadas para manipular String.


Função para comparação de texto

Podemos usar a função == para comparar strings de forma direta. A sintaxe para usar essa função é a seguinte:




fn main() {
   let s1 = String::from("hello");
   let s2 = String::from("world");


   println!("s1 == s2: {}", s1 == s2);
}
Isso imprimiria "s1 == s2: false" na saída padrão.


É importante lembrar que a comparação de strings em Rust é sensível a maiúsculas e minúsculas. Além disso, é possível comparar strings de forma ignorando maiúsculas e minúsculas usando a função eq_ignore_ascii_case da biblioteca std::ascii.




use std::ascii;


fn main() {
   let s1 = String::from("hello");
   let s2 = String::from("HELLO");


   println!("s1 == s2: {}", s1.eq_ignore_ascii_case(&s2));
}
Isso imprimiria "s1 == s2: true" na saída padrão.

Aqui está um exemplo de como o código acima pode ser reescrito em Rust usando strings:




fn main() {
   let nome = "teste".to_string();
   println!("Informe o novo nome: ");
   let mut novo_nome = String::new();
   std::io::stdin().read_line(&mut novo_nome).expect("Falha ao ler a entrada");
   if nome == novo_nome.trim() {
       println!("Os nomes são iguais!");
   } else {
       println!("Os nomes são diferentes!");
   }
}
Observe que, no código acima, usamos to_string() para converter a string literal "teste" em uma String e read_line para ler a entrada do usuário como uma String. Além disso, usamos o método trim para remover qualquer espaço em branco no início ou no final da string de entrada do usuário antes de compará-la com a string nome.

Existem outras formas de comparar texto em Rust. Algumas das principais opções são:


str::eq: Essa função permite comparar dois strings para ver se são iguais. Ela é case-sensitive, ou seja, leva em consideração a capitalização das letras. Por exemplo:


let s1 = "hello";
let s2 = "Hello";
assert!(s1.eq(s2) == false);


str::eq_ignore_ascii_case: Essa função é semelhante à str::eq, mas ignora a capitalização das letras. Por exemplo:


let s1 = "hello";
let s2 = "Hello";
assert!(s1.eq_ignore_ascii_case(s2) == true);


str::starts_with: Essa função verifica se um string começa com uma determinada sequência de caracteres. Por exemplo:


let s1 = "hello world";
assert!(s1.starts_with("hello") == true);
assert!(s1.starts_with("world") == false);


str::ends_with: Essa função verifica se um string termina com uma determinada sequência de caracteres. Por exemplo:


let s1 = "hello world";
assert!(s1.ends_with("world") == true);
assert!(s1.ends_with("hello") == false);


str::contains: Essa função verifica se um string contém uma determinada sequência de caracteres. Por exemplo:


let s1 = "hello world";
assert!(s1.contains("world") == true);
assert!(s1.contains("foo") == false);


Essas são algumas das principais formas de comparar texto em Rust. Existem muitas outras funções e métodos disponíveis na biblioteca padrão do Rust que permitem realizar outros tipos de comparações, como verificar se dois strings são anagramas um do outro, comparar strings de forma ordenada, entre outros. Existem outras:


str::is_empty: Essa função verifica se um string é vazio, ou seja, se ele não contém nenhum caractere. Por exemplo:


let s1 = "";
let s2 = "hello";
assert!(s1.is_empty() == true);
assert!(s2.is_empty() == false);
str::len: Essa função retorna o número de caracteres de um string. Por exemplo:


let s1 = "hello";
let s2 = "world";
assert!(s1.len() == 5);
assert!(s2.len() == 5);
str::chars: Essa função retorna um iterador sobre os caracteres de um string. Isso pode ser útil para comparar dois strings caractere a caractere. Por exemplo:


let s1 = "hello";
let s2 = "world";


for (c1, c2) in s1.chars().zip(s2.chars()) {
   if c1 != c2 {
       println!("Os strings são diferentes");
       break;
   }
}
str::to_lowercase e str::to_uppercase: Essas funções convertem um string para minúsculas ou maiúsculas, respectivamente. Isso pode ser útil para realizar comparações de texto de forma case-insensitive. Por exemplo:


let s1 = "HeLLo";
let s2 = "hello";
assert!(s1.to_lowercase() == s2);
str::find: Essa função procura uma determinada sequência de caracteres em um string e retorna a posição em que ela ocorre. Isso pode ser útil para verificar se um string contém uma determinada substring. Por exemplo:


let s1 = "hello world";
if s1.find("world") != None {
   println!("A string s1 contém a substring 'world'");
}
Essas são algumas outras formas de comparar texto em Rust. É importante observar que essas funções e métodos só estão disponíveis para strings do tipo str, que são imutáveis. Se você deseja comparar strings mutáveis, o tipo String também oferece muitas funções semelhantes.


str::is_empty: Essa função verifica se um string é vazio, ou seja, se ele não contém nenhum caractere. Por exemplo:


let s1 = "";
let s2 = "hello";
assert!(s1.is_empty() == true);
assert!(s2.is_empty() == false);
str::len: Essa função retorna o número de caracteres de um string. Por exemplo:


let s1 = "hello";
let s2 = "world";
assert!(s1.len() == 5);
assert!(s2.len() == 5);
str::chars: Essa função retorna um iterador sobre os caracteres de um string. Isso pode ser útil para comparar dois strings caractere a caractere. Por exemplo:


let s1 = "hello";
let s2 = "world";


for (c1, c2) in s1.chars().zip(s2.chars()) {
   if c1 != c2 {
       println!("Os strings são diferentes");
       break;
   }
}
str::to_lowercase e str::to_uppercase: Essas funções convertem um string para minúsculas ou maiúsculas, respectivamente. Isso pode ser útil para realizar comparações de texto de forma case-insensitive. Por exemplo:


let s1 = "HeLLo";
let s2 = "hello";
assert!(s1.to_lowercase() == s2);
str::find: Essa função procura uma determinada sequência de caracteres em um string e retorna a posição em que ela ocorre. Isso pode ser útil para verificar se um string contém uma determinada substring. Por exemplo:


let s1 = "hello world";
if s1.find("world") != None {
   println!("A string s1 contém a substring 'world'");
}


str::find_str: Essa função é semelhante à str::find, mas aceita um string em vez de um slice &str como argumento. Ela retorna a posição em que a sequência de caracteres ocorre no string, ou None se a sequência não foi encontrada. Por exemplo:


let s1 = "hello world";
if s1.find_str("world").is_some() {
   println!("A string s1 contém a substring 'world'");
}
str::find_char: Essa função procura um determinado caractere em um string e retorna a posição em que ele ocorre. Ela é útil para procurar caracteres específicos em um string. Por exemplo:


let s1 = "hello world";
if s1.find_char('w').is_some() {
   println!("A string s1 contém o caractere 'w'");
}
str::rfind: Essa função é semelhante à str::find, mas procura a sequência de caracteres a partir do final do string em vez do início. Ela retorna a posição em que a sequência ocorre, ou None se a sequência não foi encontrada. Por exemplo:


let s1 = "hello world";
if s1.rfind("world").is_some() {
   println!("A string s1 contém a substring 'world'");
}
str::rfind_char: Essa função é semelhante à str::find_char, mas procura o caractere a partir do final do string em vez do início. Ela retorna a posição em que o caractere ocorre, ou None se o caractere não foi encontrado. Por exemplo:


let s1 = "hello world";
if s1.rfind_char('w').is_some() {
   println!("A string s1 contém o caractere 'w'");
}
str::matches: Essa função retorna um iterador sobre as substrings de um string que correspondem a um determinado padrão. Ela é útil para encontrar todas as ocorrências de um padrão em um string. Por exemplo:


let s1 = "hello world";
for m in s1.matches("l") {
   println!("Encontrado o padrão 'l' em {}", m);
}





A forma geral de uma função 

Como já mencionado, havendo uma situação em que é necessário reutilizar um código
várias vezes, é conveniente que este código seja uma função. Em boa parte das situações,
não haverá uma função pronta que atenda à necessidade em questão, neste caso,
será necessário escrever a função. 

A sintaxe básica para definir uma função em Rust é a seguinte:




fn nome_da_funcao(parametros) -> tipo_de_retorno {
   // corpo da função
}
Já a sintaxe básica para definir um procedimento em Rust é a seguinte:




fn nome_do_procedimento(parametros) {
   // corpo do procedimento
}
Para chamar uma função ou procedimento em Rust, basta escrever o seu nome seguido dos parâmetros entre parênteses. Se a função retornar um valor, ela pode ser utilizada em uma expressão ou atribuída a uma variável. Se o procedimento não retornar um valor, ele só pode ser chamado como uma instrução independente.


Aqui está um exemplo de como definir e chamar uma função em Rust:




fn soma(x: i32, y: i32) -> i32 {
   x + y
}


fn main() {
   let resultado = soma(10, 20);
   println!("O resultado é {}", resultado);
}
E aqui está um exemplo de como definir e chamar um procedimento em Rust:




fn imprime_mensagem(mensagem: &str) {
   println!("{}", mensagem);
}


fn main() {
   imprime_mensagem("Olá, mundo!");
}




Exercício de Exemplo
Faça um programa em Rust que calcule a área de um retângulo, para isso o programa deve ler a altura e a base. O cálculo deve ser feito em uma função. Após calcular o programa deve imprimir o valor da área do retângulo.




fn area_retangulo(base: f32, altura: f32) -> f32 {
   let area = base * altura;
   return area;
}


fn main() {
   let mut vbase = String::new();
   let mut valtura = String::new();
   let mut varea: f32;


   println!("Informe a base do retângulo:");
   std::io::stdin().read_line(&mut vbase).expect("Falha ao ler a entrada");
   println!("Informe a altura do retângulo:");
   std::io::stdin().read_line(&mut valtura).expect("Falha ao ler a entrada");


   vbase = vbase.trim().parse().expect("Por favor, insira um número válido");
   valtura = valtura.trim().parse().expect("Por favor, insira um número válido");


   varea = area_retangulo(vbase, valtura);
   println!("A área do retângulo é: {}", varea);
}


Algumas coisas a serem observadas:
Em Rust, as funções e variáveis são sempre escritas em snake_case, enquanto em C elas são escritas em camelCase.
Em Rust, precisamos especificar o tipo de retorno da função após o nome da função, usando o "arrow" ->. Em C, o tipo de retorno é especificado antes do nome da função.
Em Rust, para ler dados do usuário, usamos a função std::io::stdin().read_line(), que lê uma linha inteira da entrada padrão. Em C, usamos a função scanf().
Em Rust, para converter uma string em um número, precisamos chamar o método parse() na string. Em C, usamos a função sscanf().
Em Rust, para imprimir uma string, usamos a macro println!(). Em C, usamos a função printf().




A função area_retangulo tem dois parâmetros, base e altura, que são ambos do tipo f32. O tipo f32 é um tipo de ponto flutuante de precisão simples, ou seja, um número real que pode ter uma parte fracionária.




fn area_retangulo(base: f32, altura: f32) -> f32 {
Em seguida, declaramos uma variável local chamada area, que é igual à base multiplicada pela altura.




   let area = base * altura;
Por fim, retornamos o valor da área.




   return area;
}
Ao todo, a função area_retangulo recebe a base e a altura de um retângulo como entrada e retorna a área do retângulo como resultado.


Protótipos de funções


Protótipos de funções são declarações especiais que informam ao compilador sobre o número e o tipo de argumentos de uma função, bem como o tipo de retorno da função. Eles são usados ​​principalmente para garantir que as chamadas de função estejam sintaticamente corretas, fornecendo ao compilador informações sobre a assinatura da função (isto é, o nome da função e a lista de argumentos).


Um protótipo de função é geralmente colocado no início de um programa ou em um arquivo de cabeçalho, e é escrito da seguinte maneira:




tipo_de_retorno nome_da_função(lista_de_argumentos);
Por exemplo, o protótipo de uma função que recebe dois inteiros e retorna um inteiro pode ser escrito da seguinte maneira:




int min(int x, int y);
Isso informa ao compilador que existe uma função chamada "min" que recebe dois argumentos inteiros e retorna um inteiro. A implementação da função deve ser fornecida em algum lugar do código, como no seguinte exemplo:




int min(int x, int y)
{
   if (x < y)
       return x;
   else
       return y;
}
Protótipos de função são importantes porque permitem que o compilador verifique se as chamadas de função estão sintaticamente corretas e fornecem informações sobre a assinatura da função a outros programadores. Eles também permitem que as funções sejam chamadas antes de serem implementadas, o que pode ser útil em programas grandes e complexos.




Veja um exemplo:




fn areaRetangulo(base: f32, altura: f32) -> f32;


fn main() {
   let mut vbase = String::new();
   let mut valtura = String::new();
   let varea: f32;


   println!("Informe a base do retangulo: ");
   std::io::stdin().read_line(&mut vbase).expect("Falha ao ler entrada");
   println!("Informe a altura do retangulo: ");
   std::io::stdin().read_line(&mut valtura).expect("Falha ao ler entrada");


   vbase = vbase.trim().parse().expect("Por favor, insira um numero");
   valtura = valtura.trim().parse().expect("Por favor, insira um numero");


   varea = areaRetangulo(vbase, valtura);
   println!("A area do retangulo e: {}", varea);
}


fn areaRetangulo(base: f32, altura: f32) -> f32 {
   let area = base * altura;
   return area;
}
Aqui, a assinatura da função "areaRetangulo" é declarada na linha 1 e a implementação da função é fornecida na linha 21. O código principal da função "main" começa na linha 7.


Note que, em Rust, não há necessidade de incluir bibliotecas como "stdio.h" ou "stdlib.h", já que as funções e tipos de dados necessários são importados automaticamente pelo pré-processador do Rust. Além disso, a função "main" não é declarada como "void", mas simplesmente como "fn", já que não retorna nenhum valor em Rust (em vez disso, ela usa o "println!" macro para imprimir na tela).


Aqui está como o código acima poderia ser escrito em Rust, com as assinaturas das funções "areaRetangulo" e "areaTriangulo" declaradas no início do código:




fn areaRetangulo(base: f32, altura: f32) -> f32;
fn areaTriangulo(base: f32, altura: f32) -> f32;


fn main() {
   let mut vbase = String::new();
   let mut valtura = String::new();
   let varea_ret: f32;
   let varea_tri: f32;


   println!("Informe a base do retangulo: ");
   std::io::stdin().read_line(&mut vbase).expect("Falha ao ler entrada");
   println!("Informe a altura do retangulo: ");
   std::io::stdin().read_line(&mut valtura).expect("Falha ao ler entrada");


   vbase = vbase.trim().parse().expect("Por favor, insira um numero");
   valtura = valtura.trim().parse().expect("Por favor, insira um numero");


   varea_ret = areaRetangulo(vbase, valtura);
   varea_tri = areaTriangulo(vbase, valtura);
   println!("A area do retangulo e: {}", varea_ret);
   println!("A area do triangulo e: {}", varea_tri);
}


fn areaRetangulo(base: f32, altura: f32) -> f32 {
   let area = base * altura;
   return area;
}


fn areaTriangulo(base: f32, altura: f32) -> f32 {
   let area = (base * altura) / 2.0;
   return area;
}
Aqui, as assinaturas das funções "areaRetangulo" e "areaTriangulo" são declaradas nas linhas 1 e 2, respectivamente, e as implementações das funções são fornecidas nas linhas 11 e 22, respectivamente. O código principal da função "main" começa na linha 7.








fn areaRetangulo(base: f32, altura: f32) -> f32;
fn areaTriangulo(base: f32, altura: f32) -> f32;


fn main() {
   let mut vbase = String::new();
   let mut valtura = String::new();
   let varea_ret: f32;
   let varea_tri: f32;


   println!("Informe a base do retangulo: ");
   std::io::stdin().read_line(&mut vbase).expect("Falha ao ler entrada");
   println!("Informe a altura do retangulo: ");
   std::io::stdin().read_line(&mut valtura).expect("Falha ao ler entrada");


   vbase = vbase.trim().parse().expect("Por favor, insira um numero");
   valtura = valtura.trim().parse().expect("Por favor, insira um numero");


   varea_ret = areaRetangulo(vbase, valtura);
   varea_tri = areaTriangulo(vbase, valtura);
   println!("A area do retangulo e: {}", varea_ret);
   println!("A area do triangulo e: {}", varea_tri);
}


fn areaRetangulo(base: f32, altura: f32) -> f32 {
   let area = base * altura;
   return area;
}


fn areaTriangulo(base: f32, altura: f32) -> f32 {
   let area = areaRetangulo(base, altura) / 2.0;
   return area;
}



Escopo das Variáveis


O escopo de uma variável é o conjunto de contextos no qual a variável é visível e pode ser acessada. Em outras palavras, o escopo de uma variável determina onde ela pode ser usada no código.


Existem dois tipos principais de escopo: escopo global e escopo local.


Em Rust, as variáveis globais são aquelas que são declaradas no nível mais externo de um arquivo de código, fora de qualquer função ou outro bloco de código. Elas são visíveis e acessíveis em todo o código e são criadas no início da execução do programa.


As variáveis locais, por outro lado, são aquelas que são declaradas dentro de um bloco de código, como dentro de uma função ou de um loop. Elas só são visíveis e acessíveis dentro desse bloco e são criadas quando o bloco é iniciado.


É importante entender o escopo das variáveis porque isso pode afetar a forma como o código é escrito e como ele é executado. Por exemplo, se você tentar acessar uma variável com escopo local fora da função onde ela foi definida, isso pode resultar em um erro.




Em Rust, o escopo de uma variável é determinado pelo seu bloco de código. Um bloco de código é qualquer conjunto de instruções envolvidas por chaves {}, como um loop for, uma condicional if ou uma função.


Variáveis declaradas no nível mais externo de um arquivo de código Rust, fora de qualquer função ou outro bloco, têm escopo global e são visíveis em todo o código.


As variáveis globais são declaradas usando a palavra-chave static e podem ser imutáveis ou mutáveis, dependendo da forma como são definidas. Por exemplo:




// variável global imutável com duração de tempo de execução
static PI: f64 = 3.14;


// variável global mutável com duração de tempo de execução
static mut CONTADOR: i32 = 0;
O acesso a variáveis globais em Rust é considerado uma operação unsafe por padrão, o que significa que é preciso usar a palavra-chave unsafe ao acessá-las. Isso é necessário porque o acesso concorrente a variáveis globais pode levar a problemas de sincronização e race conditions.




fn main() {
   let x = 5; // x é uma variável local e só é visível dentro da função main


   {
       let y = 10; // y é uma variável local e só é visível dentro desse bloco
   }


   // y não é mais visível aqui
}
Variáveis locais são úteis porque permitem que você declare e use variáveis de forma mais restrita, o que pode tornar o código mais legível e fácil de depurar. Além disso, elas podem ser usadas para armazenar temporariamente os resultados de cálculos ou outros valores enquanto o código está sendo executado.


Em Rust, as variáveis locais são criadas automaticamente quando o bloco é executado e são destruídas automaticamente quando o bloco é finalizado. Isso é conhecido como "gestão de memória automática" e é uma das características do Rust que o torna um linguagem segura e eficiente.






Variáveis declaradas dentro de um bloco de código têm escopo local e só são visíveis dentro desse bloco. Por exemplo:




fn main() {
   let x = 5; // x tem escopo local e só é visível dentro da função main


   {
       let y = 10; // y tem escopo local e só é visível dentro desse bloco
   }


   // y não é mais visível aqui
}


Veja





No diagrama acima, o momento em que cada variável é criada é destacado usando o texto "cria" e o momento em que ela deixa de existir é destacado usando o texto "finaliza". Assim, podemos ver que a variável global x é criada no início do programa e é finalizada no final, enquanto a variável local y é criada quando a função minha_funcao é executada e deixa de existir ao final.




Em Rust, é possível declarar uma variável com o mesmo nome em diferentes blocos de código. Neste caso, a variável com escopo mais interno tem prioridade e obscurece a variável com escopo mais externo. Por exemplo:




fn main() {
   let x = 5; // x tem escopo local e só é visível dentro da função main


   {
       let x = 10; // x tem escopo local e só é visível dentro desse bloco
       println!("x = {}", x); // imprime 10
   }


   println!("x = {}", x); // imprime 5
}
Em Rust, também é possível usar o operador shadowing para declarar uma nova variável com o mesmo nome em um bloco de código e sobrescrever a variável de escopo mais externo. Por exemplo:




fn main() {
   let x = 5; // x tem escopo local e só é visível dentro da função main


   {
       let x = x; // x tem escopo local e só é visível dentro desse bloco
       println!("x = {}", x); // imprime 5
   }


   println!("x = {}", x); // imprime 5
}


Variáveis declaradas no nível mais externo de um arquivo de código Rust, fora de qualquer função ou outro bloco, têm escopo global e são visíveis em todo o código.


Por exemplo, no código abaixo, a variável x tem escopo global e pode ser acessada em qualquer parte do código:




let x = 5; // x tem escopo global


fn main() {
   println!("x = {}", x); // imprime 5
}
Em Rust, é possível declarar uma variável global usando a palavra-chave static. A diferença entre uma variável global e uma variável static é que as variáveis static são imutáveis e têm duração de tempo de execução (lifetime). Isso significa que elas são criadas no início da execução do programa e mantidas até o final da execução.


Por exemplo:




static PI: f64 = 3.14; // PI é uma variável global imutável com duração de tempo de execução


fn main() {
   println!("PI = {}", PI); // imprime 3.14
}


use std::io;


static mut VBASE: f32 = 0.0;
static mut VALTURA: f32 = 0.0;


fn area_retangulo() -> f32 {
   unsafe {
       VBASE * VALTURA
   }
}


fn area_triangulo() -> f32 {
   area_retangulo() / 2.0
}


fn main() {
   println!("Informe a base do retângulo:");
   let mut base = String::new();
   io::stdin().read_line(&mut base).unwrap();
   unsafe {
       VBASE = base.trim().parse().unwrap();
   }


   println!("Informe a altura do retângulo:");
   let mut altura = String::new();
   io::stdin().read_line(&mut altura).unwrap();
   unsafe {
       VALTURA = altura.trim().parse().unwrap();
   }


   let area_ret = area_retangulo();
   let area_tri = area_triangulo();


   println!("A área do retângulo é: {}", area_ret);
   println!("A área do triângulo é: {}", area_tri);
}
Observe que as variáveis VBASE e VALTURA são declaradas como globais usando a palavra-chave static e são marcadas como unsafe porque são acessadas de forma não segura dentro das funções area_retangulo e area_triangulo. Isso é necessário porque o acesso a variáveis globais em Rust é considerado uma operação unsafe por padrão.



No diagrama acima, as variáveis globais VBASE e VALTURA são mostradas como atributos da função main e são criadas no início da execução do programa. As variáveis locais base e altura são mostradas como atributos da função main e são criadas quando o bloco correspondente é executado. As variáveis area_ret e area_tri são mostradas como atributos da função main e são criadas quando as funções area_retangulo e area_triangulo são chamadas, respectivamente.
Todas essas variáveis são destruídas quando o bloco ou função correspondente é finalizado.









No diagrama acima, as variáveis base e altura são locais e só existem dentro da função main. Já as variáveis globais VBASE e VALTURA são criadas no início da execução do programa e existem até o final da execução.

Exercícios da Aula
Os exercícios desta lista foram Adaptados de Lopes e Garcia (2002, p. 42-61; 400-438).


1. Faça um programa em rust que leia três números e, para cada um, imprimir o dobro. O cálculo deverá ser realizado por uma função e o resultado impresso ao final do programa.


fn main() {
   let mut numero1 = 0;
   let mut numero2 = 0;
   let mut numero3 = 0;
    println!("Insira o primeiro número: ");
   std::io::stdin().read_line(&mut numero1).expect("Falha ao ler o número");
   numero1 = numero1.trim().parse().expect("Falha ao converter o número");
    println!("Insira o segundo número: ");
   std::io::stdin().read_line(&mut numero2).expect("Falha ao ler o número");
   numero2 = numero2.trim().parse().expect("Falha ao converter o número");
    println!("Insira o terceiro número: ");
   std::io::stdin().read_line(&mut numero3).expect("Falha ao ler o número");
   numero3 = numero3.trim().parse().expect("Falha ao converter o número");
    let dobro1 = calcular_dobro(numero1);
   let dobro2 = calcular_dobro(numero2);
   let dobro3 = calcular_dobro(numero3);
    println!("O dobro do primeiro número é: {}", dobro1);
   println!("O dobro do segundo número é: {}", dobro2);
   println!("O dobro do terceiro número é: {}", dobro3);
 }
  fn calcular_dobro(numero: i32) -> i32 {
   return numero * 2;
 }
 
Explicação:
A função main é a função principal do programa, ela é chamada quando o programa é iniciado.
Dentro da função main, declaramos três variáveis mutáveis (mut numero1, mut numero2 e mut numero3) do tipo i32 (inteiro de 32 bits) e inicializamos com o valor 0.
Em seguida, usamos o método println! para imprimir na tela a mensagem "Insira o primeiro número: ". O método println! é usado para imprimir uma mensagem na tela e inclui uma quebra de linha ao final.
Em seguida, usamos o método stdin().read_line da biblioteca std::io para ler uma linha de texto digitada pelo usuário. O método read_line recebe uma variável mutável do tipo String como parâmetro, neste caso, passamos a variável numero1. O método read_line retorna um resultado do tipo `




2. Faça um programa que receba as notas de três provas e calcule a média. Para o cálculo, escreva uma função. O programa deve imprimir a média ao final.


fn main() {
   let mut nota1 = 0.0;
   let mut nota2 = 0.0;
   let mut nota3 = 0.0;
    println!("Insira a primeira nota: ");
   std::io::stdin().read_line(&mut nota1).expect("Falha ao ler a nota");
   nota1 = nota1.trim().parse().expect("Falha ao converter a nota");
    println!("Insira a segunda nota: ");
   std::io::stdin().read_line(&mut nota2).expect("Falha ao ler a nota");
   nota2 = nota2.trim().parse().expect("Falha ao converter a nota");
    println!("Insira a terceira nota: ");
   std::io::stdin().read_line(&mut nota3).expect("Falha ao ler a nota");
   nota3 = nota3.trim().parse().expect("Falha ao converter a nota");
    let media = calcular_media(nota1, nota2, nota3);
    println!("A média é: {}", media);
 }
  fn calcular_media(nota1: f64, nota2: f64, nota3: f64) -> f64 {
   return (nota1 + nota2 + nota3) / 3.0;
 }
 

Explicação:
O ator Usuário representa o usuário do programa.
A participante main(): void representa a função principal do programa.
A participante calcular_media(nota1: f64, nota2: f64, nota3: f64): f64 representa a função que calcula a média das notas.
O usuário inicia o programa.
A função main inicializa as variáveis nota1, nota2 e nota3 com o valor 0.0.
A função main imprime a mensagem "Insira a primeira nota: " na tela.
A função main lê uma linha de texto digitada pelo usuário e armazena o valor em nota1.
A função main converte o valor de nota1 de String para f64.
A função main repete os mesmos passos para as variáveis nota2 e nota3.
A função main chama a função calcular_media passando os valores de nota1, nota2 e nota3 como parâmetros.
A função calcular_media calcula e retorna a média das notas.
A função main imprime a média na tela.
O programa é encerrado.


3. Faça um programa em rust que leia o valor de um ângulo em graus e o converta, utilizando uma função, para radianos e ao final imprima o resultado. Veja a
fórmula de cálculo a seguir.







Em que:
• rad = ângulo em radianos
• ang = ângulo em graus
•  = número do pi


fn main() {
  let mut anguloGraus = 0.0;
  let pi = 3.141592;
 
  println!("Insira o ângulo em graus: ");
  std::io::stdin().read_line(&mut anguloGraus).expect("Falha ao ler o ângulo");
  anguloGraus = anguloGraus.trim().parse().expect("Falha ao converter o ângulo");
 
  let anguloRadianos = converterParaRadianos(anguloGraus, pi);
 
  println!("O ângulo em radianos é: {}", anguloRadianos);
}
 
fn converterParaRadianos(anguloGraus: f64, pi: f64) -> f64 {
  return (anguloGraus * pi) / 180.0;
}







No diagrama de sequência acima, temos os seguintes participantes:
O ator Usuário representa o usuário do programa.
A participante main(): void representa a função principal do programa.
A participante converter_para_radianos(angulo_graus: f64, pi: f64): f64 representa a função que converte o ângulo em graus para radianos.
A seguir, explicamos cada passo do diagrama de sequência:
O usuário inicia o programa.
A função main inicializa as variáveis angulo_graus e pi.
A função main imprime a mensagem "Insira o ângulo em graus: " na tela.
A função main lê uma linha de texto digitada pelo usuário e armazena o valor em angulo_graus.
A função main converte o valor de angulo_graus de String para f64.
A função main chama a função converter_para_radianos passando os valores de angulo_graus e pi como parâmetros.
A função converter_para_radianos calcula e retorna o ângulo em radianos.
A função main imprime o ângulo em radianos na tela.
O programa é encerrado.




4. Faça um programa que calcule e imprima o fatorial de um número, usando uma função que receba um valor e retorne o fatorial desse valor.


fn main() {
   println!("Digite um número para calcular o fatorial:");


   let mut numero = String::new();
   std::io::stdin().read_line(&mut numero).expect("Falha ao ler a entrada");


   let numero: u32 = numero.trim().parse().expect("Por favor, digite um número inteiro válido");


   let fatorial = calcularFatorial(numero);


   println!("O fatorial de {} é {}", numero, fatorial);
}


fn calcularFatorial(numero: u32) -> u32 {
   let mut fatorial = 1;
   for i in 2..=numero {
       fatorial *= i;
   }
   fatorial
}





O diagrama de sequência mostra que a função main chama a função calcularFatorial passando o valor de numero como argumento. A função calcularFatorial então realiza um loop para calcular o fatorial do número e retorna o resultado para a função main. A função main imprime o resultado na tela.


5. Faça um programa que verifique se um número é primo por meio de um função. Ao final imprima o resultado.






fn main() {
   println!("Digite um número para verificar se é primo:");


   let mut numero = String::new();
   std::io::stdin().read_line(&mut numero).expect("Falha ao ler a entrada");


   let numero: u32 = numero.trim().parse().expect("Por favor, digite um número inteiro válido");


   let eh_primo = verificarPrimo(numero);


   if eh_primo {
       println!("O número {} é primo", numero);
   } else {
       println!("O número {} não é primo", numero);
   }
}


fn verificarPrimo(numero: u32) -> bool {
   if numero < 2 {
       return false;
   }


   for i in 2..=(numero / 2) {
       if numero % i == 0 {
           return false;
       }
   }


   true
}







O diagrama de sequência mostra que a função main chama a função verificarPrimo passando o valor de numero como argumento. A função verificarPrimo então realiza um loop para verificar se o número é primo e retorna o resultado para a função main. A função main imprime o resultado na tela.








6. Faça um programa que leia o saldo e o % de reajuste de uma aplicação financeira e imprimir o novo saldo após o reajuste. O cálculo deve ser feito por uma função.




fn main() {
   println!("Digite o saldo da aplicação financeira:");


   let mut saldo = String::new();
   std::io::stdin().read_line(&mut saldo).expect("Falha ao ler a entrada");


   let saldo: f32 = saldo.trim().parse().expect("Por favor, digite um número válido");


   println!("Digite o percentual de reajuste da aplicação financeira:");


   let mut percentual_reajuste = String::new();
   std::io::stdin().read_line(&mut percentual_reajuste).expect("Falha ao ler a entrada");


   let percentual_reajuste: f32 = percentual_reajuste.trim().parse().expect("Por favor, digite um número válido");


   let novo_saldo = calcularNovoSaldo(saldo, percentual_reajuste);


   println!("O novo saldo da aplicação financeira é: {}", novo_saldo);
}


fn calcularNovoSaldo(saldo: f32, percentual_reajuste: f32) -> f32 {
   saldo * (1.0 + percentual_reajuste / 100.0)
}






7. Faça um programa que leia a base e a altura de um retângulo e imprima o perímetro, a área e a diagonal. Para fazer os cálculos, implemente três funções, cada uma deve realizar um cálculo especifico conforme solicitado. Utilize as fórmulas









use std::f32::consts::SQRT_2;


fn main() {
   println!("Digite a base do retângulo:");


   let mut base = String::new();
   std::io::stdin().read_line(&mut base).expect("Falha ao ler a entrada");


   let base: f32 = base.trim().parse().expect("Por favor, digite um número válido");


   println!("Digite a altura do retângulo:");


   let mut altura = String::new();
   std::io::stdin().read_line(&mut altura).expect("Falha ao ler a entrada");


   let altura: f32 = altura.trim().parse().expect("Por favor, digite um número válido");


   let perimetro = calcularPerimetro(base, altura);
   let area = calcularArea(base, altura);
   let diagonal = calcularDiagonal(base, altura);


   println!("O perímetro do retângulo é: {}", perimetro);
   println!("A área do retângulo é: {}", area);
   println!("A diagonal do retângulo é: {}", diagonal);
}


fn calcularPerimetro(base: f32, altura: f32) -> f32 {
   2.0 * (base + altura)
}


fn calcularArea(base: f32, altura: f32) -> f32 {
   base * altura
}


fn calcularDiagonal(base: f32, altura: f32) -> f32 {
   (base * base + altura * altura).sqrt()
}



O diagrama de sequência mostra que a função main chama as funções calcularPerimetro, calcularArea e calcularDiagonal passando os valores de base e altura como argumentos. Cada uma dessas funções realiza o cálculo específico e retorna o resultado para a função main. A função main imprime os resultados na tela.


8. Faça um programa que leia o raio de um circulo e imprima o perímetro e a área.
Para fazer os cálculos, implemente duas funções, cada uma deve realizar um cálculo específico conforme solicitado. Utilize as fórmulas a seguir.






use std::f32::consts::PI;


fn main() {
   println!("Digite o raio do círculo:");


   let mut raio = String::new();
   std::io::stdin().read_line(&mut raio).expect("Falha ao ler a entrada");


   let raio: f32 = raio.trim().parse().expect("Por favor, digite um número válido");


   let perimetro = calcularPerimetro(raio);
   let area = calcularArea(raio);


   println!("O perímetro do círculo é: {}", perimetro);
   println!("A área do círculo é: {}", area);
}


fn calcularPerimetro(raio: f32) -> f32 {
   2.0 * PI * raio
}


fn calcularArea(raio: f32) -> f32 {
   PI * raio * raio
}



O diagrama de sequência mostra que a função main chama as funções calcularPerimetro e calcularArea passando o valor de raio como argumento. Cada uma dessas funções realiza o cálculo específico e retorna o resultado para a função main. A função main imprime os resultados na tela






13. Em épocas de pouco dinheiro, os comerciantes estão procurando aumentar suas vendas oferecendo desconto. Faça um programa que permita entrar com o valor de um produto e o percentual de desconto e imprimir o novo valor com base no percentual informado. Para fazer o cálculo, implemente uma função.




.fn main() {
   println!("Digite o valor do produto:");


   let mut valor = String::new();
   std::io::stdin().read_line(&mut valor).expect("Falha ao ler a entrada");


   let valor: f32 = valor.trim().parse().expect("Por favor, digite um número válido");


   println!("Digite o percentual de desconto:");


   let mut percentual = String::new();
   std::io::stdin().read_line(&mut percentual).expect("Falha ao ler a entrada");


   let percentual: f32 = percentual.trim().parse().expect("Por favor, digite um número válido");


   let novo_valor = aplicarDesconto(valor, percentual);


   println!("O novo valor do produto é: {}", novo_valor);
}


fn aplicarDesconto(valor: f32, percentual: f32) -> f32 {
   valor - (valor * percentual / 100.0)
}



O diagrama de sequência mostra que a função main chama a função aplicarDesconto passando os valores de valor e percentual como argumentos. A função aplicarDesconto realiza o cálculo do novo valor com base nesses argumentos e retorna o resultado para a função main. A função main imprime o resultado na tela.








14. Faça um programa que leia os catetos (dois catetos) de um triângulo retângulo e imprima a hipotenusa. Para fazer o cálculo, implemente uma função. Utilize a fórmula a seguir.





fn main() {
   println!("Digite o valor do primeiro cateto:");


   let mut cateto1 = String::new();
   std::io::stdin().read_line(&mut cateto1).expect("Falha ao ler a entrada");


   let cateto1: f32 = cateto1.trim().parse().expect("Por favor, digite um número válido");


   println!("Digite o valor do segundo cateto:");


   let mut cateto2 = String::new();
   std::io::stdin().read_line(&mut cateto2).expect("Falha ao ler a entrada");


   let cateto2: f32 = cateto2.trim().parse().expect("Por favor, digite um número válido");


   let hipotenusa = calcularHipotenusa(cateto1, cateto2);


   println!("A hipotenusa do triângulo retângulo é: {}", hipotenusa);
}


fn calcularHipotenusa(cateto1: f32, cateto2: f32) -> f32 {
   (cateto1.powf(2.0) + cateto2.powf(2.0)).sqrt()
}













O diagrama de sequência mostra que a função main chama a função calcularHipotenusa passando os valores de cateto1 e cateto2 como argumentos. A função calcularHipotenusa realiza o cálculo da hipotenusa usando a fórmula fornecida e retorna o resultado para a função main. A função main imprime o resultado na tela.






15. Construa um programa em rust que leia um caractere (letra) e, por meio de uma função, retorne se este caractere é uma consoante ou uma vogal. Ao final imprima o resultado.






use std::io;


fn main() {
   println!("Insira um caractere: ");


   let mut caractere = String::new();
   io::stdin().read_line(&mut caractere).expect("Falha ao ler a entrada");


   let caractere = caractere.trim().chars().next().expect("Por favor, digite um caractere válido");


   let tipo = verificar_tipo_caractere(caractere);


   println!("O caractere é {}", tipo);
}


fn verificar_tipo_caractere(caractere: char) -> &'static str {
   if caractere.is_alphabetic() {
       if caractere.is_vowel() {
           return "uma vogal";
       } else {
           return "uma consoante";
       }
   } else {
       return "um caractere inválido";
   }
}





O diagrama de sequência acima representa a interação entre os componentes do código em Rust apresentado. Ele mostra que o usuário inicia a execução do programa ao inserir um caractere. Em seguida, o módulo principal ("main()") chama a função "verificar_tipo_caractere()" passando o caractere inserido pelo usuário como parâmetro. A função "verificar_tipo_caractere()" é responsável por verificar se o caractere é uma vogal, uma consoante ou um caractere inválido, e retorna o resultado para o módulo principal. Por fim, o módulo principal imprime o resultado para o usuário.


17. Implemente um programa que leia uma mensagem e um caractere. Após a leitura, o programa deve, por meio de função, retirar todas as ocorrências do caractere informado na mensagem colocando * em seu lugar. A função deve também retornar o total de caracteres retirados. Ao final, o programa deve imprimir a frase ajustada e a quantidade de caracteres substituídos.






fn main() {
println!("Insira uma mensagem: ");


let mut mensagem = String::new();
io::stdin().read_line(&mut mensagem).expect("Falha ao ler a entrada");


println!("Insira um caractere a ser substituído na mensagem: ");


let mut caractere = String::new();
io::stdin().read_line(&mut caractere).expect("Falha ao ler a entrada");
let caractere = caractere.trim().chars().next().expect("Por favor, digite um caractere válido");


let (novaMensagem, total) = substituir_caractere(&mensagem, caractere);


println!("A mensagem ajustada é: {}", novaMensagem);
println!("Foram substituídos {} caracteres", total);
}


fn substituir_caractere(mensagem: &str, caractere: char) -> (String, i32) {
   let mut novaMensagem = String::new();
   let mut total = 0;


   for c in mensagem.chars() {
       if c == caractere {
           novaMensagem.push('*');
           total += 1;
       } else {
           novaMensagem.push(c);
       }
   }


   (novaMensagem, total)
}





Neste diagrama, temos a seguinte sequência de eventos:
O Programa lê a mensagem e o caractere que devem ser utilizados na substituição.
O Programa chama a Função substituir_caractere, passando a mensagem e o caractere como parâmetros.
A Função substituir_caractere realiza a substituição dos caracteres na mensagem.
A Função substituir_caractere retorna a mensagem ajustada e o total de caracteres substituídos para o Programa.
O Programa imprime a mensagem ajustada e o total de caracteres substituídos.


20. Faça um programa que leia 20 de números inteiros e armazene em um vetor.
Após essa leitura, o programa deve ler um novo número inteiro para ser buscado no vetor. Uma função deve verificar se o número lido por último está no vetor e retornar a posição do número no vetor, caso esteja, ou -1, caso não esteja.


use std::io;


fn main() {
let mut numeros = [0; 20];




println!("Insira 20 números inteiros: ");
for i in 0..20 {
   let mut numero = String::new();
   io::stdin().read_line(&mut numero).expect("Falha ao ler a entrada");
   numeros[i] = numero.trim().parse().expect("Por favor, digite um número inteiro válido");
}


println!("Insira um número inteiro para buscar: ");
let mut numero_busca = String::new();
io::stdin().read_line(&mut numero_busca).expect("Falha ao ler a entrada");
let numero_busca: i32 = numero_busca.trim().parse().expect("Por favor, digite um número inteiro válido");


let posicao = buscar_numero(numeros, numero_busca);


if posicao == -1 {
   println!("O número não está no vetor");
} else {
   println!("O número está na posição {} do vetor", posicao);
}
}


fn buscar_numero(numeros: [i32; 20], numero_busca: i32) -> i32 {
for (i, numero) in numeros.iter().enumerate() {
if *numero == numero_busca {
return i as i32;
}
}
return -1;
}



O diagrama de sequência mostra o fluxo de execução do programa para a busca de um número inteiro em um vetor.
Ele começa com a leitura de 20 números inteiros pelo usuário e armazenamento desses números em um vetor. Em seguida, é lido um novo número inteiro pelo usuário e passado como argumento para a função buscar_numero, que verifica se o número está presente no vetor.
Se o número for encontrado, a função retorna a posição do número no vetor. Caso contrário, a função retorna -1. O resultado da função é armazenado em uma variável e, por fim, é impresso na tela.

Recursividade


A recursividade é um conceito fundamental em programação, que permite que uma função chame a si mesma de forma controlada. Isso pode ser útil para resolver problemas que podem ser divididos em subproblemas menores e independentes, o que pode ser mais fácil de resolver do que o problema inteiro.


Em Rust, você pode implementar a recursividade de forma semelhante a como faria em qualquer outra linguagem de programação. Aqui está um exemplo de uma função recursiva simples que calcula o fatorial de um número:




fn factorial(n: u64) -> u64 {
   if n == 0 {
       1
   } else {
       n * factorial(n - 1)
   }
}
Neste exemplo, a função factorial chama a si mesma com n - 1 até que n seja igual a zero, quando a recursão para e a função retorna 1. A cada chamada da função, o valor de n é multiplicado pelo resultado da chamada recursiva, resultando no fatorial do número original.


É importante ter cuidado ao implementar a recursividade, pois ela pode facilmente levar a chamadas de função infinitas se não houver uma condição de parada adequada. Além disso, a recursividade pode consumir muita memória e tempo de processamento, então é importante considerar se há uma maneira iterativa de resolver o problema.




Vejamos o diagrama de sequencia da função factorial:



Este diagrama mostra a sequência de eventos que ocorrem quando a função factorial é chamada. Primeiro, o usuário chama a função factorial com um valor de n. Em seguida, a função é ativada e chama a si mesma com n - 1. Isso continua até que n seja igual a zero, quando a função retorna 1. A cada chamada da função, o valor de n é multiplicado pelo resultado da chamada recursiva, resultando no fatorial do número original. Finalmente, o resultado é retornado para o usuário e a função é desativada.


A função abaixo não utiliza recursividade:




fn factorial(n: i32) -> i32 {
   let mut fat = 1;
   for i in (1..=n).rev() {
       fat *= i;
   }
   fat
}


fn main() {
   println!("Informe um número: ");


   let mut num = String::new();
   std::io::stdin().read_line(&mut num).unwrap();


   let num: i32 = num.trim().parse().unwrap();
   let result = factorial(num);


   println!("Fatorial de {} é {}", num, result);
}


Aqui está um teste de mesa para o programa de cálculo de fatorial iterativo em Rust que você forneceu:
Valor de entrada
Valor de saída
Valor de n
Valor de i
Valor de fat
5
120
5
5
5






4
20






3
60






2
120






1
120

Este teste de mesa mostra o resultado da função factorial para o valor de entrada de 5 e os valores das variáveis n, i e fat em cada iteração do loop.
Ao calcular o fatorial de 5, a função é chamada com n igual a 5. O loop é iniciado com i igual a 5 e fat igual a 1. Na primeira iteração, fat é multiplicado por i, resultando em 5. Na segunda iteração, `




O diagrama de sequencia do programa é:





Este diagrama mostra a sequência de eventos que ocorrem quando o programa é executado. Primeiro, o usuário inicia o programa, ativando a função main. Em seguida, a função main lê um número da entrada padrão e chama a função factorial com esse número. A função factorial é ativada e itera sobre o intervalo de 1 a n, multiplicando o valor de fat pelo valor atual de i em cada iteração. Quando a iteração termina, a função retorna o valor final de fat como resultado. O resultado é então retornado para a função main, que o imprime no console. Finalmente, as funções main e factorial são desativadas.




Aqui está como você pode modificar a função factorial para que ela seja recursiva em vez de iterativa:


fn factorial(n: i32) -> i32 {
   if n == 0 {
       1
   } else {
       n * factorial(n - 1)
   }
}


fn main() {
   println!("Informe um número: ");


   let mut num = String::new();
   std::io::stdin().read_line(&mut num).unwrap();


   let num: i32 = num.trim().parse().unwrap();
   let result = factorial(num);


   println!("Fatorial de {} é {}", num, result);
}
Aqui está um teste de mesa para o programa de cálculo de fatorial recursivo em Rust que você forneceu:
Valor de entrada
Valor de saída
Valor de n
Valor de result
5
120
5
120
4
24
4
24
3
6
3
6
2
2
2
2
1
1
1
1
0
1
0
1

Este teste de mesa mostra o resultado da função factorial para diferentes valores de entrada e o valor das variáveis n e result em cada chamada da função.
Ao calcular o fatorial de 5, a função é chamada com n igual a 5 e retorna 120. Em seguida, a função é chamada com n igual a 4 e retorna 24. Isso continua até que a função seja chamada com n igual a zero, quando a recursão para e a função retorna 1. A cada chamada da função, o valor de n é multiplicado pelo resultado da chamada recursiva, resultando no fatorial do número original.



Este diagrama mostra a sequência de eventos que ocorrem quando o programa é executado. Primeiro, o usuário inicia o programa, ativando a função main. Em seguida, a função main lê um número da entrada padrão e chama a função factorial com esse número. A função factorial é ativada e chama a si mesma com num - 1 até que num seja igual a zero, quando a recursão para e a função retorna 1. A cada chamada da função, o valor de num é multiplicado pelo resultado da chamada recursiva, resultando no fatorial do número original. O resultado é então retornado para a função main, que o imprime no console. Finalmente, as funções main e factorial são desativadas.


Loop inﬁnito na recursividade


É extremamente importante que um algoritmo recursivo não crie uma sequência infinita de chamadas a si mesmo (TENENBAUM; LANGSAM; AUGENSTEIN, 1995, p. 143), pois caso isso ocorra, o programa não conseguirá completar a operação e não terminará de forma natural. Em vez disso, é provável que o programa seja interrompido de forma forçada ou gere exceções devido à falta de memória e outros problemas. Para evitar esses problemas, é importante garantir que a função recursiva tenha uma forma de sair da sequência de execuções, como mostrado na adaptação a seguir do código da função recursiva.


fn factorial(n: i32) -> i32 {
   n * factorial(n - 1)
}
Aqui está um teste de mesa para o programa de cálculo de fatorial recursivo em Rust que você forneceu, com o valor de entrada de n igual a 5:
Valor de entrada
Valor de saída
Valor de n
5
120
5
4
48
4
3
12
3
2
2
2
1
1
1
0
0
0
-1
0
-1
-2
0
-2

Este teste de mesa mostra o resultado da função factorial para o valor de entrada de 5 e o valor de n em cada chamada da função.
Como o código não possui uma condição de parada, a função é chamada continuamente com n diminuindo de valor a cada chamada. Isso resulta em um resultado incorreto para todas as chamadas, independentemente do valor de entrada.
Sem uma condição de parada, o código acima resultará em um loop infinito. É importante incluir uma condição de parada na função para garantir que ela pare de ser chamada quando for apropriado.








Uma observação importante é que, como este código não possui uma condição de parada, ele provavelmente resultará em um loop infinito quando chamado. Para evitar esse problema, é importante adicionar uma condição de parada à função. Por exemplo:




fn factorial(n: i32) -> i32 {
   if n == 0 {
       1
   } else {
       n * factorial(n - 1)
   }
}
Isso garante que a função pare de ser chamada quando n



Exercícios da Aula
Parte dos exercícios desta lista foram Adaptados de Tenenbaum, Langsam e Augenstein
(1995, p. 143-178) e Edelweiss e Livi (2014, p. 433-436).


1) Faça um programa em rust que calcule, por meio de uma função recursiva, a * b usando a adição, em que a e b são inteiros não-negativos.


fn mult(a: i32, b: i32) -> i32 {
   if b == 0 {
       0
   } else {
       a + mult(a, b - 1)
   }
}
fn main() {
   let a = 3;
   let b = 4;
   let resultado = mult(a, b);
   println!("O resultado da multiplicação de {} por {} é {}", a, b, resultado);
}




O diagram





Este diagrama mostra os passos envolvidos na execução da função mult(), desde a chamada da função main() até a impressão do resultado da multiplicação. O loop no diagrama representa a recursão na função mult().


2. Crie uma função recursiva que receba um número inteiro positivo N e calcule o somatório dos números de 1 a N.


fn somatorio(n: i32) -> i32 {
   // Se n for igual a 1, retornamos 1
   if n == 1 {
       return 1;
   }
   // Caso contrário, chamamos a função novamente com n-1 e adicionamos o valor de n ao resultado
   return somatorio(n - 1) + n;
}




Vamos explicar cada linha do código:


fn somatorio(n: i32) -> i32 {: Essa linha declara a função "somatorio" que recebe um argumento inteiro "n" e retorna um inteiro.


if n == 1 {: Essa linha verifica se o valor de "n" é igual a 1.


return 1;: Se o valor de "n" for igual a 1, a função retorna 1.


return somatorio(n - 1) + n;: Caso contrário, a função é chamada novamente com "n-1" e o resultado é adicionado ao valor de "n". Isso é conhecido como recursão.










O diagrama mostra que a função "somatorio" é chamada com um argumento "n" e verifica se o valor de "n" é igual a 1. Se for, a função retorna 1. Caso contrário, a função é chamada novamente com "n-1" e o resultado é adicionado ao valor de "n". Isso continua até que o valor de "n" seja igual a 1, quando a função finalmente retorna o resultado.


Exemplo de código:
use std::io;


fn somatorio(n: i32) -> i32 {
   // Se n for igual a 1, retornamos 1
   if n == 1 {
       return 1;
   }
   // Caso contrário, chamamos a função novamente com n-1 e adicionamos o valor de n ao resultado
   return somatorio(n - 1) + n;
}


fn main() {
   println!("Digite um número inteiro positivo:");


   // Lê o número digitado pelo usuário
   let mut num = String::new();
   io::stdin().read_line(&mut num).expect("Falha ao ler entrada");


   // Converte o número de String para i32
   let num: i32 = num.trim().parse().expect("Por favor, digite um número inteiro válido");


   // Chama a função "somatorio" com o número digitado pelo usuário e armazena o resultado em uma variável
   let resultado = somatorio(num);


   // Imprime o resultado
   println!("O somatório de 1 a {} é {}", num, resultado);
}



O diagrama mostra que o usuário inicia o programa chamando a função "main()", que solicita que o usuário digite um número inteiro positivo. O número 10 é passado para a função "somatorio()", que é chamada recursivamente até que o valor de "n" seja igual a 1. Quando isso acontece, a função retorna 1 e todas as chamadas recursivas são combinadas, resultando no valor final que é retornado à função "main()". A função "main()" então imprime o resultado para o usuário.







3. Considere um vetor vet de tamanho 20. Construa um programa com algoritmos recursivos para calcular:
• o elemento máximo do vetor;
• o elemento mínimo do vetor;
• a soma dos elementos do vetor;
• o produto dos elementos do vetor;
• a média dos elementos do vetor.


fn elemento_maximo(vetor: &[i32], tamanho: usize) -> i32 {
   // Se o tamanho do vetor for igual a 1, retornamos o único elemento
   if tamanho == 1 {
       return vetor[0];
   }
   // Caso contrário, comparamos o último elemento com o resultado da chamada recursiva para o resto do vetor
   let ultimo = vetor[tamanho - 1];
   let maximo = elemento_maximo(vetor, tamanho - 1);
   // Retornamos o maior dos dois
   if ultimo > maximo {
       ultimo
   } else {
       maximo
   }
}


fn elemento_minimo(vetor: &[i32], tamanho: usize) -> i32 {
   // Se o tamanho do vetor for igual a 1, retornamos o único elemento
   if tamanho == 1 {
       return vetor[0];
   }
   // Caso contrário, comparamos o último elemento com o resultado da chamada recursiva para o resto do vetor
   let ultimo = vetor[tamanho - 1];
   let minimo = elemento_minimo(vetor, tamanho - 1);
   // Retornamos o menor dos dois
   if ultimo < minimo {
       ultimo
   } else {
       minimo
   }
}


fn soma(vetor: &[i32], tamanho: usize) -> i32 {
   // Se o tamanho do vetor for igual a 1, retornamos o único elemento
   if tamanho == 1 {
       return vetor[0];
   }
   // Caso contrário, adicionamos o último elemento ao resultado da chamada recursiva para o resto do vetor
   return soma(vetor, tamanho - 1) + vetor[tamanho - 1];
}


fn produto(vetor: &[i32], tamanho: usize) -> i32 {
   // Se o tamanho do vetor for igual a 1, retornamos o único elemento
   if tamanho == 1 {
       return vetor[0];
   }
   // Caso contrário, multiplicamos o último elemento pelo resultado da chamada recursiva para o resto do vetor
   return produto(vetor, tamanho - 1) * vetor[tamanho - 1];
}


fn media(vetor: &[i32], tamanho: usize) -> f64 {
   // Calculamos a soma dos elementos do vetor
   let soma = soma(vetor, tamanho) as f64;
   // Calculamos a média dividindo a soma pelo tamanho do vetor e retornamos o resultado
   soma / tamanho as f64
}


fn main() {
   // Cria um vetor de tamanho 20 e preenche-o com alguns valores
   let vetor = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
   let tamanho = vetor.len();


   
   // Chama as funções para calcular o elemento máximo, o elemento mínimo, a soma, o produto e a média do vetor
   let maximo = elemento_maximo(&vetor, tamanho);
   let minimo = elemento_minimo(&vetor, tamanho);
   let soma = soma(&vetor, tamanho);
   let produto = produto(&vetor, tamanho);
   let media = media(&vetor, tamanho);


   // Exibe os resultados
   println!("O elemento máximo do vetor é {}", maximo);
   println!("O elemento mínimo do vetor é {}", minimo);
   println!("A soma dos elementos do vetor é {}", soma);
   println!("O produto dos elementos do vetor é {}", produto);
   println!("A média dos elementos do vetor é {:.2}", media);
}


4. A sequência de Fibonacci é a sequência de inteiros: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ....
Implemente uma função recursiva que calcule e imprima todos os elementos da série Fibonacci de 0 até n. Em que, n deve ser informado pelo usuário do programa.


fn fibonacci(n: i32) {
   // Variáveis para armazenar os dois últimos termos da série
   let mut a: i32 = 0;
   let mut b: i32 = 1;


   // Laço que itera de 0 até n
   for i in 0..=n {
       // Se estivermos na primeira ou segunda iteração, imprimimos o valor de i
       // (que será o primeiro ou segundo termo da série, respectivamente)
       if i <= 1 {
           println!("{}", i);
       } else {
           // Caso contrário, calculamos o próximo termo da série como a soma dos dois últimos termos
           let c: i32 = a + b;
           println!("{}", c);


           // Atualizamos as variáveis a e b com os novos valores
           a = b;
           b = c;
       }
   }
}


Aqui está um teste de mesa da função fibonacci para o caso de n = 3:
Iteração
i
a
b
c
Saída
1
0
0
1


0
2
1
1
1


1
3
2
1
2
3
3

Na primeira iteração, o valor de i é 0, então imprimimos o valor de i (que é 0). Na segunda iteração, o valor de i é 1, então também imprimimos o valor de i (que é 1). Na terceira iteração, o valor de i é 2, então calculamos o próximo termo da série como a soma dos dois últimos termos (que são 1 e 1). O resultado é 3, então imprimimos esse valor e atualizamos as variáveis a e b com os novos valores (que são 1 e 2, respectivamente).



6. Escreva um programa recursivo em linguagem Rust para converter um número da sua forma decimal para a forma binária. Dica: dividir o número sucessivamente por 2, sendo que o resto da i-ésima divisão vai ser o dígito i do número binário (da direita para a esquerda).


Solução:


A ideia da função recursiva é a de que, enquanto o resto da divisão entre os dois números for diferente de zero, continuamos a chamar a função com os dois números sendo o divisor e o resto da divisão entre eles. Quando o resto da divisão for zero, o divisor será o MDC.


fn mdc(x: i32, y: i32) -> i32 {
   // Verifica se o resto da divisão entre x e y é zero
   if y == 0 {
       // Se for zero, x é o MDC
       return x;
   }


   // Se não for zero, chama a função novamente com y como divisor e o resto da divisão entre x e y como o outro número
   return mdc(y, x % y);
}


fn main() {
   // Calcula o MDC de 15 e 10
   let resultado = mdc(15, 10);
   println!("O MDC de 15 e 10 é {}", resultado);
}



No diagrama acima, a função mdc é chamada pelo usuário com os números 15 e 10. A função verifica se o resto da divisão entre x e y (10) é zero. Como não é zero, a função é chamada novamente com y (10) como divisor e o resto da divisão entre x (15) e y (10) como o outro número. Esse processo é repetido até que o resto da divisão seja zero, então o MDC é retornado para o usuário. No caso do exemplo, o MDC é 5.


6. Escreva um programa recursivo em linguagem C para converter um número da sua forma decimal para a forma binária. Dica: dividir o número sucessivamente por 2, sendo que o resto da i-ésima divisão vai ser o dígito i do número binário (da direita para a esquerda).


fn converte_para_binario(numero: i32) -> String {
   // Se o número for zero, retorna "0"
   if numero == 0 {
   return "0".to_string();
   }
  
   
   // Inicializa uma string vazia para armazenar os dígitos do número binário
   let mut binario = "".to_string();
  
   // Enquanto o número for maior que zero
   while numero > 0 {
       // Adiciona o resto da divisão por 2 na string binário
       binario = format!("{}{}", numero % 2, binario);
       // Divide o número por 2
       numero /= 2;
   }
  
   // Retorna o número binário
   return binario;
   }
  
   fn main() {
   // Converte o número 10 para binário
   let resultado = converte_para_binario(10);
   println!("O número 10 em binário é {}", resultado);
   }


A função "converte_para_binario" é declarada, recebendo um parâmetro "numero" do tipo "i32" e retornando uma string.
É verificado se o número é zero. Se for, a função retorna a string "0".
É inicializada uma string vazia chamada "binario" para armazenar os dígitos do número binário.
Inicia-se um loop "while" enquanto o número for maior que zero.
Adiciona-se o resto da divisão do número por 2 na string "binario", usando o formato "{}{}" para inserir o novo dígito no início da string.
Divide-se o número por 2.
Quando o loop terminar, a função retorna o número binário armazenado na string "binario".
Na função "main", o número 10 é convertido para binário e impresso na tela.




7. Escreva uma função recursiva em linguagem Rust para calcular o valor de x^n


use std::io;


fn potencia(x: i32, n: i32) -> i32 {
   // Se n for zero, retorna 1
   if n == 0 {
   return 1;
   }


   
   // Se n for positivo, retorna x multiplicado pela potência de x decrementada em 1
   if n > 0 {
       return x * potencia(x, n - 1);
   }


   // Se n for negativo, retorna 1 dividido pela potência de x decrementada em 1
   return 1 / potencia(x, -n - 1);
}


fn main() {
   println!("Informe o valor de x:");


   
   // Lê o valor de x digitado pelo usuário
   let mut x = String::new();
   io::stdin().read_line(&mut x).expect("Falha ao ler entrada");
   let x: i32 = x.trim().parse().expect("Por favor, digite um número válido");


   println!("Informe o valor de n:");


   // Lê o valor de n digitado pelo usuário
   let mut n = String::new();
   io::stdin().read_line(&mut n).expect("Falha ao ler entrada");
   let n: i32 = n.trim().parse().expect("Por favor, digite um número válido");


   // Calcula o valor de x^n
   let resultado = potencia(x, n);
   println!("O valor de {}^{} é {}", x, n, resultado);
}


Se a leitura dos dados for encapsulado na função le_dados, temos:


use std::io;


fn potencia(x: i32, n: i32) -> i32 {
   // Se n for zero, retorna 1
   if n == 0 {
   return 1;
   }


   
   // Se n for positivo, retorna x multiplicado pela potência de x decrementada em 1
   if n > 0 {
       return x * potencia(x, n - 1);
   }


   // Se n for negativo, retorna 1 dividido pela potência de x decrementada em 1
   return 1 / potencia(x, -n - 1);
}


fn le_dados(mensagem: &str) -> i32 {
   println!("{}", mensagem);


   
   // Lê o valor digitado pelo usuário
   let mut entrada = String::new();
   io::stdin().read_line(&mut entrada).expect("Falha ao ler entrada");


   // Retorna o valor lido como i32, ou exibe uma mensagem de erro em caso de falha
   return entrada.trim().parse().expect("Por favor, digite um número válido");
}


fn main() {
   // Lê o valor de x digitado pelo usuário
   let x = le_dados("Informe o valor de x:");


   
   // Lê o valor de n digitado pelo usuário
   let n = le_dados("Informe o valor de n:");


   // Calcula o valor de x^n
   let resultado = potencia(x, n);
   println!("O valor de {}^{} é {}", x, n, resultado);
}


O diagrama de sequencia fica assim



No diagrama acima, a função "le_dados" é chamada duas vezes pelo usuário para ler os valores de x e n. Em seguida, a função "potencia" é chamada com esses valores como parâmetros. A função verifica se n é zero, positivo ou negativo, e realiza as operações correspondentes para calcular o valor de x^n. O resultado é então retornado para o usuário.






8. Escreva um programa em rust recursivo que inverta a ordem dos elementos, nú- meros inteiros, de uma lista armazenada em um vetor. Ao final da execução, o conteúdo do primeiro elemento deverá estar no último, o do segundo no pe- núltimo, e assim por diante. Dica: troque os conteúdos das duas extremidades do vetor e chame uma função recursivamente para fazer o mesmo no subvetor interno.


fn inverte_vetor(vetor: &mut [i32], inicio: usize, fim: usize) {
   // Se início for maior ou igual a fim, a função retorna
   if inicio >= fim {
   return;
   }
  
   
   // Troca os valores do início e do fim
   let temp = vetor[inicio];
   vetor[inicio] = vetor[fim];
   vetor[fim] = temp;
  
   // Chama a função novamente para inverter os valores no subvetor interno
   inverte_vetor(vetor, inicio + 1, fim - 1);
}
  
fn main() {
   // Cria um vetor com os números 1 a 5
   let mut vetor = [1, 2, 3, 4, 5];


   
   // Inverte o vetor
   inverte_vetor(&mut vetor, 0, vetor.len() - 1);


   println!("O vetor invertido é {:?}", vetor);
}

No diagrama acima, a função "inverte_vetor" é chamada pelo usuário com o vetor e os índices de início e fim. A função verifica se o índice de início é maior ou igual ao índice de fim, e, se for, a função retorna. Caso contrário, os valores no índice de início e de fim são trocados e a função é chamada novamente para inverter os valores no subvetor interno, até que o índice de início seja maior ou igual ao índice de fim.






9. Escreva uma função recursiva para calcular a função de Ackermann A(m,n), sendo m e n valores inteiros não negativos, dada por: 







use std::io;


fn le_dado(mensagem: &str) -> i32 {
   let mut input = String::new();


   println!("{}", mensagem);
   io::stdin().read_line(&mut input).expect("Falha ao ler entrada");


   match input.trim().parse() {
       Ok(num) => num,
       Err(_) => {
           println!("Valor inválido");
           return le_dado(mensagem);
       }
   }
}


fn ackermann(m: i32, n: i32) -> i32 {
   if m == 0 {
       n + 1
   } else if n == 0 {
       ackermann(m - 1, 1)
   } else {
       ackermann(m - 1, ackermann(m, n - 1))
   }
}


fn main() {
   let m = le_dado("Insira o valor de m: ");
   let n = le_dado("Insira o valor de n: ");
   let resultado = ackermann(m, n);
   println!("Resultado: {}", resultado);
}



O diagrama de sequência da UML mostra a execução de uma série de ações (chamadas de "mensagens") entre os objetos (ou "atores") envolvidos em um processo. No caso do programa acima, temos um único ator, o "Usuário", que inicia a execução do programa ao chamar a função main().
A função main() então chama a função le_dado duas vezes, para ler os valores de m e n do usuário. A função le_dado lê a entrada do usuário, valida o valor lido e retorna o resultado para a função main().
Em seguida, a função main() chama a função ackermann passando os valores de m e n lidos. A função ackermann é implementada de forma recursiva, ou seja, ela chama a si mesma para calcular o resultado da função de Ackermann. Ela verifica os valores de m e n e, de acordo com as regras da função de Ackermann, retorna o resultado ou chama a si mesma novamente com novos valores de m e n.
Por fim, a função main() imprime o resultado da função de Ackermann na tela.






10. Imagine que comm(n,k) representa o número de diferentes comitês de k pessoas, que podem ser formados, dadas n pessoas a partir das quais escolher. Por exemplo, comm(4,3) = 4, porque dadas quatro pessoas, A, B, C e D existem quatro possíveis comitês de três pessoas: ABC, ABD, ACD e BCD. Escreva e teste um programa recursivo em C para calcular comm(n,k) para n, k >= 1. Para tal, considere a seguinte identidade:


comm(n r k) = n, se k = 1
comm(n r k) = 1, se k = n
comm(n r k) = comm(n - 1, K ) + comm(n - 1, k - 1), se 1 < k < n


fn comm(n: i32, k: i32) -> i32 {
   if k == 1 {
       return n;
   } else if k == n {
       return 1;
   } else if 1 < k && k < n {
       return comm(n - 1, k) + comm(n - 1, k - 1);
   } else {
       panic!("Os valores de n e k devem ser maiores ou iguais a 1.");
   }
}


fn main() {
   assert_eq!(comm(4, 3), 4);
   assert_eq!(comm(5, 4), 5);
   assert_eq!(comm(6, 5), 6);
}



O diagrama acima mostra o fluxo de execução do método comm quando é chamado com os argumentos (4, 3). A primeira chamada recursiva é comm(3, 3), seguida por comm(2, 3) e por último comm(1, 3). Como o valor de k é maior que o valor de n, a função lança uma exceção com a mensagem "Os valores de n e k devem ser maiores ou iguais a 1.".
É importante notar que o diagrama acima só representa um dos caminhos possíveis de execução da função comm, dependendo dos valores passados como argumento. Para uma representação completa do fluxo de execução da função, seria necessário incluir todas as possíveis combinações de valores para n e k.




ATENÇÃO
A função panic! é uma macro (um tipo especial de função em Rust) que é usada para gerar uma exceção em tempo de execução, ou seja, uma interrupção na execução do programa. Ela é chamada quando o código detecta uma condição de erro ou exceção inesperada, e pode ser usada para fornecer informações adicionais sobre o erro por meio de uma mensagem de erro.
Ao chamar a função panic!, o programa é interrompido e é gerada uma mensagem de erro, que é exibida no console. Em seguida, o programa encerra a execução e retorna um código de saída apropriado para indicar que ocorreu um erro.
A função panic! é útil em situações em que o código não pode continuar a execução de forma segura ou correta, como em caso de erro de sintaxe, problemas de memória ou outros problemas inesperados. Ela também pode ser usada como uma forma de garantir que certas condições sejam satisfeitas antes de continuar a execução do código, como verificações de pre-condição.

Ponteiros


Os ponteiros são uma característica de muitas linguagens de programação e são usados ​​para armazenar endereços de memória. O ponteiro é uma variável especial que guarda o endereço de memória de outra variável, em vez de armazenar o próprio dado. Para declarar um ponteiro, é preciso definir um tipo de dado, como int, float ou char. Isso significa que o ponteiro é capaz de armazenar apenas o endereço de memória de uma variável do determinado tipo especificado. Enquanto as variáveis tradicionais armazenam os próprios dados, os ponteiros são usados ​​para acessar os dados armazenados em um endereço de memória específico. (FEOFILOFF, 2008)
Os ponteiros são uma ferramenta poderosa em programação, mas também podem ser confusos. Eles "apontam" para um endereço de memória que armazena um valor de um determinado tipo, como int. Uma das maiores dificuldades com os ponteiros é saber se estamos acessando o próprio valor do ponteiro ou o dado armazenado no endereço de memória apontado pelo ponteiro. A capacidade de armazenar o endereço de memória de uma variável torna os ponteiros úteis para passagem de parâmetros por referência, como no exemplo de um cálculo de juros em uma aplicação financeira, onde é preciso atualizar o saldo.
Eles podem ser úteis em várias situações, como:
Alocação dinâmica de memória: os ponteiros podem ser usados ​​para alocar memória dinamicamente durante a execução do programa, permitindo que você crie novos objetos ou matrizes sem precisar saber o tamanho exato no momento da compilação.
Acesso a elementos de uma estrutura de dados: os ponteiros podem ser usados ​​para acessar elementos de estruturas de dados, como listas ligadas ou árvores, de forma mais eficiente do que usando índices ou chaves.
Passagem de parâmetros por referência: os ponteiros podem ser usados ​​para passar parâmetros para uma função por referência, permitindo que a função modifique os valores dos parâmetros de forma permanente. Isso pode ser útil quando você precisa passar grandes quantidades de dados para uma função ou quando deseja evitar a cópia desnecessária de dados.
Implementação de algoritmos recursivos: os ponteiros podem ser usados ​​para implementar algoritmos recursivos, permitindo que as funções chamem a si mesmas de forma a percorrer uma estrutura de dados de forma hierárquica.
É importante notar que os ponteiros também podem ser um ponto de erro comum em programas, pois eles exigem mais atenção e cuidado do programador. Alguns dos erros mais comuns com ponteiros incluem usá-los sem inicializá-los, acessar memória fora dos limites do programa e esquecer de liberar a memória alocada dinamicamente.


A alocação dinâmica de memória é um processo pelo qual um programa pode solicitar ao sistema operacional um bloco de memória durante a execução do programa. Isso é útil quando você não sabe quanto espaço de memória será necessário para armazenar um determinado conjunto de dados ou quando precisa criar um objeto ou matriz de tamanho variável.
Para alocar memória dinamicamente, as linguagens de programação geralmente fornecem uma função especial chamada "malloc" (em C) ou "new" (em C++, Java, C#, entre outras). Essa função recebe como parâmetro o tamanho em bytes de memória a ser alocado e retorna um ponteiro para o primeiro byte desse bloco de memória.
Por exemplo, em C, você pode alocar dinamicamente um vetor de 10 inteiros da seguinte maneira:
int vetor = (int) malloc(10 * sizeof(int));
Isso cria um vetor de 10 inteiros e armazena o endereço do primeiro elemento no ponteiro "vetor". Depois, você pode acessar os elementos do vetor usando o operador de deslocamento, como em vetor[0] ou vetor[9].
Uma vez que você terminou de usar o espaço de memória alocado dinamicamente, é importante liberá-lo para que o sistema operacional possa reutilizá-lo. Isso é feito usando a função "free" (em C) ou "delete" (em C++, Java, C#, entre outras). Por exemplo, para liberar o vetor alocado anteriormente, você pode fazer:
free(vetor);
Em resumo, a alocação dinâmica de memória permite que você crie objetos ou matrizes de tamanho variável durante a execução do programa, o que pode ser útil em muitas situações. No entanto, é importante lembrar de liberar a memória alocada dinamicamente quando ela não for mais necessária, para evitar problemas de desperdício de memória ou vazamento de memória.


Em Rust, a alocação dinâmica de memória é realizada através do uso de tipos de dados especiais chamados "box". Um "box" é um ponteiro para uma estrutura de dados alocada dinamicamente na heap (área de memória compartilhada entre todos os processos).
Para criar um "box", você pode usar o operador "box" seguido do valor que deseja armazenar. Por exemplo, para criar um "box" contendo um inteiro, você pode fazer:


let x = box 5;
Para acessar o valor armazenado no "box", você pode usar o operador de desreferenciação "*". Por exemplo:


let y = *x;
Quando você terminar de usar um "box", é importante liberar a memória alocada para evitar vazamentos de memória. Isso é feito automaticamente pelo coletor de lixo do Rust, que verifica periodicamente quais "boxes" não estão mais sendo usados ​​e libera sua memória.
Além dos "boxes", o Rust também possui outros tipos de ponteiros, como "references" (referências) e "raw pointers" (ponteiros cru). Esses tipos de ponteiros são úteis em situações específicas, mas exigem mais cuidado do programador para evitar problemas de segurança de memória.
Os "boxes" em Rust permitem a alocação dinâmica de memória durante a execução do programa e são gerenciados pelo coletor de lixo do Rust, o que torna mais fácil evitar problemas de vazamento de memória. No entanto, é importante lembrar que os "boxes" só podem armazenar valores e não podem ser usados ​​para implementar estruturas de dados mais complexas, como listas ligadas ou árvores.


os ponteiros podem ser usados ​​para acessar elementos de uma estrutura de dados de forma eficiente. Por exemplo, você pode usar um ponteiro para acessar um elemento de uma matriz ou lista ligada sem precisar percorrer todos os elementos anteriores. Isso pode ser útil quando você precisa acessar elementos aleatórios em uma estrutura de dados ou quando deseja evitar a cópia desnecessária de dados.


Para usar ponteiros em Rust, você primeiro precisa importar o módulo std::ptr. Em seguida, você pode usar os operadores & e * para obter e acessar ponteiros. Por exemplo, o código a seguir mostra como acessar o primeiro elemento de uma matriz usando um ponteiro:


use std::ptr;


let mut arr = [1, 2, 3, 4];
let p = arr.as_mut_ptr(); // obtém um ponteiro para o primeiro elemento da matriz
let x = unsafe { *p }; // acessa o valor do primeiro elemento através do ponteiro
println!("{}", x); // imprime "1"


É importante observar que o uso de ponteiros em Rust requer muito cuidado e atenção, pois o compilador não realiza verificações de tipo ou limites ao trabalhar com ponteiros. Isso significa que é fácil cometer erros ao usar ponteiros, como acessar memória fora dos limites do programa ou esquecer de liberar a memória alocada dinamicamente. Para evitar esses erros, é importante usar a marcação unsafe com cuidado e garantir que você esteja ciente dos riscos envolvidos ao trabalhar com ponteiros em Rust.




Em Rust, você pode usar ponteiros para passar parâmetros para uma função por referência, permitindo que a função modifique os valores dos parâmetros de forma permanente. Isso é feito adicionando um símbolo '&' antes do tipo de parâmetro.


Por exemplo, considere a seguinte função que altera o valor de um número inteiro:


fn add_one(x: &mut i32) {
  *x += 1;
}






Aqui, 'x' é um ponteiro para um inteiro mutável. O símbolo '*' é usado para desreferenciar o ponteiro e acessar o valor apontado. A função 'add_one' modifica o valor apontado por 'x' adicionando 1 a ele.


Para chamar essa função e passar um parâmetro por referência, você precisará usar o símbolo '&mut' antes da variável:




let mut y = 5;
add_one(&mut y);
println!("{}", y);  // imprime 6




Aqui, 'y' é uma variável mutável que é passada por referência para a função 'add_one'. Depois que a função é chamada, o valor de 'y' é alterado para 6.


É importante notar que, quando você passa uma variável por referência, ela precisa ser mutável. Isso significa que você precisa usar o modificador 'mut' na declaração da variável. Se você tentar passar uma variável imutável por referência, obterá um erro de compilação.


A implementação de algoritmos recursivos com ponteiros em Rust é semelhante à implementação de algoritmos recursivos em outras linguagens de programação. Aqui está um exemplo simples de uma função recursiva que calcula o fatorial de um número inteiro usando ponteiros:




fn fatorial(num: &mut i32) -> i32 {
   // caso base: se o número for 0, retorne 1
   if *num == 0 {
       return 1;
   }
   // caso recursivo: chame a função novamente com num - 1 e multiplique pelo valor atual de num
   *num *= fatorial(&mut (*num - 1));
}


fn main() {
   let mut num = 5;
   println!("O fatorial de {} é {}", num, fatorial(&mut num));
}
Neste exemplo, a função fatorial é uma função recursiva que recebe um ponteiro para um inteiro num. A função verifica se num é zero e, se for, retorna 1. Se num não for zero, a função chama a si mesma novamente com num - 1 e multiplica o resultado pelo valor atual de num. Isso permite que a função calcule o fatorial de num de forma recursiva.


Na função main, criamos um inteiro mutável chamado num e o inicializamos com o valor 5. Em seguida, chamamos a função fatorial passando um ponteiro para num como argumento e imprimimos o resultado. O resultado impresso deve ser "O fatorial de 5 é 120".


Espero que isso ajude a entender como os ponteiros podem ser usados ​​para implementar algoritmos recursivos em Rust. Se você tiver mais perguntas ou quiser ver mais exemplos, fique à vontade para perguntar.


Aqui está um outro exemplo simples de uma função recursiva que calcula a soma dos elementos de uma matriz usando ponteiros:


fn soma_matriz(matriz: &[i32], tamanho: &mut usize) -> i32 {
   // caso base: se o tamanho da matriz for zero, retorne 0
   if *tamanho == 0 {
       return 0;
   }
   // caso recursivo: chame a função novamente com tamanho - 1 e some o último elemento da matriz
   let ultimo_elemento = matriz[*tamanho - 1];
   *tamanho -= 1;
   ultimo_elemento + soma_matriz(matriz, tamanho)
}


fn main() {
   let matriz = [1, 2, 3, 4, 5];
   let mut tamanho = matriz.len();
   println!("A soma dos elementos da matriz é {}", soma_matriz(&matriz, &mut tamanho));
}
Neste exemplo, a função soma_matriz é uma função recursiva que recebe um ponteiro para uma matriz de inteiros matriz e um ponteiro para um valor do tipo usize chamado tamanho. A função verifica se tamanho é zero e, se for, retorna 0. Se tamanho não for zero, a função armazena o último elemento da matriz em uma variável chamada ultimo_elemento, decrementa tamanho em 1 e chama a si mesma novamente passando os mesmos argumentos. A função retorna então a soma de ultimo_elemento e o resultado da chamada recursiva.


Na função main, criamos uma matriz de inteiros e inicializamos com alguns valores. Em seguida, criamos um valor mutável do tipo usize chamado tamanho e o inicializamos com o tamanho da matriz. Em seguida, chamamos a função soma_matriz passando um ponteiro para a matriz e um ponteiro para tamanho como argumentos e imprimimos o resultado. O resultado impresso deve ser "A soma dos elementos da matriz é 15".


Espero que este exemplo ajude a entender como os ponteiros podem ser usados ​​para implementar algoritmos recursivos em Rust. Se você tiver mais perguntas ou quiser ver mais exemplos, fique à vontade para perguntar.


Exercício de exemplo


Crie um programa em Rust que calcule os juros de um saldo específico com base em uma taxa fornecida pelo usuário. Utilize uma função para calcular os juros e atualizar o saldo atual baseado no saldo anterior mais os juros. No final, o programa deve imprimir o total de juros e o novo saldo.
use std::io;


fn calcula_juros(saldo: &mut f32, taxa: f32) -> f32 {
   let juros = *saldo * taxa / 100.0;
   *saldo += juros;
   return juros;
}


fn main() {
   let mut v_saldo: f32 = 0.0;
   let mut v_taxa: f32 = 0.0;


   println!("Informe um saldo: ");
   io::stdin().read_line(&mut v_saldo)
       .expect("Erro ao ler a entrada");


   println!("Informe uma taxa: ");
   io::stdin().read_line(&mut v_taxa)
       .expect("Erro ao ler a entrada");


   let v_resul = calcula_juros(&mut v_saldo, v_taxa);


   println!("Juros.....: {}", v_resul);
   println!("Saldo Novo: {}", v_saldo);
}
O programa acima é escrito em Rust e tem como objetivo calcular os juros de um determinado saldo com base em uma taxa fornecida pelo usuário. Ele faz isso através de uma função chamada calcula_juros() que recebe o saldo e a taxa como parâmetros e retorna o valor dos juros calculados.
A função calcula_juros() primeiro calcula os juros usando a fórmula juros = saldo * taxa / 100.0. Em seguida, atualiza o saldo somando os juros a ele. Por fim, a função retorna o valor dos juros para a função main().
A função main() é a função principal do programa e é responsável por pedir o saldo e a taxa para o usuário e chamar a função calcula_juros(). Depois que a função calcula_juros() retorna, a função main() imprime o valor dos juros e o novo saldo.


O programa acima usa ponteiros na função calcula_juros(). A função recebe o saldo como um ponteiro mutável para um valor do tipo f32, ou seja, um ponteiro para um valor de ponto flutuante de 32 bits. Isso é feito para que a função possa modificar o saldo passado como parâmetro e refletir essa mudança no código que chamou a função.
O ponteiro é usado para acessar o valor do saldo armazenado no endereço de memória apontado pelo ponteiro. Isso é feito usando o operador de dereferenciação *. Por exemplo, na linha 8, o ponteiro é usado para acessar o saldo e calcular os juros. Na linha 9, o ponteiro é usado novamente para atualizar o saldo somando os juros.
Em resumo, os ponteiros são usados ​​neste programa para permitir que a função calcula_juros() modifique o valor do saldo passado como parâmetro e reflita essa mudança no código que chamou a função. Isso é feito passando o saldo como um ponteiro mutável para a função e usando o operador de dereferenciação para acessar o valor armazenado no endereço de memória apontado pelo ponteiro.














Operações com Ponteiros


As operações com ponteiros são ações que podem ser realizadas com ponteiros em uma linguagem de programação. Algumas das operações com ponteiros mais comuns são:
Declaração de ponteiros: criação de um ponteiro para armazenar o endereço de memória de uma variável
Atribuição de endereços: atribuição de um endereço de memória a um ponteiro
Acesso ao valor armazenado no endereço de memória apontado pelo ponteiro: uso do operador de dereferenciação * para acessar o valor armazenado no endereço de memória apontado pelo ponteiro
Operações matemáticas com ponteiros: adição ou subtração de um número a um ponteiro para mover o ponteiro para um endereço de memória diferente
Essas são apenas algumas das operações com ponteiros mais comuns, mas existem outras operações que podem ser realizadas dependendo da linguagem de programação e da necessidade do programa. Alguns exemplos de outras operações com ponteiros incluem:
Comparação de ponteiros: verificação de se dois ponteiros apontam para o mesmo endereço de memória
Incremento e decremento de ponteiros: movimentação do ponteiro para o próximo ou anterior endereço de memória, respectivamente
Alocação dinâmica de memória: uso de funções especiais para alocar espaço na memória durante a execução do programa
Passagem de ponteiros como parâmetros para funções: permitir que uma função modifique o valor de uma variável fora da função através de um ponteiro
Em resumo, as operações com ponteiros são ações que podem ser realizadas com ponteiros em uma linguagem de programação e permitem que os ponteiros sejam usados ​​para armazenar e acessar endereços de memória, realizar operações matemáticas e comparar ponteiros, entre outras coisas.
Em Rust, a declaração de ponteiros é feita usando o símbolo * seguido pelo tipo de dado para o qual o ponteiro irá apontar. Por exemplo, para declarar um ponteiro para um valor inteiro, você pode usar a seguinte sintaxe:




let ponteiro_inteiro: *const i32;
Nesse exemplo, ponteiro_inteiro é um ponteiro para um valor inteiro que é imutável (const). Se você quiser um ponteiro mutável para um inteiro, pode usar a seguinte sintaxe:




let mut ponteiro_inteiro: *mut i32;
Observe que, além do tipo de dado, é preciso especificar se o ponteiro é mutável ou imutável. Isso é feito usando os modificadores mut ou const, respectivamente.


Após a declaração do ponteiro, você pode atribuir um endereço de memória a ele usando o operador de endereçamento &. Por exemplo:




let valor = 10;
let mut ponteiro_inteiro: *mut i32;
ponteiro_inteiro = &valor;




Nesse exemplo, o ponteiro ponteiro_inteiro está sendo atribuído o endereço de memória da variável valor.
A atribuição de endereços a um ponteiro é feita usando o operador de endereçamento &. Por exemplo, para atribuir o endereço de memória da variável valor ao ponteiro ponteiro_inteiro, você pode usar a seguinte sintaxe:




let valor = 10;
let mut ponteiro_inteiro: *mut i32;
ponteiro_inteiro = &valor;




Nesse exemplo, o ponteiro ponteiro_inteiro está sendo atribuído o endereço de memória da variável valor. Isso significa que o ponteiro agora está "apontando" para a variável valor.


É importante lembrar que, para atribuir um endereço de memória a um ponteiro, o ponteiro deve ser mutável. Se o ponteiro for imutável, você não poderá alterar o endereço de memória ao qual ele aponta.


Além disso, é preciso tomar cuidado ao trabalhar com ponteiros para garantir que você não acesse endereços de memória inválidos ou não alocados, o que pode causar comportamentos inesperados ou até mesmo falhas no programa.
Para acessar o valor armazenado no endereço de memória apontado por um ponteiro em Rust, é preciso usar o operador de dereferenciação *. Por exemplo, para acessar o valor armazenado no endereço de memória apontado pelo ponteiro ponteiro_inteiro e atribuir esse valor à variável valor_apontado_pelo_ponteiro, você pode usar a seguinte sintaxe:


let valor = 10;
let mut ponteiro_inteiro: *mut i32;
ponteiro_inteiro = &valor;


let valor_apontado_pelo_ponteiro = *ponteiro_inteiro;
Nesse exemplo, o valor armazenado no endereço de memória apontado pelo ponteiro ponteiro_inteiro é atribuído à variável valor_apontado_pelo_ponteiro. No caso, esse valor seria igual a 10, que é o valor armazenado na variável valor.


As operações matemáticas com ponteiros em Rust permitem que você adicione ou subtraia um número de um ponteiro para mover o ponteiro para um endereço de memória diferente. Isso é útil, por exemplo, quando você está trabalhando com arrays e precisa percorrê-los usando um ponteiro.


Para realizar operações matemáticas com ponteiros em Rust, basta usar os operadores de adição + e subtração -. Por exemplo, para adicionar 1 a um ponteiro, você pode usar a seguinte sintaxe:




let mut ponteiro_inteiro: *mut i32;


// adiciona 1 ao ponteiro
ponteiro_inteiro = ponteiro_inteiro + 1;
Da mesma forma, para subtrair 1 de um ponteiro, você pode usar a seguinte sintaxe:




let mut ponteiro_inteiro: *mut i32;


// subtrai 1 do ponteiro
ponteiro_inteiro = ponteiro_inteiro - 1;
Observe que essas operações matemáticas com ponteiros só são possíveis para ponteiros mutáveis. Além disso, é preciso tomar cuidado ao trabalhar com ponteiros para garantir que você não acesse endereços de memória inválidos ou não alocados, o que pode causar comportamentos inesperados ou até mesmo falhas no programa.


Aqui estão alguns exemplos de testes de mesa para as operações matemáticas com ponteiros em Rust:
Adição de 1 a um ponteiro
Valor inicial do ponteiro
Valor final do ponteiro
0x000001
0x000002
0x000005
0x000006
0x000010
0x000011

Subtração de 1 de um ponteiro
Valor inicial do ponteiro
Valor final do ponteiro
0x000002
0x000001
0x000006
0x000005
0x000011
0x000010

Esses são apenas alguns exemplos de como as operações matemáticas com ponteiros podem ser usadas em Rust. Vejamos outros:

Adição de 2 a um ponteiro
Valor inicial do ponteiro
Valor final do ponteiro
0x000001
0x000003
0x000005
0x000007
0x000010
0x000012

Código Rust:


let mut ponteiro_inteiro: *mut i32; // adiciona 2 ao ponteiro ponteiro_inteiro = ponteiro_inteiro + 2;








Subtração de 3 de um ponteiro
Valor inicial do ponteiro
Valor final do ponteiro
0x000003
0x00000000
0x000007
0x000004
0x000012
0x00000F

Código Rust:


let mut ponteiro_inteiro: *mut i32; // subtrai 3 do ponteiro ponteiro_inteiro = ponteiro_inteiro - 3;






Esses são apenas alguns exemplos de como as operações matemáticas com ponteiros podem ser usadas em Rust.






Aqui está um exemplo de como uma operação matemática com ponteiros pode falhar em Rust:


let mut ponteiro_inteiro: *mut i32;


// tenta subtrair 1 do ponteiro
ponteiro_inteiro = ponteiro_inteiro - 1;
Neste caso, a operação matemática falha porque o ponteiro ponteiro_inteiro não está apontando para um endereço de memória válido. Como o ponteiro não foi inicializado, ele está apontando para um endereço de memória inválido, o que faz com que a operação matemática falhe.


Para evitar esse tipo de problema, é importante garantir que o ponteiro está apontando para um endereço de memória válido antes de tentar realizar qualquer operação matemática com ele. Além disso, é preciso tomar cuidado ao trabalhar com ponteiros para garantir que você não acesse endereços de memória inválidos ou não alocados, o que pode causar comportamentos inesperados ou até mesmo falhas no programa.


Comparação de ponteiros


As operações de comparação com ponteiros em Rust permitem comparar dois ponteiros entre si, levando em consideração suas posições de memória. Isso é útil para saber se dois ponteiros apontam para a mesma posição de memória, ou se um está antes ou depois do outro. Essas operações são importantes porque permitem que o código Rust manipule a memória de forma mais precisa e segura, evitando problemas como acesso a memória incorreta ou liberação de memória múltiplas vezes. Além disso, elas são necessárias para implementar algumas estruturas de dados, como listas encadeadas, que dependem da posição de memória dos elementos para funcionar corretamente.


A seguir, apresento uma tabela com as operações de comparação com ponteiros em Rust:
Operação
Descrição
p1 == p2
Verifica se os ponteiros p1 e p2 apontam para o mesmo endereço de memória.
p1 != p2
Verifica se os ponteiros p1 e p2 não apontam para o mesmo endereço de memória.
p1 < p2
Verifica se o endereço apontado por p1 é menor que o endereço apontado por p2.
p1 > p2
Verifica se o endereço apontado por p1 é maior que o endereço apontado por p2.
p1 <= p2
Verifica se o endereço apontado por p1 é menor ou igual ao endereço apontado por p2.
p1 >= p2
Verifica se o endereço apontado por p1 é maior ou igual ao endereço apontado por p2.

Importante lembrar que as operações de comparação com ponteiros só são permitidas quando os ponteiros apontam para elementos de um mesmo array. É ilegal comparar ponteiros que apontam para elementos de arrays diferentes ou para elementos que não são parte de um array. Além disso, é ilegal comparar ponteiros nulos com outros ponteiros.




Incremento e decremento de ponteiros


Em Rust, os ponteiros são usados ​​para acessar dados em uma localização de memória. Os operadores de incremento e decremento são usados ​​para mover o ponteiro para uma localização de memória adjacente.


O operador de incremento ++ move o ponteiro para a próxima posição de memória e o operador de decremento -- move o ponteiro para a posição de memória anterior. Por exemplo:




let mut x = 5;
let p = &mut x;


*p += 1;
println!("{}", x); // 6


p += 1; // Erro de compilação: não é permitido incrementar ponteiros mutáveis
Os operadores de incremento e decremento só são permitidos em ponteiros não mutáveis ​​e apenas para tipos que implementam o trait Copy. Além disso, eles só podem ser usados ​​em ponteiros para arrays ou para tipos de tamanho fixo, como [i32; 5] ou u8.


Ao usar um ponteiro como um iterador, é comum usar os operadores de incremento e decremento para mover o ponteiro para a próxima ou posição anterior na memória. Por exemplo:




let arr = [1, 2, 3, 4, 5];
let mut p = &arr[0];


while p != &arr[5] {
   println!("{}", *p);
   p += 1;
}
Neste exemplo, o ponteiro p é inicializado com o endereço do primeiro elemento do array e é então incrementado a cada iteração do loop até chegar ao último elemento. A cada iteração, o valor apontado pelo ponteiro é impresso.




Você também pode usar os operadores de incremento e decremento para mover um ponteiro para a próxima ou posição anterior em um slice. Por exemplo:




let arr = [1, 2, 3, 4, 5];
let slice = &arr[1..4];
let mut p = slice.as_ptr();


while p != slice.as_ptr().add(slice.len()) {
   println!("{}", unsafe { *p });
   p = p.add(1);
}
Neste exemplo, o ponteiro p é inicializado com o endereço do primeiro elemento do slice e é então incrementado a cada iteração do loop até chegar ao último elemento. A cada iteração, o valor apontado pelo ponteiro é impresso usando a função unsafe *p.


Em resumo, os operadores de incremento e decremento são usados ​​para mover um ponteiro para a próxima ou posição anterior em uma área de memória e podem ser usados ​​para iterar sobre arrays ou slices. No entanto, eles só são permitidos em ponteiros não mutáveis ​​e apenas para tipos que implementam o trait Copy.


Aqui está um exemplo de teste de mesa para o uso dos operadores de incremento e decremento em Rust:


Inicialmente:
x = [1, 2, 3, 4, 5]
p = &x[1]


p++
p aponta para 2


p--
p aponta para 1


p += 2
p aponta para 3


p -= 1
p aponta para 2


Neste exemplo, o ponteiro p é inicializado com o endereço do segundo elemento do array e é então movido para a frente e para trás usando os operadores de incremento e decremento. Ele também é movido duas posições para a frente usando o operador de adição e uma posição para trás usando o operador de subtração. Ao final, o ponteiro p aponta para o terceiro elemento do array.
Veja o diagrama de sequencia



Este diagrama mostra as etapas do teste de mesa, começando com a inicialização do array x e do ponteiro p, seguido pelo uso dos operadores de incremento e decremento para mover o ponteiro para a frente e para trás e para a próxima ou posição anterior na memória.






Alocação dinâmica de memória


Em Rust, é possível alocar espaço na memória dinamicamente durante a execução do programa usando funções especiais. Isso é útil quando você não sabe quanto espaço será necessário no momento em que o programa é compilado, ou se você precisa alocar um grande espaço de memória que não precisa ser usado constantemente.


A função Box::new é um dos meios mais comuns de se alocar memória dinamicamente em Rust. Ela cria uma caixa (box) que armazena um valor e gerencia a memória alocada para esse valor. A caixa é uma estrutura que implementa o trait Drop, que é chamado quando a caixa sai de escopo, liberando assim a memória alocada. Por exemplo:




let b = Box::new(5);
println!("{}", *b); // 5
A função Box::new aloca um novo espaço na memória para armazenar o valor 5 e retorna uma caixa que aponta para esse valor. Para acessar o valor armazenado na caixa, precisamos desreferenciá-la usando o operador de desreferenciação *.


Além de Box::new, também é possível alocar memória usando a função Vec::new. O Vec é um tipo de dado que armazena uma sequência de valores em uma área de memória contígua e pode ser redimensionado dinamicamente. Por exemplo:




let mut v = Vec::new();


v.push(1);
v.push(2);
v.push(3);


println!("{:?}", v); // [1, 2, 3]
Neste exemplo, o Vec é inicializado como vazio e então três valores são adicionados a ele usando o método push. O Vec gerencia automaticamente a memória necessária para armazenar esses valores e redimensiona se necessário.


Além de Box::new e Vec::new, também é possível alocar memória usando as funções alloc::alloc e alloc::alloc_zeroed da biblioteca de alloc do Rust. Essas funções permitem que você aloque um determinado tamanho de memória e retornem um ponteiro para essa área de memória. No entanto, é importante lembrar de liberar essa memória quando ela não for mais necessária, usando a função alloc::dealloc.


As funções alloc::alloc e alloc::alloc_zeroed são funções da biblioteca de alloc do Rust que permitem alocar espaço na memória dinamicamente durante a execução do programa. Elas são úteis quando você precisa de um controle mais preciso sobre a alocação de memória do que o que é oferecido pelas estruturas de dados padrão, como Box e Vec.


A função alloc::alloc aloca um determinado tamanho de memória e retorna um ponteiro para essa área de memória. Por exemplo:




use std::alloc::{alloc, dealloc, Layout};


fn main() {
   let layout = Layout::new::<i32>();
   let ptr = unsafe { alloc(layout) as *mut i32 };


   if !ptr.is_null() {
       unsafe { *ptr = 5 };
       println!("{}", unsafe { *ptr }); // 5
   }


   unsafe { dealloc(ptr as *mut u8, layout) };
}
Neste exemplo, a função alloc é chamada para alocar um espaço de memória suficiente para armazenar um i32. O layout é usado para especificar o tamanho e alinhamento do tipo de dados que será armazenado. Se a alocação for bem-sucedida, o ponteiro retornado é usado para armazenar o valor 5 e então imprimir o valor armazenado. Quando o ponteiro não é mais necessário, a função dealloc é chamada para liberar a memória alocada.


A função alloc::alloc_zeroed é semelhante à função alloc::alloc, mas aloca um espaço de memória e inicializa todos os bytes com zero. Por exemplo:




use std::alloc::{alloc_zeroed, dealloc, Layout};


fn main() {
   let layout = Layout::new::<i32>();
   let ptr = unsafe { alloc_zeroed(layout) as *mut i32 };


   if !ptr.is_null() {
       println!("{}", unsafe { *ptr }); // 0
   }


   unsafe { dealloc(ptr as *mut u8, layout) };
}
Neste exemplo, a função alloc_zeroed é chamada para alocar um espaço de memória suficiente para armazenar um i32 e inicializar todos os bytes com zero. O ponteiro retornado é então usado para imprimir o valor armazenado, que deve ser zero. Quando o ponteiro não é mais necessário, a função dealloc é chamada para liberar a memória alocada.


Aqui está um exemplo de programa em Rust que usa a função alloc para alocar memória para um tipo básico e para um vetor:




use std::alloc::{alloc, dealloc, Layout};


fn main() {
   // Aloca memória para um i32
   let layout = Layout::new::<i32>();
   let ptr = unsafe { alloc(layout) as *mut i32 };


   if !ptr.is_null() {
       unsafe { *ptr = 5 };
       println!("Valor de i32: {}", unsafe { *ptr });
   }


   // Aloca memória para um vetor de i32
   let layout = Layout::array::<i32>(5).unwrap();
   let ptr = unsafe { alloc(layout) as *mut [i32; 5] };


   if !ptr.is_null() {
       unsafe { (*ptr)[0] = 1; (*ptr)[1] = 2; (*ptr)[2] = 3; (*ptr)[3] = 4; (*ptr)[4] = 5 };
       println!("Valor do vetor: {:?}", unsafe { *ptr });
   }


   // Libera a memória alocada
   unsafe { dealloc(ptr as *mut u8, layout) };
}
Neste exemplo, a função alloc é chamada duas vezes, uma vez para alocar memória para um i32 e outra vez para alocar memória para um vetor de i32. O layout é usado para especificar o tamanho e alinhamento do tipo de dados que será armazenado. Se a alocação for bem-sucedida, o ponteiro retornado é usado para armazenar valores e então imprimir o valor armazenado. Quando a memória não é mais necessária, a função dealloc é chamada para liberá-la.


Observe que, neste exemplo, estamos usando a função unsafe para acessar a memória alocada diretamente usando o ponteiro. Isso é considerado prática insegura em Rust e só deve ser usado se você tiver certeza de que está fazendo o gerenciamento de memória de forma segura. Em geral, é melhor usar estruturas de dados que gerenciam a memória de forma automática, como Box e Vec, ao invés de usar a função alloc diretamente.


Vale salientar que Layout é uma estrutura de dados que representa os requisitos de tamanho e alinhamento de um tipo de dados em Rust. Ele é usado pelas funções alloc e alloc_zeroed da biblioteca de alloc para especificar o tamanho e alinhamento da memória que deve ser alocada.


Para criar um Layout, você pode usar o método estático Layout::new para especificar o tamanho e alinhamento de um tipo de dados simples, como um i32 ou um f64. Por exemplo:




let layout = Layout::new::<i32>();
Para criar um Layout para um vetor ou estrutura de dados, você pode usar o método estático Layout::array ou Layout::new, respectivamente. Por exemplo:




let layout = Layout::array::<i32>(5).unwrap();


#[repr(C)]
struct Point {
   x: f32,
   y: f32,
}


let layout = Layout::new::<Point>();
Uma vez que você criou um Layout, você pode passá-lo para as funções alloc e alloc_zeroed para alocar a memória necessária para armazenar o tipo de dados especificado. Depois que a memória não é mais necessária, você pode usar a função dealloc para liberá-la.


Em resumo, o Layout é usado para especificar os requisitos de tamanho e alinhamento de um tipo de dados quando se aloca memória dinamicamente em Rust. Ele é usado pelas funções alloc e alloc_zeroed da biblioteca de alloc para gerenciar a memória alocada de forma segura.


O alinhamento de um tipo de dados em Rust é o número de bytes mínimo que um tipo de dados deve ocupar em memória. Isso é usado para garantir que os dados em memória sejam acessados de forma eficiente pelo processador.
Em Rust, o alinhamento de um tipo de dados é determinado pelo maior alinhamento de qualquer um de seus campos. Por exemplo, o alinhamento de um i32 é de 4 bytes, já que é o maior alinhamento de qualquer um de seus campos. Já o alinhamento de um f64 é de 8 bytes, já que é o maior alinhamento de qualquer um de seus campos.
O alinhamento também é usado para garantir que os dados em memória sejam armazenados em posições de memória que são múltiplos de seu alinhamento. Isso é importante para garantir que o processador possa acessar os dados de forma eficiente, sem ter que realizar operações de desalinhamento.
Por exemplo, se você tem um vetor de i32 e quer armazená-lo em memória, o vetor será armazenado em posições de memória que são múltiplos de 4 (o alinhamento de um i32). Isso garante que o processador possa acessar os elementos do vetor de forma eficiente, sem ter que realizar operações de desalinhamento.
O alinhamento de um tipo de dados em Rust é o número de bytes mínimo que um tipo de dados deve ocupar em memória e é usado para garantir que os dados em memória sejam acessados de forma eficiente pelo processador.


Já um exemplo de como usar a função alloc_zeroed para alocar e inicializar um vetor de i32 com zeros em Rust:




use std::alloc::{alloc_zeroed, dealloc, Layout};


fn main() {
   // Aloca memória para um vetor de i32 e inicializa todos os bytes com zero
   let layout = Layout::array::<i32>(5).unwrap();
   let ptr = unsafe { alloc_zeroed(layout) as *mut [i32; 5] };


   if !ptr.is_null() {
       println!("Valor do vetor: {:?}", unsafe { *ptr });
   }


   // Libera a memória alocada
   unsafe { dealloc(ptr as *mut u8, layout) };
}
Neste exemplo, a função alloc_zeroed é chamada para alocar um espaço de memória suficiente para armazenar um vetor de i32 e inicializar todos os bytes com zero. O layout é usado para especificar o tamanho e alinhamento do tipo de dados que será armazenado. Se a alocação for bem-sucedida, o ponteiro retornado é usado para imprimir o valor armazenado, que deve ser um vetor de zeros. Quando a memória não é mais necessária, a função dealloc é chamada para liberá-la.


Aqui está um teste de mesa para o programa de exemplo que usa a função alloc_zeroed para alocar e inicializar um vetor de i32 com zeros em Rust:
Passo
Valor de ptr
Valor de *ptr
1
Ponteiro para o início do vetor alocado
[0, 0, 0, 0, 0]
2
Ponteiro para o início do vetor alocado
[0, 0, 0, 0, 0]

No primeiro passo, a função alloc_zeroed é chamada para alocar um espaço de memória suficiente para armazenar um vetor de i32 e inicializar todos os bytes com zero. O ponteiro retornado aponta para o início do vetor alocado.
No segundo passo, o ponteiro é usado para imprimir o valor armazenado, que deve ser um vetor de zeros.






Passagem de ponteiros como parâmetros para funções é uma técnica comum em linguagens de programação, incluindo Rust. A ideia é passar a localização de um valor armazenado na memória para uma função, em vez de passar o valor em si. Isso pode ser útil em várias situações, como quando você quer modificar um valor em um determinado local na memória ou quando quer economizar tempo e espaço evitando a cópia de grandes estruturas de dados.


Aqui está um exemplo de como passar um ponteiro para uma função em Rust:




fn multiplica_por_dois(numero: &mut i32) {
   *numero *= 2;
}


fn main() {
   let mut numero = 5;
   multiplica_por_dois(&mut numero);
   println!("O número agora é {}", numero); // Imprime "O número agora é 10"
}
Neste exemplo, a função multiplica_por_dois recebe um ponteiro para um valor i32 mutável como parâmetro. O &mut indica que estamos passando um ponteiro mutável para o valor. Dentro da função, o operador de asterisco * é usado para acessar o valor armazenado no endereço apontado pelo ponteiro. Isso permite que a função modifique o valor original.


Na função main, criamos uma variável numero com o valor 5 e passamos seu endereço para a função multiplica_por_dois como um ponteiro mutável. Quando a função é chamada, o valor de numero é modificado para 10.




Resumindo A seguir foi apresentado um código-fonte de exemplo que mostra um resumo das ope- rações necessárias para declarar ponteiros, atribuir e obter valores. Com as operações apresentadas neste exemplo, é possível resolver a maioria dos problemas envolvendo o uso de ponteiros em Rust.


fn main() {
   let mut p_num: *mut i32; // declaração de ponteiro
   let mut num = 10;
   let mut num2 = 20;


   p_num = &mut num; // aponta p_num para num
   *p_num = 10; // atribui valor a num por meio do apontamento
   num2 += *p_num; // atribui valor a num2 por meio do ponteiro


   // obtendo valor de variáveis
   println!("conteúdo de num: {}", num);
   println!("endereço de num: {:p}", &num);
   println!("conteúdo de num2: {}", num2);
   println!("endereço de num2: {:p}", &num2);


   // obtendo valor de ponteiros
   println!("conteúdo de p_num: {:p}", p_num);
   println!("conteúdo do apontamento de p_num: {}", *p_num);
   println!("endereço de p_num: {:p}", &p_num);
}


Uso de Ponteiros com Vetores / Matrizes


Para usar vetores e matrizes em conjunto com ponteiros, basta lembrar que cada posição de um vetor ou matriz possui um espaço de memória reservado. Dessa forma, é possível considerar uma posição de um vetor como uma variável e aplicar os conceitos de ponteiros que já foram apresentados. Além disso, é possível apontar um ponteiro para o próprio vetor ou matriz, e não somente para uma posição específica. Em resumo, é possível usar ponteiros para acessar e modificar os elementos de um vetor ou matriz de forma semelhante a como faria com variáveis normais. No entanto, é importante ter cuidado para não acessar posições fora dos limites dos arrays e para não perder a referência para os arrays originais.
Veja a seguir:


fn main() {
   let mut p_num: *mut i32; // declaração do ponteiro
   let mut vet_num = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // declaração da matriz


   p_num = &mut vet_num[0]; // aponta o ponteiro para uma posição do vetor
   *p_num = 10; // atribui valor a posição do vetor pelo ponteiro


   p_num = vet_num.as_mut_ptr(); // aponta p_num para o vetor vet_num
   p_num[1] = 20; // atribui valor a posição do vetor pelo ponteiro


   println!("Posição 1: {}", vet_num[0]);
   println!("Posição 2: {}", vet_num[1]);
}




Em Rust, é possível usar ponteiros para acessar elementos em vetores e matrizes de forma semelhante ao que é feito em C.


Por exemplo, para declarar um vetor de inteiros e um ponteiro para o vetor, você pode usar o seguinte código:


Copy code
let mut vector = [1, 2, 3, 4, 5];
let mut vector_ptr: *mut i32 = vector.as_mut_ptr();
Aqui, o ponteiro vector_ptr aponta para o primeiro elemento do vetor vector. Você pode usar o ponteiro para acessar e modificar os elementos do vetor de duas formas:


Dereferenciando o ponteiro e usando índices:
Copy code
(*vector_ptr)[0] = 10;
(*vector_ptr)[1] = 20;
Usando os operadores de deslocamento de ponteiro (ptr.offset(n)):
Copy code
*vector_ptr.offset(0) = 10;
*vector_ptr.offset(1) = 20;
Observe que, em ambos os casos, é preciso usar o operador de dereferenciação * para acessar o conteúdo apontado pelo ponteiro.


Para acessar elementos em matrizes, basta usar índices aninhados, assim como faria com vetores normais:


Copy code
let mut matrix = [[1, 2], [3, 4], [5, 6]];
let mut matrix_ptr: *mut i32 = matrix[0].as_mut_ptr();


(*matrix_ptr)[0] = 10;
(*matrix_ptr)[1] = 20;
Ou:


Copy code
*matrix_ptr.offset(0) = 10;
*matrix_ptr.offset(1) = 20;
É importante lembrar que, ao usar ponteiros para acessar elementos em vetores e matrizes, é preciso ter cuidado para não tentar acessar posições fora dos limites desses arrays, pois isso pode causar comportamentos inesperados ou até mesmo um erro de execução.


Além disso, é preciso tomar cuidado para não perder a referência para os arrays originais, pois isso pode resultar em vazamento de memória. Por exemplo, ao usar ponteiros para modificar elementos em um vetor ou matriz, é preciso ter certeza de que o vetor ou matriz ainda está em escopo enquanto o ponteiro ainda é válido.




Ponteiros Genéricos


Às vezes, precisamos trabalhar com dados sem saber qual o tipo específico deles. Nestes casos, podemos usar ponteiros genéricos. Estes ponteiros são declarados usando a sintaxe *mut T ou *const T, onde T é um tipo genérico. Eles permitem que apontemos para qualquer tipo de dado, incluindo aqueles definidos pelo próprio programador. No entanto, é importante lembrar que ponteiros genéricos não podem ser usados para acessar ou modificar os dados diretamente, pois eles podem apontar para qualquer tipo de dado.


Em Rust, eles são implementados usando a sintaxe de tipo *mut T ou *const T, onde T é um tipo de dado genérico.


Por exemplo, você pode criar um ponteiro genérico para um valor mutável assim:


let x = 5;
let y = &mut x;


Neste exemplo, y é um ponteiro para um valor mutável do tipo i32. Você também pode criar um ponteiro genérico para um valor constante assim:




let x = 5;
let y = &x;


Neste exemplo, y é um ponteiro para um valor constante do tipo i32.


Ponteiros genéricos são úteis quando você precisa trabalhar com dados sem saber qual o tipo específico deles. Eles são comumente usados em funções que precisam aceitar qualquer tipo de dado como argumento ou retornar qualquer tipo de dado como resultado. No entanto, é importante lembrar que ponteiros genéricos têm algumas restrições em relação ao seu uso, pois eles podem apontar para qualquer tipo de dado e, portanto, não podem ser usados para acessar ou modificar os dados diretamente.


Como ponteiros genéricos são ponteiros que podem apontar para qualquer tipo de dado. Isso significa que eles não possuem informações sobre o tipo de dado para o qual estão apontando. Portanto, não é possível usá-los para acessar ou modificar os dados diretamente. Isso ocorre porque o compilador não sabe qual o tipo de dado que está sendo apontado, então ele não sabe como acessar ou modificar os dados corretamente.


Para acessar ou modificar os dados apontados por um ponteiro genérico, é necessário primeiro especificar o tipo de dado para o qual o ponteiro está apontando. Isso pode ser feito usando a coerção de tipo ou a função de "dereferenciamento" *. Por exemplo:




let x = 5;
let y: *mut i32 = &mut x;
let z: &mut i32 = unsafe { &mut *y };


*z = 10;


Neste exemplo, y é um ponteiro genérico para um valor mutável do tipo i32. Para acessar o valor apontado por y, usamos a função de dereferenciamento * para obter uma referência mutável para o valor e, em seguida, atribuímos o valor 10 a ele.


É importante lembrar que o uso de ponteiros genéricos e a coerção de tipo podem ser perigosos e devem ser usados com cuidado, pois eles podem levar a problemas de segurança de tipo e falhas de acesso a memória. É sempre recomendável evitar o uso de ponteiros genéricos sempre que possível e, quando for necessário usá-los, ter muito cuidado para garantir que o código esteja correto e seguro.




Ponteiro para Ponteiro


De forma geral, um ponteiro para ponteiro é um ponteiro que armazena um endereço de memória que, por sua vez, aponta para outro endereço de memória. Isso é útil quando você quer passar um ponteiro como parâmetro para uma função ou alterar o valor de um ponteiro dentro de uma função. Em Rust, é possível criar ponteiros com vários níveis de apontamento, ou seja, um ponteiro que aponta para outro ponteiro, que aponta para outro ponteiro, e assim por diante. Isso pode ser útil em determinadas situações, mas é importante lembrar que o uso excessivo de ponteiros pode aumentar a complexidade do código e aumentar o risco de erros de segurança.


Um ponteiro para ponteiro é um ponteiro que aponta para outro ponteiro. Isso é útil quando você quer passar um ponteiro como parâmetro para uma função ou mudar o valor de um ponteiro em uma função.


Para declarar um ponteiro para ponteiro em Rust, basta adicionar um símbolo & adicional na frente do tipo. Por exemplo, um ponteiro para ponteiro para um inteiro seria declarado como &&i32.


Aqui está um exemplo de como usar um ponteiro para ponteiro em Rust:




fn main() {
   let mut x = 5;
   let y = &mut x;


   // `z` é um ponteiro para ponteiro para inteiro
   let z = &&mut x;


   **z += 1;


   println!("x = {}", x); // imprime "x = 6"
}
No exemplo acima, x é uma variável do tipo i32 e y é um ponteiro mutável para x. z é um ponteiro para ponteiro para x, ou seja, um ponteiro para o ponteiro y. Ao acessarmos o valor de z usando duas vezes o símbolo *, obtemos o valor de x, que é alterado para 6.
let z = &&mut x;
Nesta linha, z é declarada como um ponteiro para ponteiro para x, ou seja, um ponteiro que aponta para o ponteiro y, que por sua vez aponta para o valor de x. Isso é indicado pelo uso de dois símbolos & na frente do tipo.


Para acessar o valor de x através do ponteiro para ponteiro, é preciso usar duas vezes o símbolo *, como na seguinte linha:




**z += 1;
Aqui, o valor de x é acessado usando **z, o que significa "o valor apontado pelo ponteiro apontado por z". Como z é um ponteiro para ponteiro, o valor de x é obtido através de dois desreferenciamentos.




Outro exemplo:


fn add_one(x: &&mut i32) {
   **x += 1;
}


fn main() {
   let mut x = 5;
   let y = &mut x;


   // Passa o ponteiro `y` como parâmetro para a função `add_one`
   add_one(&mut y);


   println!("x = {}", x); // imprime "x = 6"
}
Observe que agora a função add_one recebe um ponteiro para ponteiro e, para acessar o valor apontado pelo ponteiro, precisamos usar duas vezes o operador de desreferenciação (*). Isso é necessário porque o ponteiro para ponteiro aponta para outro ponteiro, e precisamos desreferenciar duas vezes para chegar ao valor original apontado pelo ponteiro mutável.


Outro exemplo de ponteiro para ponteiro


fn main() {
   let x: i32;
   let p: *mut i32;
   let p2: *mut *mut i32;


   x = 10; //atribuindo valor a x
   p = &mut x; //apontando p para x
   p2 = &mut p; //apontando p2 para p


   println!("Conteudo de p2: {:?}", p2);
   println!("Conteudo em que p2 aponta: {:?}", unsafe { *p2 });
   println!("Conteudo em que p aponta: {:?}", unsafe { **p2 });
}
Observe que, para acessar os valores apontados pelos ponteiros, é necessário usar o bloco unsafe e o operador de desreferenciação (*). Isso é necessário porque o Rust não permite acessar os valores apontados por ponteiros de forma segura sem a utilização de unsafe. Além disso, é importante notar que os ponteiros em Rust são sempre mutáveis, então não é necessário especificar o modificador mut quando declaramos os ponteiros p e p2.




Exercícios


1. Escreva um programa que contenha duas variáveis inteiras. Compare seus enderços e exiba o maior endereço.


fn main() {
   let mut x = 5;
   let mut y = 10;


   // Obter os endereços das variáveis x e y usando o operador &
   let x_ptr = &x as *const i32;
   let y_ptr = &y as *const i32;


   // Comparar os endereços usando os operadores < e >
   if x_ptr > y_ptr {
       println!("O endereço de x é maior que o endereço de y.");
   } else if y_ptr > x_ptr {
       println!("O endereço de y é maior que o endereço de x.");
   } else {
       println!("Os endereços de x e y são iguais.");
   }
}


Aqui está uma nova tabela com os endereços simulados de x_ptr e y_ptr, e as saídas preenchidas de acordo com o programa:
Passo
x
y
x_ptr
y_ptr
Saída
1
5
10
0x01
0x02


2
5
10
0x01
0x02


3
5
10
0x01
0x02


4
5
10
0x01
0x02


5
5
10
0x01
0x02
O endereço de y é maior que o de x



2. Crie um programa que leia números reais em um vetor de tamanho 3. Imprima o endereço de cada posição desse vetor.


fn main() {
   // Declara um vetor de tamanho 3 para armazenar números reais
   let mut vetor: [f64; 3] = [0.0, 0.0, 0.0];


   // Lê três números reais do usuário
   println!("Insira três números reais:");
   for i in 0..3 {
       let mut numero = String::new();
       std::io::stdin().read_line(&mut numero).expect("Falha ao ler a entrada");
       vetor[i] = numero.trim().parse().expect("Falha ao converter para f64");
   }


   // Imprime os endereços de cada posição do vetor usando ponteiros
   println!("Endereços do vetor:");
   for i in 0..3 {
       println!("vetor[{}] = {}", i, &vetor[i] as *const f64);
   }
}


Aqui está um teste de mesa para o programa que eu apresentei acima, que lê três números reais em um vetor e imprime os endereços de cada posição desse vetor usando ponteiros:
Entrada
Processamento
Saída
3.14, 2.72, 1.41
Lê os números reais e armazena-os no vetor
-
-
Imprime os endereços de cada posição do vetor usando ponteiros
vetor[0] = 0x7ffc63f7c4b0<br>
vetor[1] = 0x7ffc63f7c4b8<br>
vetor[2] = 0x7ffc63f7c4c0





3. Crie um programa que contenha um vetor de inteiros com tamanho 5. Utilizando apenas ponteiros, leia valores e armazene neste vetor e após isso, imprima o dobro de cada valor lido.


fn main() {
   // Declara um vetor de tamanho 5 para armazenar inteiros
   let mut vetor: [i32; 5] = [0, 0, 0, 0, 0];


   // Lê valores e armazena-os no vetor usando ponteiros
   println!("Insira cinco valores inteiros:");
   for i in 0..5 {
       let mut valor = String::new();
       std::io::stdin().read_line(&mut valor).expect("Falha ao ler a entrada");
       let valor: i32 = valor.trim().parse().expect("Falha ao converter para i32");
       *vetor.get_unchecked_mut(i) = valor;
   }


   // Imprime o dobro de cada valor lido usando ponteiros
   println!("Valores dobrados:");
   for i in 0..5 {
       println!("{}", *vetor.get_unchecked(i) * 2);
   }
}


ATENÇÃO


get_unchecked_mut é uma função do módulo std::slice que permite acessar elementos de um slice (que é um tipo de dado que representa uma fatia de um vetor) sem fazer verificações de limite. Isso pode ser útil em situações em que você já sabe que o índice fornecido está dentro dos limites do slice e, portanto, não há necessidade de realizar verificações de limite.


Ao usar get_unchecked_mut, é importante ter cuidado para garantir que o índice fornecido realmente esteja dentro dos limites do slice, pois caso contrário o comportamento do programa pode ser indeterminado.


Aqui está um exemplo de como get_unchecked_mut pode ser usado para acessar elementos de um slice:




fn main() {
   let mut vetor = [1, 2, 3, 4, 5];


   // Acessa o terceiro elemento do vetor sem fazer verificações de limite
   let elemento = *vetor.get_unchecked_mut(2);


   println!("O terceiro elemento do vetor é {}", elemento);
}


DEFINIÇÃO:
Em Rust, um slice (que é a palavra em inglês para "fatia") é um tipo de dado que representa uma fatia de um vetor. Ele é definido como um intervalo de elementos de um vetor e é representado por um ponteiro para o primeiro elemento da fatia e um tamanho.


Slices são úteis porque permitem acessar uma sequência de elementos de um vetor sem precisar copiar todos os elementos para um novo vetor. Eles são frequentemente usados em Rust para passar subconjuntos de dados para funções ou métodos sem precisar copiar os dados.


Aqui está um exemplo de como um slice pode ser usado em Rust:




fn main() {
   let vetor = [1, 2, 3, 4, 5];


   // Cria um slice que representa os três primeiros elementos do vetor
   let slice = &vetor[0..3];


   // Imprime os elementos do slice
   println!("Os elementos do slice são: {:?}", slice);
}
Neste exemplo, o slice é criado a partir do vetor original usando uma notação de intervalo ([início..fim]), onde início é o índice do primeiro elemento da fatia e fim é o índice do elemento após o último elemento da fatia. O slice resultante inclui os elementos do vetor original com os índices de 0 a 2 (inclusive).


O seguinte teste de mesa refere-se ao exemplo de slice apresentado acima, que cria um slice que representa os três primeiros elementos de um vetor e imprime esses elementos:
Entrada
Processamento
Saída
-
Cria um slice que representa os três primeiros elementos do vetor
slice = [1, 2, 3]
-
Imprime os elementos do slice
Os elementos do slice são: [1, 2, 3]








5. Faça um programa que receba dois valores inteiros, após receber esses dois valores, uma função deve calcular e retornar para o programa o resultado da soma e da subtração dos valores. Obs.: Apenas uma função deve realizar esta operação, desta forma, faça uso de ponteiros.


use std::io;


fn operacoes(x: i32, y: i32, soma: &mut i32, subtracao: &mut i32) {
   // Calcula a soma e a subtração dos valores x e y e armazena o resultado nos ponteiros fornecidos
   *soma = x + y;
   *subtracao = x - y;
}


fn main() {
   // Lê os dois valores inteiros
   println!("Insira o primeiro valor:");
   let mut valor1 = String::new();
   io::stdin().read_line(&mut valor1).expect("Falha ao ler a entrada");
   let valor1: i32 = valor1.trim().parse().expect("Por favor, insira um número inteiro válido");


   println!("Insira o segundo valor:");
   let mut valor2 = String::new();
   io::stdin().read_line(&mut valor2).expect("Falha ao ler a entrada");
   let valor2: i32 = valor2.trim().parse().expect("Por favor, insira um número inteiro válido");


   // Declara as variáveis para armazenar o resultado da soma e da subtração
   let mut resultado_soma = 0;
   let mut resultado_subtracao = 0;


   // Chama a função para calcular a soma e a subtração e passa as variáveis por referência para que elas possam ser modificadas pela função
   operacoes(valor1, valor2, &mut resultado_soma, &mut resultado_subtracao);


   // Imprime o resultado da soma e da subtração
   println!("Soma: {}", resultado_soma);
   println!("Subtração: {}", resultado_subtracao);
}
Aqui está uma tabela de teste de mesa para a função operacoes que calcula a soma e a subtração de dois valores inteiros:
x
y
soma
subtracao
5
3
8
2
-3
4
1
-7
0
0
0
0
-5
-2
-7
-3

Na primeira linha da tabela, os valores x e y são 5 e 3, respectivamente. A função operacoes calcula a soma dos valores como 8 e a subtração como 2.
Na segunda linha, os valores x e y são -3 e 4, respectivamente. A função operacoes calcula a soma dos valores como 1 e a subtração como -7.
Na terceira linha, os valores x e y são 0. A função operacoes calcula a soma dos valores como 0 e a subtração como 0.
Na quarta linha, os valores x e y são -5 e -2, respectivamente. A função operacoes calcula a soma dos valores como -7 e a subtração como -3.




6. Construa uma função que, recebendo como parâmetros quatro números inteiros, devolva ao módulo que o chamou os dois maiores números dentre os quatro rece- bidos. Faça um programa que leia tantos conjuntos de quatro valores quantos o usuário deseje e que acione a função para cada conjunto de valores, apresentando a cada vez os dois maiores números. Se preferir, utilize vetor para armazenar o conjunto de valores.


use std::io;


fn dois_maiores(n1: i32, n2: i32, n3: i32, n4: i32) -> (i32, i32) {
   let mut maior1 = n1;
   let mut maior2 = n2;


   if n2 > maior1 {
       maior2 = maior1;
       maior1 = n2;
   }
   if n3 > maior1 {
       maior2 = maior1;
       maior1 = n3;
   }
   if n4 > maior1 {
       maior2 = maior1;
       maior1 = n4;
   } else if n4 > maior2 {
       maior2 = n4;
   }


   (maior1, maior2)
}


fn main() {
   loop {
       println!("Insira quatro números inteiros: ");


       let mut input = String::new();
       io::stdin().read_line(&mut input).expect("Falha ao ler entrada");


       let mut numeros = input
           .split_whitespace()
           .map(|x| x.parse().expect("Não foi possível converter para inteiro"))
           .collect::<Vec<i32>>();


       if numeros.len() != 4 {
           println!("Você deve inserir exatamente quatro números");
           continue;
       }


       let (maior1, maior2) = dois_maiores(numeros[0], numeros[1], numeros[2], numeros[3]);
       println!("Os dois maiores números são: {} e {}", maior1, maior2);
   }
}








Aqui está uma tabela com teste de mesa para a função encontrar_dois_maiores que eu propus em minha resposta anterior:
a
b
c
d
maior1
maior2
10
20
30
40
40
30
50
40
30
20
50
40
60
70
80
90
90
80
100
90
80
70
100
90
-10
-20
-30
-40
-10
-20
-50
-40
-30
-20
-20
-30
-60
-70
-80
-90
-90
-80
-100
-90
-80
-70
-70
-80
0
0
0
0
0
0

Nesta tabela, eu simulei todas as combinações possíveis de valores para os parâmetros a, b, c e d, bem como os valores de maior1 e maior2 que deveriam ser retornados pela função. Por exemplo, na primeira linha, todos os valores para a, b, c e d são positivos e crescentes, então o maior valor é o valor de d (40) e o segundo maior é o valor de c (30).
Na segunda linha, os valores para a, b, c e d são positivos e decrescentes, então o maior valor é o valor de a (50) e o segundo maior é o valor de b (40).
Na terceira linha, todos os valores são positivos e crescentes, então o maior valor é o valor de d (90) e o segundo maior é o valor de c (80).
Na quarta linha, todos os valores são positivos e decrescentes, então o maior valor é o valor de a (100) e o segundo maior é o valor de b (90).
Na quinta linha, todos os valores são negativos e crescentes, então o maior valor é o valor de a (-10) e o segundo maior é o valor de b (-20).
Na sexta linha, os valores são negativos e decrescentes, então o maior valor é o valor de a (-50) e o segundo maior é o valor de b (-40).


E assim por diante.


7. Considere um vetor de 10 elementos, contendo valores inteiros. Faça um pro- grama que leia os valores para preencher esse vetor, após a leitura o programa deve invocar uma função que calcule e devolva as frequências absoluta e relativa desses valores no conjunto. (Observação: a frequência absoluta de um valor é o número de vezes que esse valor aparece no conjunto de dados; a frequência relativa é a frequência absoluta dividida pelo número total de dados.). Utilize outros dois vetores para armazenar as frequências relativas e absolutas e ao final do programa, imprima de forma tabulada os números e suas frequências absoluta e relativa.
use std::io;


fn main() {
   // Criamos dois vetores para armazenar os valores e as frequências
   let mut valores = Vec::new();
   let mut frequencias_absolutas = Vec::new();


   // Lê os valores do usuário e armazena-os no vetor "valores"
   println!("Digite os valores inteiros (um por linha):");
   loop {
       let mut valor = String::new();
       io::stdin().read_line(&mut valor).expect("Falha ao ler a entrada");
       let valor: i32 = match valor.trim().parse() {
           Ok(num) => num,
           Err(_) => break,
       };
       valores.push(valor);
   }


   // Calcula as frequências absolutas dos valores no vetor
   for valor in &valores {
       let frequencia_absoluta = valores.iter().filter(|&v| *v == *valor).count() as i32;
       frequencias_absolutas.push(frequencia_absoluta);
   }


   // Calcula as frequências relativas
   let num_dados = valores.len() as f32;
   let mut frequencias_relativas = Vec::new();
   for frequencia_absoluta in &frequencias_absolutas {
       let frequencia_relativa = *frequencia_absoluta as f32 / num_dados;
       frequencias_relativas.push(frequencia_relativa);
   }


   // Imprime os resultados em uma tabela
   println!("Valor\tFrequencia Absoluta\tFrequencia Relativa");
   for (valor, frequencia_absoluta, frequencia_relativa) in valores.iter().zip(frequencias_absolutas.iter()).zip(frequencias_relativas.iter()) {
       println!("{}\t{}\t{}", valor, frequencia_absoluta, frequencia_relativa);
   }
}


Aqui está um exemplo de tabela de teste de mesa para o código acima, considerando o seguinte vetor de valores: [1, 2, 2, 3, 3, 3, 4, 4, 4, 4].
Valor
Frequência Absoluta
Frequência Relativa
1
1
0.1
2
2
0.2
3
3
0.3
4
4
0.4

Nesta tabela, simulamos os valores que não estão presentes no vetor de valores, mas que poderiam aparecer em um conjunto real de dados. Como esses valores não aparecem no vetor, suas frequências absolutas são 0 e suas frequências relativas são 0.0.
8. O laboratório de agropecuária da Universidade Federal do Capa Bode tem um termômetro de extrema precisão, utilizado para aferir as temperaturas de uma estufa onde cultivam uma variedade de jaca transgênica, com apenas um caroço do tamanho de uma semente de laranja. O problema é que este termômetro dá os resultados na escala Kelvin (K) e os pesquisadores que atuam perto da estufa são americanos, acostumados com a escala Fahrenheit (F). Você deve criar um programa para pegar uma lista de 24 temperaturas em Kelvin e convertê-las para Fahrenheit. O problema maior é que esses pesquisadores querem que você faça essa conversão e imprima os resultados utilizando ponteiros. Para a conversão, observe as fórmulas a seguir:


F = 1.8 * (K - 273) + 32




Em que:
• F = Fahrenheit
• K = Kelvin


fn main() {
   // Lista de temperaturas em Kelvin
   let temperaturas_kelvin = [293.15, 283.15, 273.15, 263.15, 253.15, 243.15, 233.15, 223.15, 213.15, 203.15, 193.15, 183.15, 173.15, 163.15, 153.15, 143.15, 133.15, 123.15, 113.15, 103.15, 93.15, 83.15, 73.15, 63.15, 53.15];


   // Ponteiro para a primeira temperatura na lista
   let mut ponteiro_kelvin = &temperaturas_kelvin[0];


   // Laço para percorrer a lista de temperaturas
   for _ in 0..temperaturas_kelvin.len() {
       // Convertemos a temperatura para Fahrenheit usando a fórmula fornecida
       let temperatura_fahrenheit = 1.8 * (*ponteiro_kelvin - 273.0) + 32.0;


       // Imprimimos o resultado da conversão
       println!("{} K = {} F", *ponteiro_kelvin, temperatura_fahrenheit);


       // Avançamos o ponteiro para a próxima temperatura na lista
       ponteiro_kelvin = ponteiro_kelvin.offset(1);
   }
}




9. O Google está desenvolvendo um novo sistema operacional para máquinas de venda de bolinhas de borracha de R$1,00, mas precisa realizar testes no Ge- renciador de Memória desse novo sistema. Você foi contratado para fazer um programa para verificar se o gerenciador de memória está funcionando correta- mente. Seu programa deverá ler 3 números inteiros, 3 números decimais, 3 letras, armazená-las em variáveis, e depois, através de ponteiros, trocar os seus valores, substituindo todos os números inteiros pelo número 2014, os decimais por 9.99, e as letras por ’Y’. Depois da substituição, o programa deverá exibir o valor das variáveis já devidamente atualizados.


O objetivo deste exercício é familiarizar o usuário com o uso de ponteiros em programação. Ponteiros são variáveis que armazenam endereços de memória de outras variáveis, permitindo que essas variáveis sejam modificadas diretamente através dos ponteiros. Neste exercício, o usuário é solicitado a ler três números inteiros, três números decimais e três letras do usuário, armazenando-os em variáveis separadas. Em seguida, o usuário deve utilizar ponteiros para modificar os valores dessas variáveis, substituindo-os pelo número 2014, pelo valor 9.99 e pela letra 'Y', respectivamente. Depois da substituição, o programa deve exibir os novos valores das variáveis.
Este exercício é útil para entender como os ponteiros podem ser usados para modificar valores de variáveis de forma eficiente e para se familiarizar com a sintaxe de trabalho com ponteiros em uma linguagem de programação específica.


fn main() {
   // Lê os 3 números inteiros do usuário
   let mut inteiro_1: i32 = ler_inteiro("Primeiro número inteiro: ");
   let mut inteiro_2: i32 = ler_inteiro("Segundo número inteiro: ");
   let mut inteiro_3: i32 = ler_inteiro("Terceiro número inteiro: ");


   // Lê os 3 números decimais do usuário
   let mut decimal_1: f32 = ler_decimal("Primeiro número decimal: ");
   let mut decimal_2: f32 = ler_decimal("Segundo número decimal: ");
   let mut decimal_3: f32 = ler_decimal("Terceiro número decimal: ");


   // Lê as 3 letras do usuário
   let mut letra_1: char = ler_letra("Primeira letra: ");
   let mut letra_2: char = ler_letra("Segunda letra: ");
   let mut letra_3: char = ler_letra("Terceira letra: ");


   // Cria os ponteiros para cada variável
   let ponteiro_inteiro_1: *mut i32 = &mut inteiro_1;
   let ponteiro_inteiro_2: *mut i32 = &mut inteiro_2;
   let ponteiro_inteiro_3: *mut i32 = &mut inteiro_3;
   let ponteiro_decimal_1: *mut f32 = &mut decimal_1;
   let ponteiro_decimal_2: *mut f32 = &mut decimal_2;
   let ponteiro_decimal_3: *mut f32 = &mut decimal_3;
   let ponteiro_letra_1: *mut char = &mut letra_1;
   let ponteiro_letra_2: *mut char = &mut letra_2;
   let ponteiro_letra_3: *mut char = &mut letra_3;


   // Modifica os valores das variáveis através dos ponteiros
   unsafe {
       *ponteiro_inteiro_1 = 2014;
       *ponteiro_inteiro_2 = 2014;
       *ponteiro_inteiro_3 = 2014;
       *ponteiro_decimal_1 = 9.99;
       *ponteiro_decimal_2 = 9.99;
       *ponteiro_decimal_3 = 9.99;
       *ponteiro_letra_1 = 'Y';
       *ponteiro_letra_2 = 'Y';
       *ponteiro_letra_3 = 'Y';
   }


   // Exibe os novos valores das variáveis
   println!("Número inteiro 1: {}", inteiro_1);
   println!("Número inteiro 2: {}", inteiro_2);
   println!("Número inteiro 3: {}", inteiro_3);
   println!("Número decimal 1: {}", decimal_1);
   println!("Número decimal 2: {}", decimal_2);
   println!("Número decimal 3: {}", decimal_3);
   println!("Letra 1: {}", letra_1);
   println!("Letra 2: {}", letra_2);
   println!("Letra 3: {}", letra_3);
}


// Função para ler um número inteiro do usuário
fn ler_inteiro(mensagem: &str) -> i32 {
   let mut input = String::new();
   print!("{}", mensagem);
   io::stdout().flush().unwrap();
   io::stdin().read_line(&mut input).unwrap();
   input.trim().parse().unwrap()
}


// Função para ler um número decimal do usuário
fn ler_decimal(mensagem: &str) -> f32 {
   let mut input = String::new();
   print!("{}", mensagem);
   io::stdout().flush().unwrap();
   io::stdin().read_line(&mut input).unwrap();
   input.trim().parse().unwrap()
}


// Função para ler uma letra do usuário
fn ler_letra(mensagem: &str) -> char {
   let mut input = String::new();
   print!("{}", mensagem);
   io::stdout().flush().unwrap();
   io::stdin().read_line(&mut input).unwrap();
   input.trim().parse().unwrap()
}




Veja uma tabela com o teste de mesa com dados de entrada simulados


Entrada
Variável inteiro_1
Variável inteiro_2
Variável inteiro_3
Variável decimal_1
Variável decimal_2
Variável decimal_3
Variável letra_1
Variável letra_2
Variável letra_3
4
4
















5
4
5














6
4
5
6












7.5
4
5
6
7.5










8.3
4
5
6
7.5
8.3








9.7
4
5
6
7.5
8.3
9.7






A
4
5
6
7.5
8.3
9.7
A




B
4
5
6
7.5
8.3
9.7
A
B


C
4
5
6
7.5
8.3
9.7
A
B
C
Troca
2014
2014
2014
9.99
9.99
9.99
Y
Y
Y

Nesta tabela, simulamos os valores de entrada que o usuário forneceria para o programa. As variáveis inteiro_1, inteiro_2 e inteiro_3 são preenchidas com os três números inteiros fornecidos pelo usuário, enquanto as variáveis decimal_1, decimal_2 e decimal_3 são preenchidas com os três números decimais fornecidos pelo usuário. As variáveis letra_1, letra_2 e letra_3 são preenchidas com as três letras fornecidas pelo usuário. Na última linha, ocorre a troca dos valores das variáveis, substituindo-os pelo número 2014, pelo valor 9.99 e pela letra 'Y', respectivamente.


10. O departamento comercial da Batatinha S/A necessita atualizar os valores de seus produtos no seu catálogo de vendas. O presidente ordenou um reajuste de 4.78% para todos os itens. São 15 itens no catálogo. Sua tarefa é elaborar um programa que leia o valor atual dos produtos e armazene em um vetor, e após isso efetue o reajuste no valor dos produtos. O reajuste (acesso ao vetor) deverá ser feito utilizando ponteiros. Imprima na tela o valor reajustado, usando também ponteiros.


fn main() {
   // Declara o vetor de valores dos produtos e o reajuste
   let mut valores_produtos = [100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0, 800.0, 900.0, 1000.0, 1100.0, 1200.0, 1300.0, 1400.0, 1500.0];
   let reajuste = 1.0478;


   // Itera pelo vetor de valores dos produtos, usando ponteiros
   for valor_produto in valores_produtos.iter_mut() {
       // Aplica o reajuste no valor do produto atual
       *valor_produto *= reajuste;
   }


   // Imprime o valor reajustado de cada produto, usando ponteiros
   for valor_produto in valores_produtos.iter() {
       println!("Valor reajustado: {}", valor_produto);
   }
}


Alguns pontos a serem observados neste código:
O vetor de valores dos produtos é declarado como mut, pois vamos alterar seus valores ao aplicar o reajuste.
Usamos a função iter_mut para obter um iterador que permita acessar os elementos do vetor de forma mutável, através de ponteiros.
Dentro do laço de repetição, usamos o operador de dereferenciação (*) para acessar o valor apontado pelo ponteiro atual e multiplicá-lo pelo reajuste.
Na segunda iteração, usamos a função iter para obter um iterador que permita acessar os elementos do vetor de forma imutável, através de ponteiros.
Dentro do segundo laço de repetição, usamos novamente o operador de dereferenciação (*) para acessar o valor apontado pelo ponteiro atual e imprimi-lo na tela.


Aqui está uma tabela de teste de mesa para o código que foi apresentado:
Valor do produto
Reajuste
Valor reajustado
100.0
1.0478
104.78
200.0
1.0478
209.56
300.0
1.0478
315.34
400.0
1.0478
421.12
500.0
1.0478
526.9
600.0
1.0478
632.68
700.0
1.0478
738.46
800.0
1.0478
844.24
900.0
1.0478
950.02
1000.0
1.0478
1055.8
1100.0
1.0478
1161.58
1200.0
1.0478
1267.36
1300.0
1.0478
1373.14
1400.0
1.0478
1478.92
1500.0
1.0478
1584.7

Nesta tabela, simulamos os valores que seriam armazenados no vetor de valores dos produtos e os valores reajustados que seriam gerados a partir deles. Cada linha representa um produto diferente, com seu valor atual e o valor reajustado após a aplicação do reajuste de 4.78%.
Observe que, para cada produto, o valor reajustado é obtido multiplicando o valor atual pelo reajuste. Por exemplo, para o primeiro produto, o valor reajustado é obtido multiplicando 100.0 por 1.0478, resultando em 104.78.



Alocação Dinâmica de Memória


A alocação dinâmica de memória é um recurso que permite que um programa em execução solicite espaço adicional na memória do computador durante a sua execução. Isso é diferente da alocação estática de memória, onde o espaço de memória é alocado no momento em que o programa é compilado.
A alocação dinâmica de memória é muito útil quando não é possível determinar exatamente quanto espaço de memória será necessário para armazenar os dados de um programa durante a sua execução. Por exemplo, se um programa precisa ler uma grande quantidade de dados de um arquivo e armazená-los em memória, pode ser difícil saber exatamente quanto espaço de memória será necessário no momento da compilação. Nesse caso, a alocação dinâmica de memória permite que o programa solicite mais espaço de memória enquanto está em execução, conforme necessário.
Para realizar a alocação dinâmica de memória, a linguagem de programação geralmente fornece uma função especial, como malloc() em C e new em C++. Essa função pode ser chamada durante a execução do programa para solicitar um determinado tamanho de espaço de memória. Se houver espaço suficiente disponível, a função retornará um ponteiro para o início do bloco de memória alocado. Se não houver espaço suficiente, a função retornará um valor especial indicando que a alocação falhou.
É importante lembrar que a alocação dinâmica de memória também exige a liberação explícita do espaço de memória quando ele não é mais necessário. Isso é feito chamando uma função de liberação de memória, como free() em C ou delete em C++. Se isso não for feito, pode ocorrer vazamento de memória, o que pode levar a problemas de desempenho e estabilidade do programa.


É importante compreender a alocação estática de memória antes de se aprofundar na alocação dinâmica, pois isso ajuda a entender "quando" usar os conceitos de alocação dinâmica. Até agora, todos os conceitos abordados são sobre alocação estática de memória, que é quando reservamos um espaço de memória para uma variável. O tamanho da memória reservada depende do tipo de dado e do compilador, mas geralmente é o tamanho descrito na tabela 10 da aula 4. Por exemplo, o tipo int reserva 16 bits de memória. Se declararmos um vetor de inteiros com tamanho 10, o vetor reservará 10 x 16 = 160 bits. Mas como saber se os 16 bits serão suficientes para armazenar o dado ou se as 10 áreas de memória reservadas são suficientes? Talvez sejam necessárias 20 ou 50 áreas? Imagine que você precisa criar um programa para armazenar os dados de funcionários de uma pequena empresa que está crescendo e tem cerca de 30 funcionários. Como a empresa tem apenas 30 funcionários, talvez não seja necessário reservar mais do que uma área de memória para os dados de 50 funcionários, pelo menos por um tempo. Mas e se a empresa precisar contratar mais 100 funcionários de repente? Como garantir que o programa terá espaço suficiente para armazenar todos os dados? Uma opção seria reservar uma área de memória suficiente para armazenar os dados de 1000 funcionários, mas isso pode levar a desperdício de memória, pois o programa estará consumindo muita memória desnecessariamente enquanto a empresa não tiver muitos funcionários. Além disso, se a empresa crescer além de 1000 funcionários, o programa não será mais capaz de atender às necessidades da empresa. É aí que entra a alocação dinâmica de memória. Com essa técnica, podemos alocar somente a memória necessária no momento e aumentar a memória conforme a necessidade aumenta, evitando assim falta de memória ou desperdício.


Alocação Dinâmica de Memória

\end{comment}







Referências


"OpenAI. (2021). ChatGPT. Disponível em: https://openai.com/blog/chatgpt/"
SILVA, Rodrigo Freitas;AGUIAR, Marcelo Otone. Introdução ao C em 10 aulas.
https://learn.microsoft.com/pt-br/windows/dev-environment/rust/overview





AGUIAR, M. O.; SILVA, R. F. Introdução ao C em 10 aulas. Alegre : Marcelo Otone Aguiar, 2016, v.1. p.294.
%-----------------------------------------



\end{document}

